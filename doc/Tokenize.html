<!-- -*-HTML-*- -->
<!-- $Id: Tokenize.html,v 1.11 2002/12/15 18:31:15 markus Exp $ -->

<html>
  <head>
    <title>General Reference: Tokenize</title>
    <meta name="description" content="Documentation of Tokenize-class">
    <meta name="keywords" content="Documentation, Docu, Tokenize, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align=center border=0 cellspacing=10>
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class Tokenize</h1>
    <p>Derived from
      <i>none</i>
      <br>
      Derived by:
      <a href="AssParse.html">AssignmentParse</a>
      <a href="PathSrch.html">PathSearch</a></p>

    <p>#include &lt;Tokenize.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to split strings into sub-strings.</p>

    <p>This sub-strings are extracted from the beginning of the string (or the
      character behind the last found sub-string) to a passed seperator (or to
      the end of string). The seperator-character is not included in the
      result.</p>

    <p>If no further sub-string is available an empty string is returned. That
      also means that two seperators behind each other are silently skipped
      and the next following sub-string (if any) is returned.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Tokenize.html#Tokenize"><b>Tokenize</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">std::string</span></tt>&amp; <tt><span style="color:blue">string</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <tt><span style="color:purple">std::string</span></tt>&amp;</tt> </td>
        <td><a href="Tokenize.html#data"><b>data</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">std::string</span></tt></tt> </td>
        <td><a href="Tokenize.html#getActNode"><b>getActNode</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">std::string</span></tt></tt> </td>
        <td><a href="Tokenize.html#getNextNode"><b>getNextNode</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">split</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Tokenize.html#Tokenize"><b>Tokenize</b></a>&amp;</tt> </td>
        <td><a href="Tokenize.html#operator="><tt><span style="color:black"><b>operator</b></span></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">std::string</span></tt>&amp; <tt><span style="color:blue">string</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Tokenize.html#operatorcstring"><tt><span style="color:black"><b>operator</b></span> const std::string&amp;</tt></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Tokenize.html#reset"><b>reset</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Tokenize.html#~Tokenize"><b>~Tokenize</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Tokenize.html#checkIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="Tokenize"></a><b>Tokenize</b> (const std::string&amp; string)</pre>
    <dl>
      <dd><p>Defaultconstructor; getting the string to handle.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>string</code>: String to split<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="~Tokenize"></a><b>~Tokenize</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="operator="></a>Tokenize&amp; <b>operator=</b> (const std::string&amp; string)</pre>
    <dl>
      <dd><p>Assignmentoperator; sets a new string to handle. No matter
        of previous seperation, the next query starts from the beginning
        of the new string.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>string</code>: New string to split<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Tokenize&amp;: Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="checkIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks the status of the object</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Status; 0: OK</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Accessing the object</h3>
    <pre><a name="operatorcstring"></a><b>operator const std::string&amp;</b> () const</pre>
    <dl>
      <dd><p>Conversion from a tokenize-object to a std::string. Returns the
        string to handle.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string&: Handled string</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="data"></a>const std::string&amp; <b>data</b> () const</pre>
    <dl>
      <dd><p>Returns the string to handle.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string&: Handled string</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="getActNode"></a>std::string <b>getActNode</b> () const</pre>
    <dl>
      <dd><p>Returns the result of the last seperation (or the whole string if no
        node was previously extracted).</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string&: Current sub-node of the separation</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="getNextNode"></a>std::string <b>getNextNode</b> (const char split)</pre>
    <dl>
      <dd><p>Returns a sub-string consisting of the string from the end of the
        last separation (skipping of all characters equal to split) or the
        beginning of the string for the first search to the next occurence of
        split (or the end of the string). The separating characters are not
        included.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>split</code>: Character separating the parts<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: Next node (empty string at end)</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>Two following separators are ignored; the method always returns some data (if available)</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="reset"></a>void <b>reset</b> ()</pre>
    <dl>
      <dd><p>Resets the object; the next seperation starts again from the
        beginning of the string.</p></dd>
    </dl>
  </body>
</html>
