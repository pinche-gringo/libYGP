<!-- -*-HTML-*- -->
<!-- $Id: Thread.html,v 1.4 2002/12/15 00:22:12 markus Exp $ -->

<html>
  <head>
    <title>General Reference: Thread</title>
    <meta name="description" content="Documentation of Thread-class">
    <meta name="keywords" content="Documentation, Docu, Thread, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align=center border=0 cellspacing=10>
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class Thread</h1>
    <p>Derived from
      <i>none</i>
      <br>
      Derived by: <a href="Thread.html#OThread">OThread&lt;T&gt;</a></p>

    <p>#include &lt;Thread.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to execute a certain function in a thread</p>

    <p>There are two create-functions: The first calles the passed function with
      the parameters directly; the second passed a pointer to the created thread
      and enables to get the paramters with its getArgs-method. This enables
      controlling the thread.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Thread.html#cancel"><b>cancel</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt>static <a href="Thread.html">Thread</a>*</tt> </td>
        <td><a href="Thread.html#create"><b>create</b></a></td>
        <td><tt>(<tt><span style="color:navy">THREAD_FUNCTION</span></tt> <tt><span style="color:blue">fnc</span></tt>, <tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">paArgs</span></tt>)
          throw (<tt><span style="color:navy">std::string</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>static <a href="Thread.html">Thread</a>*</tt> </td>
        <td><a href="Thread.html#create2"><b>create2</b></a></td>
        <td><tt>(<tt><span style="color:navy">THREAD_FUNCTION</span></tt> <tt><span style="color:blue">fnc</span></tt>, <tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">paArgs</span></tt>)
          throw (<tt><span style="color:navy">std::string</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">long</span></tt></tt> </td>
        <td><a href="Thread.html#currentID"><b>currentID</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt>*</tt> </td>
        <td><a href="Thread.html#getArgs"><b>getArgs</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">long</span></tt></tt> </td>
        <td><a href="Thread.html#getID"><b>getID</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Thread.html#isToCancel"><b>isToCancel</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Thread.html#ret"><b>ret</b></a></td>
        <td><tt>(<tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">rc</span></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:purple">void</span></tt>*</tt> </td>
        <td><a href="Thread.html#waitForThread"><b>waitForThread</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Thread.html#788"><b>Thread</b></a>& <tt><span style="color:blue">id</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:purple">void</span></tt>*</tt> </td>
        <td><a href="Thread.html#waitForThread2"><b>waitForThread</b></a></td>
        <td><tt>(<tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">long</span></tt> <tt><span style="color:blue">threadID</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Thread.html#~Thread"><b>~Thread</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Thread.html#Thread"><b>Thread</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td></td>
        <td><a href="Thread.html#Thread2"><b>Thread</b></a></td>
        <td><tt>(<tt><span style="color:navy">THREAD_FUNCTION</span></tt> <tt><span style="color:blue">fnc</span></tt>, <tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">paArgs</span></tt>)
          throw (<tt><span style="color:navy">std::string</span></tt>)</tt>;</td></tr>
    </table>
    <hr noshade>
    <h2>Member descriptions</h2>
    <hr noshade>
    <h2>Variable Member Descriptions</h2>
    <pre><a name="Thread"></a><b>Thread</b> ()</pre>
    <dl>
      <dd><p>Defaultconstructor; create the object but no actual thread</p></dd>
    </dl>
    <hr>
    <pre><a name="Thread2"></a><b>Thread</b> (THREAD_FUNCTION fnc, void* paArgs) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor; creates the thread object and the thread and passes
         <code>paArgs</code> as arguments.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>fnc</code>: Function to be called in the thread<dd>
          <dd><code>paArgs</code>: Pointer to argument(s)<dd>
      </dl><dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string describing the error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~Thread"></a><b>~Thread</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="create"></a>void <b>create</b> (THREAD_FUNCTION fnc, void* paArgs) throw (std::string)</pre>
    <dl>
      <dd><p>Creates a thread (object) and passes paArgs directly as parameter to
         the thread function.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>fnc</code>: Function to execute inside the thread<dd>
          <dd><code>paArgs: Pointer to argument(s).</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string describing the error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="create2"></a>void <b>create2</b> (THREAD_FUNCTION fnc, void* paArgs) throw (std::string)</pre>
    <dl>
      <dd><p>Creates a thread (object) and passes the thread object as parameter to
         the thread function.</p>
        <p>To access its actual parameters the thread function must use something like
          <pre>   static_cast&lt;Thread*&gt; (paArgs).getArgs ();</pre></p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>fnc</code>: Function to execute inside the thread<dd>
          <dd><code>paArgs</code>: Pointer to argument(s).</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string describing the error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="getArgs"></a>void* <b>getArgs</b> () const</pre>
    <dl>
      <dd><p>Gets the actual arguments to the thread.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
           <dd>void*: The actual parameters of the thread</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>As create2 passed a pointer to the thread object, this method enables
             access to the actual parameters.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="cancel"></a>void <b>cancel</b> () </pre>
    <dl>
      <dd><p>Terminates the thread</p></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>Note that not all plattforms (e.g. Windows) support to cancel a thread; in such a case the thread must itself check, if it should be canceled.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="currentID"></a>unsigned long <b>currentID</b> () </pre>
    <dl>
      <dd><p>Returns the ID of the current thread.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned long: ID of the current thread</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="getID"></a>unsigned long <b>getID</b> () </pre>
    <dl>
      <dd><p>Returns the ID of the thread object.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned long: ID of the thread object</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ret"></a>void <b>ret</b> (void* rc) </pre>
    <dl>
      <dd><p>Sets the return code for the thread.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>rc</code>: Value to return</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="waitForThread"></a>void* <b>waitForThread</b> (const Thread& id) </pre>
    <dl>
      <dd><p>Waits for the passed thread to terminate</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>id</code>: Thread to wait for<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>void*: The returncode of the thread
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="waitForThread2"></a>void* <b>waitForThread</b> (unsigned long id) </pre>
    <dl>
      <dd><p>Waits for the thread with the passed ID to terminate</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>id</code>: Thread to wait for<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>void*
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="isToCancel"></a>void <b>isToCancel</b> () const </pre>
    <dl>
      <dd><p>Checks if the thread should be canceled and does so, if yes</p></dd>
    </dl>

    <hr noshade><a name="OThread"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class OThread&lt;T&gt;</h1>
    <p>Derived from
      <a href="Thread.html">Thread</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Thread.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to execute a (non-static) member function in a thread (Of course
      static methods would work too, but for them its easier to use Thread
      directly.)</p>

    <p>There are two create-functions: The first calles the passed function with
      the parameters directly; the second passed a pointer to the created thread
      and enables to get the paramters with its getArgs-method. This enables
      controlling the thread.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt>static <a href="Thread.html#OThread">OThread&lt;T&gt;</a>*</tt> </td>
        <td><a href="Thread.html#OTcreate"><b>create</b></a></td>
        <td><tt>(<tt><span style="color:navy">T</span></tt>* <tt><span style="color:blue">obj</span></tt>, <tt><span style="color:navy">THREAD_OBJMEMBER</span></tt> <tt><span style="color:blue">fnc</span></tt>, <tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">paArgs</span></tt>)
          throw (<tt><span style="color:navy">std::string</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>static <a href="Thread.html#OThread">OThread&lt;T&gt;</a>*</tt> </td>
        <td><a href="Thread.html#OTcreate2"><b>create2</b></a></td>
        <td><tt>(<tt><span style="color:navy">T</span></tt>* <tt><span style="color:blue">obj</span></tt>, <tt><span style="color:navy">THREAD_OBJMEMBER</span></tt> <tt><span style="color:blue">fnc</span></tt>, <tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">paArgs</span></tt>)
          throw (<tt><span style="color:navy">std::string</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Thread.html#~OThread"><b>~OThread</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td></td>
        <td><a href="Thread.html#OThread2"><b>OThread</b></a></td>
        <td><tt>(<tt><span style="color:navy">T</span></tt>* <tt><span style="color:blue">obj</span></tt>, <tt><span style="color:navy">THREAD_OBJMEMBER</span></tt> <tt><span style="color:blue">fnc</span></tt>, <tt><span style="color:purple">void</span></tt>* <tt><span style="color:blue">paArgs</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">threadAsArg</span> = false</tt>)
          throw (<tt><span style="color:navy">std::string</span></tt>)</tt>;</td></tr>
    </table>
    <hr noshade>
    <h2>Member descriptions</h2>
    <hr noshade>
    <h2>Variable Member Descriptions</h2>
    <pre><a name="OThread2"></a><b>OThread</b> (T* obj, THREAD_OBJMEMBER fnc, void* paArgs, bool threadAsArg = false) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor; creates the thread object and the thread and passes -
        depending on <code>threadAsArg</code> - either <code>paArgs</code> as
        or the created object as arguments to the thread function.</p>

        <p>As a thread function needs to be static, a proxy method only calling
          obj->*fnc is used.</p></dd>

      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose member should be executed as thread<dd>
          <dd><code>fnc</code>: Member serving as thread function<dd>
          <dd><code>paArgs</code>: Pointer to argument(s)<dd>
          <dd><code>threadAsArgs</code>: Flag, if arguments should be passed directly<dd>
      </dl><dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string describing the error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OThread"></a><b>~OThread</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>

    <pre><a name="OTcreate"></a>void <b>create</b> (T* obj, THREAD_OBJMEMBER fnc, void* paArgs) throw (std::string)</pre>
    <dl>
      <dd><p>Creates a thread (object) and passes paArgs directly as parameter to
         the thread function.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose member should be executed as thread<dd>
          <dd><code>fnc</code>: Member serving as thread function<dd>
          <dd><code>paArgs</code>: Pointer to argument(s)<dd>
      </dl><dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string describing the error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OTcreate2"></a>void <b>create2</b> (T* obj, THREAD_OBJMEMBER fnc, void* paArgs) throw (std::string)</pre>
    <dl>
      <dd><p>Creates a thread (object) and passes the thread object as parameter to
         the thread function.</p>
        <p>To access its actual parameters the thread function must use something like
          <pre>   static_cast&lt;Thread*&gt; (paArgs).getArgs ();</pre></p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose member should be executed as thread<dd>
          <dd><code>fnc</code>: Member serving as thread function<dd>
          <dd><code>paArgs</code>: Pointer to argument(s)<dd>
      </dl><dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string describing the error</dd></dl></dd>
    </dl>
  </body>
</html>