<!-- -*-HTML-*- -->
<!-- $Id: PathSrch.html,v 1.5 2002/12/15 19:23:23 markus Exp $ -->

<html>
  <head>
    <title>General Reference: PathSearch</title>
    <meta name="description" content="Documentation of PathSearch-class">
    <meta name="keywords" content="Documentation, Docu, PathSearch, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align=center border=0 cellspacing=10>
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class PathSearch</h1>
    <p>Derived from
      <a href="Tokenize.html">Tokenize</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;PathSrch.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to split strings consisting of path-nodes into its nodes.</p>

    <p>This sub-strings are extracted from the beginning of the string (or the
      character behind the last found node) to the next path-seperator (or to
      the end of string). The seperator-character is not included in the
      result.</p>

    <p>If no further sub-string is available an empty string is returned. That
      also means that two seperators behind each other are silently skipped
      and the next following sub-string (if any) is returned.</p>

    <p>The character to seperate the nodes differ between the operating systems.
      Under UNIX (or UNIX-like systems) it's the double-point (:), in DOS,
      Windoze and OS/2 its the semicolon (;).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="PathSrch.html#PathSearch"><b>PathSearch</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">std::string</span></tt>&amp; <tt><span style="color:blue">path</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:purple;">std::string</span></tt></tt> </td>
        <td><a href="PathSrch.html#expandNode"><b>expandNode</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">std::string</span></tt>&amp; <tt><span style="color:blue;">input</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple;">std::string</span></tt></tt> </td>
        <td><a href="PathSrch.html#getNextExpandedNode"><b>getNextExpandedNode</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">std::string</span></tt></tt> </td>
        <td><a href="PathSrch.html#getNextNode"><b>getNextNode</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="PathSearch.html#PathSearch"><b>PathSearch</b></a>&amp;</tt> </td>
        <td><a href="PathSrch.html#operator"><tt><span style="color:black"><b>operator</b></span>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">std::string</span></tt>&amp; <tt><span style="color:blue">path</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="PathSrch.html#~PathSearch"><b>~PathSearch</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="PathSearch"></a><b>PathSearch</b> (const std::string&amp; path)</pre>
    <dl>
      <dd><p>Defaultconstructor; with the string to handle.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>path</code>: String to split into nodes<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="~PathSearch"></a><b>~PathSearch</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="operator="></a>PathSearch&amp; <b>operator=</b> (const std::string&amp; path)</pre>
    <dl>
      <dd><p>Assignmentoperator; sets a new string to handle. No matter of
        seperation, the next query starts from the beginning of the new
        string.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>path</code>: String to split into nodes<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="expandNode"></a>std::string <b>expandNode</b> (const std::string&amp; input)</pre>
    <dl>
      <dd><p>Performs tilde-expansion on the input.</p>
        <p>The expansion is only done under the following conditions:</p>
        <ul>
         <li>The string starts with a tilde</li>
         <li>None of the characters up to the next whitespace or slash (/) is quoted</li>
         <li>The following characters (if any) specify a user-name</li>
        </ul>
 
        <p> If those conditions apply, a single tilde is replaced with the
          contents of the <code>HOME</code>-environment variable (UNIX) or the combination
          of <code>HOMEDRIVE</code> and <code>HOMEPATH</code> (Windows). A tilde with following name
          returns the <code>HOME</code>-path of the user with that name (or the input, if
          such a user does not exist.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>input</code>: String to expand<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: Expanded string or <code>input</code> (if not expandable)</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Accessing the object</h3>
    <pre><a name="getNextNode"></a>std::string <b>getNextNode</b> () const</pre>
    <dl>
      <dd><p>Returns a string consisting of the node behind the end of the last
        seperation (or the beginning of the string for the first search) to the
        next occurence of the path-seperating character (or the end of the
        string). The seperating characters are not returned.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: Next node (empty string at end)</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="getNextExpandedNode"></a>std::string <b>getNextExpandedNode</b> () const</pre>
    <dl>
      <dd><p>Returns a string consisting of the node behind the end of the last
        seperation (or the beginning of the string for the first search) to the
        next occurence of the path-seperating character (or the end of the
        string). The seperating characters are not returned.</p>
        <p>The node is additionally expanded under the following conditions:</p>
        <ul>
         <li>The string starts with a tilde</li>
         <li>None of the characters up to the next whitespace or slash (/) is quoted</li>
         <li>The following characters (if any) specify a user-name</li>
        </ul>
 
        <p> If those conditions apply, a single tilde is replaced with the
          contents of the <code>HOME</code>-environment variable (UNIX) or the combination
          of <code>HOMEDRIVE</code> and <code>HOMEPATH</code> (Windows). A tilde with following name
          returns the <code>HOME</code>-path of the user with that name (or the input, if
          such a user does not exist.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: Next node (empty string at end)</dd></dl></dd>
    </dl>
  </body>
</html>
