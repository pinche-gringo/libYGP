<!-- $Id: Parse.html,v 1.9 2000/04/17 23:34:18 Markus Rel $ -->

<html>
  <head>
    <title>General Reference: Parser</title>
    <meta name="description" content="Documentation of general parser">
    <meta name="keywords" content="Documentation, Docu, Parser, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">General parser-information</h1>
    <p>Classes to parse objects and sequences of objects from a stream. If an
      object is found it is possible to start an action for this event.</p>

    <p>The classes of the parser exists in 3 variants:</p>
    <ul>
      <li>The first variant reports matching objects with a virtual
        function called <i>found</i>. These classes have the prefix
        <i>Parse</i>.</li>
      <li>The second calls a C-style function if an object was found and has
        therefore a function-pointer as parameter of the constructor(s). These
        classes have a prefix of <i>CBParse</i>. The callbacks have the type
        <i><a name="PARSECALLBACK"></a>PARSECALLBACK</i> which are pointer to
        functions with a const char*-paramter returning an integer.</li>
      <li>The third calls a C++-style function if an object was found and has
        therefore an object and a pointer to a memberfunction as parameter of
        he constructor(s). These classes starts with <i>OFParse</i>. The object
        can be of any type; the callback a <a name="PTCALLBACK"></a><i>T::*PTCALLBACK</i>
        which is a object-member expecting an const char*-paramter and returning
        an integer.</li>
    </ul>

    <p>Any of this functions must return the following values (which  specifies
      how the parsing should be continued):</p>
    <ul>
      <li><b>0</b>: Parsing (actually callback) OK</li>
      <li><b>&gt; 0</b>: Error while parsing; parsing can be continued (in
	sequences, ...)</li>
      <li><b>&lt; 0</b>: Error while parsing; abort parsing (unrecoverable
	error)</li>
    </ul>

    <p>If possible use the error-values (PARSE_OK, PARSE_ERROR, PARSE_CB_ERROR,
      PARSE_CB_ABORT) in the error-enum of <a href="Parse.html#ParseObject">
	ParseObject</a>.</p>

    <p>To minimize the usage of storage the parser can be compiled with the
      the macro <i>MULTIBUFFER</i> defined. This causes the buffer holding the
      actual parsed data to be allocated and released everytime a parse-object
      is parsed and therefore in a worse performance. Alternatively the method
      <a href="Parse.html#POAttfreeBuffer">ParseAttomic::freeBuffer</a> can
      be called (but better not while an object is parsed).</p>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseObject"></a>Class ParseObject</h1>
    <p>Derived from: <i>None</i></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Abstract base-class for parsing objects. It contains methods of general
      purpose.</p>

    <p><b>Note</b>: The passed const char*-parameters are only stored and not
      copied, so ensure that they are valid during the lifetime of each
      parse-object!</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseObject1">ParseObject</a></td>
        <td>(const char* description, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseObject2">ParseObject</a></td>
        <td>(const <a href="Parse.html#ParseObject">ParseObject</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseObject">~ParseObject</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseObject">ParseObject</a>&amp;</td>
        <td><a href="Parse.html#POoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseObject">ParseObject</a>&amp; other)</td></tr>

      <tr valign="top"><td>const char*</td>
        <td><a href="Parse.html#POgetDescription">getDescription</a></td>
        <td>() const</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POsetDescription">setDescription</a></td>
        <td>(const char* desc)</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POsetSkipWS">setSkipWS</a></td>
        <td>(bool skipWhitespace)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POskipWS">skipWS</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream)</td></tr>
      <tr valign="top"><td>int</td>
        <td><a href="Parse.html#POparse">parse</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw
          (std::string)</td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POdoParse">doParse</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
          bool optional) = 0</td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseObject1"></a>ParseObject (const char* description, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; the parameter <i>description</i> must contain a
        description of the object, <i>skipWhitespace</i> defines if white-spaces
        should be skipped <b>after</b> sucessful parsing this object.</p>
      <p><b>Note</b>: The description must be valid during the lifetime (or
        at least the usage) of the object!</p></dd>
    </dl>
    <pre><a name="ParseObject2"></a>ParseObject (const ParseObject&amp; other)</pre>
    <pre><a name="~ParseObject"></a>virtual ~ParseObject ()</pre>

    <pre><a name="POoperator="></a>ParseObject&amp; operator= (const ParseObject&amp; other)</pre>

    <h4>Accessing values</h4>
    <pre><a name="POgetDescription"></a>const char* getDescription () const</pre>
    <dl>
      <dd>Retrieves the pointer to the description specified to this object.</dd>
    </dl>
    <pre><a name="POsetDescription"></a>void setDescription (const char* desc)</pre>
    <dl>
      <dd>Changes the description of the object</dd>
    </dl>
    <pre><a name="POsetSkipWS"></a>void setSkipWS (bool skipWhitespace)</pre>
    <dl>
      <dd>Sets the flag if whitespaces should be skipped after sucessfully
        parsing data matching the object.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="skipWS"></a>void skipWS (<a href="XStream.html#Xistream">Xistream</a>&amp; stream) const</pre>
    <dl>
      <dd>Skips all whitespace characters (blank, tabulator, carriage return
        and line feed) from the current position in the passed stream.</dd>
    </dl>
    <pre><a name="POparse"></a>int parse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd>Tries to parse data matching the information stored with this
        parse-object from the passed stream. If this parsing is successful (the
        parsed data matches) this function returns <i>PARSE_OK</i>; else a
        non-zero value. Errors larger than 0 are <i>soft errors</i> and the
        parsing can be continued, errors less than 0 are <i>hard errors</i> and
        the parsing is stopped.</dd>

      <dt>&nbsp;&nbsp;&nbsp;&nbsp;Throws:</dt><dd>std::string with a description of
        the expected and the found data</dd>
    </dl>
    <pre><a name="POdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream, bool optional)</pre>
    <dl>
      <dd><p>Pure virtual method defining the interface for the actual
        parse-method for the different parse-objects; to be implemented by the
        derived classes.</p>

        <p>The parameter <i>optional</i> specifies if the object has to be
          found or is optional (like in
          <a href="Parse.html#ParseSelection">selections</a>).</p>

        <p>If this parsing is successful (the parsed data matches) this
          function must return <i>PARSE_OK</i>; else a non-zero value. Errors
          larger than 0 are <i>soft errors</i> and the parsing can be continued,
          errors less than 0 are <i>hard errors</i> and the parsing is stopped.</p>
        <p>If possible used the predefined error-codes <i>PARSE_ERROR</i>,
          <i>PARSE_CB_ERROR</i> and <i>PARSE_CB_ABORT</i>. Unrecoverable
          (<i>hard</i>) errors can also be reported with an (explaining)
          exception.</p></dd>
    </dl>
    <pre><a name="POfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Callback to notify caller that an object has found itself during
        parsing. This callback can report its status with the return codes
        <i>PARSE_OK</i> or 0 for OK, <i>PARSE_CB_ERROR</i> or any other number
        larger than 0 for <i>soft errors</i> and <i>PARSE_CB_ABORT</i> or any
        number below 0 for <i>hard errors</i>.  Unrecoverable (<i>hard</i>)
        errors can also be reported with an (explaining) exception.</dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseEOF"></a>Class ParseEOF</h1>
    <p>Derived from: <a href="Parse.html#ParseObject">ParseObject</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF).</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseEOF1">ParseEOF</a></td><td>()</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseEOF">~ParseEOF</a></td><td>()</td></tr>

      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POEOFdoParse">doParse</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
          bool optional)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseEOF1"></a>ParseEOF ()</pre>
    <pre><a name="~ParseEOF"></a>virtual ~ParseEOF ()</pre>

    <h4>Parsing</h4>
    <pre><a name="POEOFdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream, bool)</pre>
    <dl>
      <dd>Returns <i>PARSE_OK</i>; if the end of the stream has been
        reached; <i>PARSE_ERROR</i> if not.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseEOF"></a>Class CBParseEOF</h1>
    <p>Derived from: <a href="Parse.html#ParseEOF">ParseEOF</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseEOF1">CBParseEOF</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseEOF">~CBParseEOF</a></td><td>()</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBEOFsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBEOFfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseEOF1"></a>CBParseEOF (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="~CBParseEOF"></a>virtual ~CBParseEOF ()</pre>

    <pre><a name="CBEOFsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBEOFfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseEOF"></a>Class OFParseEOF&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseEOF">ParseEOF</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseEOF1">OFParseEOF</a></td>
        <td>(T&amp; objToNotify, <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseEOF">~OFParseEOF</a></td><td>()</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBEOFfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseEOF1"></a>OFParseEOF (T&amp; objToNotify, <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="~OFParseEOF"></a>virtual ~OFParseEOF ()</pre>

    <h4>Parsing</h4>
    <pre><a name="CBEOFfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseAttomic"></a>Class ParseAttomic</h1>
    <p>Derived from: <a href="Parse.html#ParseObject"></a>ParseObject</p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse an attomic value; Base-class of all attomic values.</p>

    <p>The member <i>pValue</i> has the following semantic: A parsed character
      is valid if it occures in the pValue-list, where the backslash (\)
      escapes the next charater to the following meaning:</p>

    <ul>
      <li><b>A</b> ... Any alphabethic character is valid</li>
      <li><b>X</b> ... Any alphanumeric character is valid</li>
      <li><b>9</b> ... Any number is valid</li>
      <li><b>0</b> ... The zero-character (\0) is valid</li>
      <li><b>n</b> ... The line-feed-character (\n) is valid</li>
      <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
      <li><b>\</b> ... The backslash itself is valid</li>
      <li><b>blank ( )</b> ... Any whitespace is valid</li>
      <li><b>*</b> ... Any character is valid</li>
    </ul>

    <p>The members <i>maxCard</i> and <i>minCard</i> specify how many characters
      the object can or must have. If there are less matching characters parsed,
      the object is considered as not found; after reaching the upper border,
      parsing is stopped (for this object).</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseAttomic1">ParseAttomic</a></td>
        <td>(const char* value, const char* description, unsigned int max = 1,
	  unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseAttomic2">ParseAttomic</a></td>
        <td>(const <a href="Parse.html#ParseAttomic">ParseAttomic</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseAttomic">~ParseAttomic</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseAttomic">ParseAttomic</a>&amp;</td>
        <td><a href="Parse.html#POAttoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseAttomic">ParseAttomic</a>&amp; other)</td></tr>

      <tr valign="top"><td>const char*</td>
        <td><a href="Parse.html#POAttgetValue">getValue</a></td><td>() const</td></tr>
      <tr valign="top"><td>unsigned int</td>
        <td><a href="Parse.html#POAttgetMaxCard">getMaxCard</a></td>
        <td>() const</td></tr>
      <tr valign="top"><td>unsigned int</td>
        <td><a href="Parse.html#POAttgetMinCard">getMinCard</a></td>
        <td>() const</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POAttsetValue">setValue</a></td>
        <td>(const char* value)</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POAttsetMaxCard">setMaxCard</a></td>
        <td>(unsigned int val)</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POAttsetMinCard">setMinCard</a></td>
        <td>(unsigned int val)</td></tr>

      <tr valign="top"><td>static void</td>
        <td><a href="Parse.html#POAttfreeBuffer">freeBuffer</a></td><td>()</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POAttcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
      <tr valign="top"><td>virtual bool</td>
        <td><a href="Parse.html#POAttcheckValue">checkValue</a></td><td>(char ch)</td></tr>

      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POAttdoParse">doParse</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
	  bool optional) throw (std::string)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseAttomic1"></a>ParseAttomic (const char* value, const char* description, unsigned int max = 1,
              unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
	<p>The parameter <i>value</i> specifies the valid characters for the
	  object, which can either be listed or specified by a type behind a
	  backslash (\) with the following characters:</p>

  <ul type="disc">
	  <li><b>A</b> ... Any alphabethic character is valid</li>
	  <li><b>X</b> ... Any alphanumeric character is valid</li>
	  <li><b>9</b> ... Any number is valid</li>
	  <li><b>0</b> ... The zero-character (\0) is valid</li>
	  <li><b>n</b> ... The line-feed-character (\n) is valid</li>
	  <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
	  <li><b>\</b> ... The backslash itself is valid</li>
	  <li><b>blank ( )</b> ... Any whitespace is valid</li>
	  <li><b>*</b> ... Any character is valid</li>
	</ul>

	<p>That means a value like "\9abcdeABCDE" would report all
	  hexadecimal values as valid. <b>Note</b>: The backslash (\) is a
	  character itself, so in a C-file this definition must be written as
	  "\\9abcdeABCDE"!</p>

	<p>The parameters <i>max</i> and <i>min</i> specify the maximal and
	  minimal number of characters this object may contain.</p></dd>
    </dl>
    <pre><a name="ParseAttomic2"></a>ParseAttomic (const ParseAttomic&amp; other)</pre>
    <pre><a name="~ParseAttomic"></a>virtual ~ParseAttomic ()</pre>

    <pre><a name="POAttoperator="></a>ParseAttomic&amp; operator= (const ParseAttomic&amp; other)</pre>

    <pre><a name="POAttfreeBuffer"></a>static void freeBuffer</pre>
    <dl>
      <dd><p>Frees the buffer which is used to store the parsed data. Use with
          care (only at the end of parsing and not during parsing a single
          object).</p>

        <p>By default the parse-buffer is freed during the cleanup at the
          termination of the program or (if compiled with the macro
          MULTIBUFFER defined) everytime an attomic object finishes its
          parsing (successful or not).</p></dd>
    </dl>

    <h4>Accessing values</h4>
    <pre><a name="POAttgetValue"></a>const char* getValue () const</pre>
    <dl>
      <dd>Returns a pointer to the stored valid characters.</dd>
    </dl>
    <pre><a name="POAttsetValue"></a>setValue (const char* value)</pre>
    <dl>
      <dd>Changes the valid characters. This parameter must be valid (not
        freed) for the whole lifetime (usage) of the object.</dd>
    </dl>
    <pre><a name="POAttgetMaxCard"></a>unsigned int getMaxCard () const</pre>
    <dl>
      <dd>Returns the maximal number of characters this object may match while
        parsing.</dd>
    </dl>
    <pre><a name="POAttsetMaxCard"></a>void setMaxCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the maximal number of characters this object may match while
        parsing.</dd>
    </dl>
    <pre><a name="POAttgetMinCard"></a>unsigned int getMinCard () const</pre>
    <dl>
      <dd>Returns the minimal number of characters this object must match while
        parsing.</dd>
    </dl>
    <pre><a name="POAttsetMinCard"></a>void setMinCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the minimal number of characters this object must match while
        parsing.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="POAttdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream, bool optional) throw (std::string)</pre>
    <dl>
      <dd><p>Returns <i>PARSE_OK</i> if data matching the object is found (and
          the callback does not report something different).</p>
        <p>It is a soft error (<i>PARSE_ERROR</i>) if the minimal cardinality is
          not fullfilled.</p>
        <p>If parsing is optional or the error is recoverable (&gt; 0), the
          parsed data is pushed back into the stream and <i>PARSE_ERROR</i> is
          returned.</p>
        <p>If parsing is not optional and the error is not recoverable (&lt; 0),
          an exception (std::string) is thrown.</p></dd>
    </dl>
    <pre><a name="POAttcheckValue"></a>virtual bool checkValue (char ch) const</pre>
    <dl>
      <dd>Checks if ch is valid according the value-list of the object. See the
        <a href="Parse.html#ParseAttomic1">constructor</a> or the
        <a href="Parse.html#ParseAttomic">general information</a> at the
          beginning of the documentation to this class for further information</dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POAttcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseAttomic"></a>Class CBParseAttomic</h1>
    <p>Derived from: <a href="Parse.html#ParseAttomic">ParseAttomic</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse attomic values with a callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseAttomic1">CBParseAttomic</a></td>
        <td>(const char* value, const char* description,
          <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseAttomic2">CBParseAttomic</a></td>
        <td>(const <a href="Parse.html#CBParseAttomic">CBParseAttomic</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseAttomic">~CBParseAttomic</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseAttomic">CBParseAttomic</a>&amp;</td>
        <td><a href="Parse.html#CBAttoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseAttomic">CBParseAttomic</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBAttsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBAttfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseAttomic1"></a>CBParseAttomic (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
                unsigned int max = 1, unsigned int min = 1,
                bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseAttomic2"></a>CBParseAttomic (const CBParseAttomic&amp; other)</pre>
    <pre><a name="~CBParseAttomic"></a>virtual ~CBParseAttomic ()</pre>
    <pre><a name="CBAttoperator="></a>CBParseAttomic&amp; operator= (const CBParseAttomic&amp; other)</pre>

    <pre><a name="CBAttsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBAttfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseAttomic"></a>Class OFParseAttomic&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseAttomic">ParseAttomic</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse attomic values with a callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseAttomic1">OFParseAttomic</a></td>
        <td>(const char* value, const char* description, T&amp; objToNotify,
	  <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
	  unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseAttomic2">OFParseAttomic</a></td>
        <td>(const <a href="Parse.html#OMParseAttomic">OFParseAttomic</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseAttomic">~OFParseAttomic</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseAttomic">OFParseAttomic</a>&amp;</td>
        <td><a href="Parse.html#OFAttoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseAttomic">OFParseAttomic</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFAttfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseAttomic1"></a>OFParseAttomic (const char* value, const char* description, T&amp; objToNotify,
                <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1,
                unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseAttomic2"></a>OFParseAttomic (const OFParseAttomic&amp; other)</pre>
    <pre><a name="~OFParseAttomic"></a>virtual ~OFParseAttomic ()</pre>
    <pre><a name="OFAttoperator="></a>OFParseAttomic&amp; operator= (const OFParseAttomic&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFAttfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseText"></a>Class ParseText</h1>
    <p>Derived from: <a href="Parse.html#ParseAttomic">ParseAttomic</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.</p>

    <p>Parsing of this element is stopped, if any of the characters in the
      abort-parameters is found (or the maximal cardinality is reached).</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseText1">ParseText</a></td>
        <td>(const char* abort, const char* description, unsigned int max = 1,
	  unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseText2">ParseText</a></td>
        <td>(const <a href="Parse.html#ParseText">ParseText</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseText">~ParseText</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseText">ParseText</a>&amp;</td>
        <td><a href="Parse.html#POTxtoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseText">ParseText</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual bool</td>
        <td><a href="Parse.html#POTxtcheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseText1"></a>ParseText (const char* abort, const char* description, unsigned int max = 1,
           unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>abort</i> specifies the characters which ends the
          parsing for this object.</p></dd>
    </dl>

    <pre><a name="ParseText2"></a>ParseText (const ParseText&amp; other)</pre>
    <pre><a name="~ParseText"></a>virtual ~ParseText ()</pre>

    <pre><a name="POTxtoperator="></a>ParseText&amp; operator= (const ParseText&amp; other)</pre>

    <pre><a name="POTxtcheckValue"></a>virtual bool checkValue (char ch) const</pre>
    <dl>
      <dd>Checks if the parsed value is according the abort-list of the object.
        If the parsed character is inside the list, false is returned; if not
        true.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseText"></a>Class CBParseText</h1>
    <p>Derived from: <a href="Parse.html#ParseText">ParseText</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseText">ParseText</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseText1">CBParseText</a></td>
        <td>(const char* abort, const char* description,
          <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseText2">CBParseText</a></td>
        <td>(const <a href="Parse.html#CBParseText">CBParseText</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseText">~CBParseText</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseText">CBParseText</a>&amp;</td>
        <td><a href="Parse.html#CBTxtoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseText">CBParseText</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBTxtsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBTxtfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseText1"></a>CBParseText (const char* abort, const char* description, <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
       unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseText2"></a>CBParseText (const CBParseText&amp; other)</pre>
    <pre><a name="~CBParseText"></a>virtual ~CBParseText ()</pre>
    <pre><a name="CBTxtoperator="></a>CBParseText&amp; operator= (const CBParseText&amp; other)</pre>

    <pre><a name="CBTxtsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBTxtfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseText"></a>Class OFParseText&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseText">ParseText</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseText">ParseText</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseText1">OFParseText</a></td>
        <td>(const char* abort, const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseText2">OFParseText</a></td>
        <td>(const <a href="Parse.html#OMParseText">OFParseText</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseText">~OFParseText</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseText">OFParseText</a>&amp;</td>
        <td><a href="Parse.html#OFTxtoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseText">OFParseText</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFTxtfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseText1"></a>OFParseText (const char* abort, const char* description, T&amp; objToNotify,
             <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1,
             unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseText2"></a>OFParseText (const OFParseText&amp; other)</pre>
    <pre><a name="~OFParseText"></a>virtual ~OFParseText ()</pre>
    <pre><a name="OFTxtoperator="></a>OFParseText&amp; operator= (const OFParseText&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFTxtfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseTextEsc"></a>Class ParseTextEsc</h1>
    <p>Derived from: <a href="Parse.html#ParseText">ParseText</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.</p>

    <p>Parsing of this element is stopped, if the maximal cardinality is
      reached or any of the characters in the abort-parameters is found which
      is not succeeded by a certain (defined) character.</p>
    <p>This class enables parsing analogue to strings in C. A C-string is
      terminated with a quote ("), except if the quote follows a backslash (\).
      The only difference is that both quote and backslash can be specified and
      therefor be every charcter.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseTextEsc1">ParseTextEsc</a></td>
        <td>(const char* abort, const char* description, unsigned int max = 1,
          unsigned int min = 1, char escape = '\\', bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseTextEsc2">ParseTextEsc</a></td>
        <td>(const <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseTextEsc">~ParseTextEsc</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseTextEsc">ParseTextEsc</a>&amp;</td>
        <td><a href="Parse.html#POTxEoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual bool</td>
        <td><a href="Parse.html#POTxEcheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseTextEsc1"></a>ParseTextEsc (const char* abort, const char* description, unsigned int max = 1,
              unsigned int min = 1, char escape = '\\', bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>abort</i> specifies the characters which ends the
          parsing for this object (if it is not succeeded by the character
          defined with the parameter <i>escape</i>).</p></dd>
    </dl>

    <pre><a name="ParseTextEsc2"></a>ParseTextEsc (const ParseTextEsc&amp; other)</pre>
    <pre><a name="~ParseTextEsc"></a>virtual ~ParseTextEsc ()</pre>

    <pre><a name="POTxEoperator="></a>ParseTextEsc&amp; operator= (const ParseTextEsc&amp; other)</pre>

    <pre><a name="POTxEcheckValue"></a>virtual bool checkValue (char ch) const</pre>
    <dl>
      <dd>Checks if the parsed value is according the abort-list of the object.
        If the parsed character is inside the list and not succeeded by the
        escape-character, false is returned; if not true.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseTextEsc"></a>Class CBParseTextEsc</h1>
    <p>Derived from: <a href="Parse.html#ParseTextEsc">ParseTextEsc</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseTextEsc1">CBParseTextEsc</a></td>
        <td>(const char* abort, const char* description,
	  <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
	  unsigned int max = 1, unsigned int min = 1, char escape = '\\',
	  bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseTextEsc2">CBParseTextEsc</a></td>
        <td>(const <a href="Parse.html#CBParseTextEsc">CBParseTextEsc</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseTextEsc">~CBParseTextEsc</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseTextEsc">CBParseTextEsc</a>&amp;</td>
        <td><a href="Parse.html#CBTxEoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseTextEsc">CBParseTextEsc</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBTxEsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBTxEfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseTextEsc1"></a>CBParseTextEsc (const char* abort, const char* description, <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
                unsigned int max = 1, unsigned int min = 1, char escape = '\\',
                bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseTextEsc2"></a>CBParseTextEsc (const CBParseText&amp; other)</pre>
    <pre><a name="~CBParseTextEsc"></a>virtual ~CBParseTextEsc ()</pre>
    <pre><a name="CBTxEoperator="></a>CBParseTextEsc&amp; operator= (const CBParseTextEsc&amp; other)</pre>

    <pre><a name="CBTxEsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBTxEfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseTextEsc"></a>Class OFParseTextEsc&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseTextEsc">ParseTextEsc</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseTextEsc1">OFParseTextEsc</a></td>
        <td>(const char* value, const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, char escape = '\\',
          bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseTextEsc2">OFParseTextEsc</a></td>
        <td>(const <a href="Parse.html#OMParseTextEsc">OFParseTextEsc</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseTextEsc">~OFParseTextEsc</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseTextEsc">OFParseTextEsc</a>&amp;</td>
        <td><a href="Parse.html#OFTxEoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseTextEsc">OFParseTextEsc</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFTxEfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseTextEsc1"></a>OFParseTextEsc (const char* value, const char* description, T&amp; objToNotify,
                <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1, unsigned int min = 1,
                char escape = '\\', bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseTextEsc2"></a>OFParseTextEsc (const OFParseTextEsc&amp; other)</pre>
    <pre><a name="~OFParseTextEsc"></a>virtual ~OFParseTextEsc ()</pre>
    <pre><a name="OFTxEoperator="></a>OFParseTextEsc&amp; operator= (const OFParseTextEsc&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFTxEfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseExact"></a>Class ParseExact</h1>
    <p>Derived from: <a href="Parse.html#ParseExact">ParseExact</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!)</p>
    <p>The min- and max-members are not totally wasted; they could be used to
      define the minimal length of certain keywords which would be valid even
      if just written in a short(er) form.</p>

    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseExact1">ParseExact</a></td>
        <td>(const char* value, const char* description, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseExact2">ParseExact</a></td>
        <td>(const char* value, const char* description, unsigned int max,
          unsigned int min, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseExact3">ParseExact</a></td>
        <td>(const <a href="Parse.html#ParseExact">ParseExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseExact">~ParseExact</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseExact">ParseExact</a>&amp;</td>
        <td><a href="Parse.html#POExaoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseExact">ParseExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POExacheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
      <tr valign="top"><td>virtual bool</td>
        <td><a href="Parse.html#POExacheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseExact1"></a>ParseExact (const char* value, const char* description, bool skipWhitespace = true)</pre>
    <pre><a name="ParseExact2"></a>ParseExact (const char* value, const char* description, unsigned int max,
            unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>The parameters <i>min</i> and <i>max</i> could be used to define a
        minimal length of a keyword. This word would be valid if at least min
        characters would be parsed, but other (longer) versions of the word
        would also be valid.</dd>
    </dl>

    <pre><a name="ParseExact3"></a>ParseExact (const ParseExact&amp; other)</pre>
    <pre><a name="~ParseExact"></a>virtual ~ParseExact ()</pre>

    <pre><a name="POExaoperator="></a>ParseExact&amp; operator= (const ParseExact&amp; other)</pre>

    <pre><a name="POExacheckValue"></a>virtual bool checkValue (char ch) const</pre>
    <dl>
      <dd>Retruns true, if the passed character is exactly equal (case-sensitive!)
        than the one in the actual position of the object; else false.</dd>
    </dl>
    <pre><a name="POExacheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseExact"></a>Class CBParseExact</h1>
    <p>Derived from: <a href="Parse.html#ParseExact">ParseExact</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseExact">ParseExact</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseExact1">CBParseExact</a></td>
        <td>(const char* value, const char* description,
	  <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
	  bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseExact2">CBParseExact</a></td>
        <td>(const char* value, const char* description,
          <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseExact3">CBParseExact</a></td>
        <td>(const <a href="Parse.html#CBParseExact">CBParseExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseExact">~CBParseExact</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseExact">CBParseExact</a>&amp;</td>
        <td><a href="Parse.html#CBExaoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseExact">CBParseExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBExasetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBExafound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseExact1"></a>CBParseExact (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
              bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseExact2"></a>CBParseExact (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
              unsigned int max = 1, unsigned int min = 1,
              bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback. With the <i>min</i>- and <i>max</i>-
        parameters it is possible to parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="CBParseExact3"></a>CBParseExact (const CBParseExact&amp; other)</pre>
    <pre><a name="~CBParseExact"></a>virtual ~CBParseExact ()</pre>
    <pre><a name="CBExaoperator="></a>CBParseExact&amp; operator= (const CBParseExact&amp; other)</pre>

    <pre><a name="CBExasetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBExafound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseExact"></a>Class OFParseExact&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseExact">ParseExact</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseExact">ParseExact</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseExact1">OFParseExact</a></td>
        <td>(const char* value, const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseExact2">OFParseExact</a></td>
        <td>(const char* value, const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseExact3">OFParseExact</a></td>
        <td>(const <a href="Parse.html#OMParseExact">OFParseExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseExact">~OFParseExact</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseExact">OFParseExact</a>&amp;</td>
        <td><a href="Parse.html#OFExaoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseExact">OFParseExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFExafound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseExact1"></a>OFParseExact (const char* value, const char* description, T&amp; objToNotify,
              <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseExact2"></a>OFParseExact (const char* value, const char* description, T&amp; objToNotify,
              <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1,
              unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback. With the <i>min</i>- and <i>max</i>-
        parameters it is possible to parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="OFParseExact3"></a>OFParseExact (const OFParseExact&amp; other)</pre>
    <pre><a name="~OFParseExact"></a>virtual ~OFParseExact ()</pre>
    <pre><a name="OFExaoperator="></a>OFParseExact&amp; operator= (const OFParseExact&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFExafound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseUpperExact"></a>Class ParseUpperExact</h1>
    <p>Derived from: <a href="Parse.html#ParseAttomic">ParseAttomic</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!)</p>
    <p>The min- and max-members are not totally wasted; they could be used to
      define the minimal length of certain keywords which would be valid even
      if just written in a short(er) form.</p>

    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseUpperExact1">ParseUpperExact</a></td>
        <td>(const char* value, const char* description, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseUpperExact2">ParseUpperExact</a></td>
        <td>(const char* value, const char* description, unsigned int max,
          unsigned int min, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseUpperExact3">ParseUpperExact</a></td>
        <td>(const <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseUpperExact">~ParseUpperExact</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseUpperExact">ParseUpperExact</a>&amp;</td>
        <td><a href="Parse.html#POUExoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POUExcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
      <tr valign="top"><td>virtual bool</td>
        <td><a href="Parse.html#POUExcheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseUpperExact1"></a>ParseUpperExact (const char* value, const char* description,
                 bool skipWhitespace = true)</pre>
    <pre><a name="ParseUpperExact2"></a>ParseUpperExact (const char* value, const char* description, unsigned int max,
                 unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>The parameters <i>min</i> and <i>max</i> could be used to define a
        minimal length of a keyword. This word would be valid if at least min
        characters would be parsed, but other (longer) versions of the word
        would also be valid.</dd>
    </dl>

    <pre><a name="ParseUpperExact3"></a>ParseUpperExact (const ParseUpperExact&amp; other)</pre>
    <pre><a name="~ParseUpperExact"></a>virtual ~ParseUpperExact ()</pre>

    <pre><a name="POUExoperator="></a>ParseUpperExact&amp; operator= (const ParseUpperExact&amp; other)</pre>

    <pre><a name="POUExcheckValue"></a>virtual bool checkValue (char ch) const</pre>
    <dl>
      <dd>Retruns true, if the passed character is exactly equal (not
        case-sensitive!) than the one in the actual position of the object;
        else false.</dd>
    </dl>
    <pre><a name="POUExcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseUpperExact"></a>Class CBParseUpperExact</h1>
    <p>Derived from: <a href="Parse.html#ParseUpperExact">ParseUpperExact</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseUpperExact1">CBParseUpperExact</a></td>
        <td>(const char* value, const char* description,
          <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
          bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseUpperExact2">CBParseUpperExact</a></td>
        <td>(const char* value, const char* description,
          <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseUpperExact3">CBParseUpperExact</a></td>
        <td>(const <a href="Parse.html#CBParseUpperExact">CBParseUpperExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseUpperExact">~CBParseUpperExact</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseUpperExact">CBParseUpperExact</a>&amp;</td>
        <td><a href="Parse.html#CBUExoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseUpperExact">CBParseUpperExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBUExsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBUExfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseUpperExact1"></a>CBParseUpperExact (const char* value, const char* description,
                   <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseUpperExact2"></a>CBParseUpperExact (const char* value, const char* description,
                   <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback, unsigned int max = 1,
                   unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback. With the <i>min</i>- and <i>max</i>-
        parameters it is possible to parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="CBParseUpperExact3"></a>CBParseUpperExact (const CBParseUpperExact&amp; other)</pre>
    <pre><a name="~CBParseUpperExact"></a>virtual ~CBParseUpperExact ()</pre>
    <pre><a name="CBUExoperator="></a>CBParseUpperExact&amp; operator= (const CBParseUpperExact&amp; other)</pre>

    <pre><a name="CBUExsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBUExfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseUpperExact"></a>Class OFParseUpperExact&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseUpperExact">ParseUpperExact</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseUpperExact1">OFParseUpperExact</a></td>
        <td>(const char* value, const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseUpperExact2">OFParseUpperExact</a></td>
        <td>(const char* value, const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseUpperExact3">OFParseUpperExact</a></td>
        <td>(const <a href="Parse.html#OMParseUpperExact">OFParseUpperExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseUpperExact">~OFParseUpperExact</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseUpperExact">OFParseUpperExact</a>&amp;</td>
        <td><a href="Parse.html#OFUExoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseUpperExact">OFParseUpperExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFUExfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseUpperExact1"></a>OFParseUpperExact (const char* value, const char* description, T&amp; objToNotify,
                   <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseUpperExact2"></a>OFParseUpperExact (const char* value, const char* description, T&amp; objToNotify,
                   <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1,
                   unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.
        With the <i>min</i>- and <i>max</i>- parameters it is possible to
        parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="OFParseUpperExact3"></a>OFParseUpperExact (const OFParseUpperExact&amp; other)</pre>
    <pre><a name="~OFParseUpperExact"></a>virtual ~OFParseUpperExact ()</pre>
    <pre><a name="OFUExoperator="></a>OFParseUpperExact&amp; operator= (const OFParseUpperExact&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFUExfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseSequence"></a>Class ParseSequence</h1>
    <p>Derived from: <a href="Parse.html#ParseObject">ParseObject</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects (sequences).</p>
    <p>A sequence is only considered parsed successfully, if all of its
      elements are parsed successfully.</p>
    <p>Errors while parsing causes a <i>soft error</i> only for the first
      element; errors for further elements causes <i>hard errors</i> (which
      are not recoverable).</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseSequence1">ParseSequence</a></td>
        <td>(<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[],
          const char* description, unsigned int max = 1, unsigned int min = 1,
          bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseSequence2">ParseSequence</a></td>
        <td>(const <a href="Parse.html#ParseSequence">ParseSequence</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseSequence">~ParseSequence</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseSequence">ParseSequence</a>&amp;</td>
        <td><a href="Parse.html#POSeqoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseSequence">ParseSequence</a>&amp; other)</td></tr>

      <tr valign="top"><td>unsigned int</td>
        <td><a href="Parse.html#POSeqgetMaxCard">getMaxCard</a></td>
        <td>() const</td></tr>
      <tr valign="top"><td>unsigned int</td>
        <td><a href="Parse.html#POSeqgetMinCard">getMinCard</a></td>
        <td>() const</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POSeqsetMaxCard">setMaxCard</a></td>
        <td>(unsigned int val)</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#POSeqsetMinCard">setMinCard</a></td>
        <td>(unsigned int val)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POSeqcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>

      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POSeqdoParse">doParse</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
          bool optional) throw (std::string)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseSequence1"></a>ParseSequence (<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
               unsigned int max = 1, unsigned int min = 1,
               bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>apObjectList</i> specifies the list of ParseObject
          which must be found in serie to fullfill the sequence.</p>
        <p>The parameters <i>max</i> and <i>min</i> specify the maximal and
          minimal number how often the sequence must or may be repeated.</p></dd>
    </dl>
    <pre><a name="ParseSequence2"></a>ParseSequence (const ParseSequence&amp; other)</pre>
    <pre><a name="~ParseSequence"></a>virtual ~ParseSequence ()</pre>

    <pre><a name="POSeqoperator="></a>ParseSequence&amp; operator= (const ParseSequence&amp; other)</pre>

    <h4>Accessing values</h4>
    <pre><a name="POSeqgetMaxCard"></a>unsigned int getMaxCard () const</pre>
    <dl>
      <dd>Returns the maximal number how often the sequence may be repeated.</dd>
    </dl>
    <pre><a name="POSeqsetMaxCard"></a>void setMaxCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the maximal number how often the sequence may be repeated.</dd>
    </dl>
    <pre><a name="POSeqgetMinCard"></a>unsigned int getMinCard () const</pre>
    <dl>
      <dd>Returns the minimal number how often the sequence must be repeated.</dd>
    </dl>
    <pre><a name="POSeqsetMinCard"></a>void setMinCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the minimal number how often the sequence must be repeated.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="POSeqdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd><p>Returns <i>PARSE_OK</i> if the the sequence has been parsed
          successfully (all objects found and the minimal cardinality of the
          sequence is fullfilled (this is also true, if a soft error (&gt; 0)
          occurs while parsing the first element of the sequence).</p>
        <p>If there is a soft error parsing the first element of the sequence
          before the mininmal cardinality is fullfilled or with any other
          element of the sequence, <i>PARSE_ERROR</i> is returned; hard errors
          causes an exception to be thrown.</p></dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POSeqcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseSequence"></a>Class CBParseSequence</h1>
    <p>Derived from: <a href="Parse.html#ParseSequence">ParseSequence</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects with a callback to report matching
      input.</p>
    <p>See the documentation of <a href="Parse.html#ParseSequence">ParseSequence</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseSequence1">CBParseSequence</a></td>
        <td>(<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
	  <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
	  unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseSequence2">CBParseSequence</a></td>
        <td>(const <a href="Parse.html#CBParseSequence">CBParseSequence</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseSequence">~CBParseSequence</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseSequence">CBParseSequence</a>&amp;</td>
        <td><a href="Parse.html#CBSeqoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseSequence">CBParseSequence</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBSeqsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBSeqfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseSequence1"></a>CBParseSequence (<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
                 <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback, unsigned int max = 1,
                 unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseSequence2"></a>CBParseSequence (const CBParseSequence&amp; other)</pre>
    <pre><a name="~CBParseSequence"></a>virtual ~CBParseSequence ()</pre>
    <pre><a name="CBSeqoperator="></a>CBParseSequence&amp; operator= (const CBParseSequence&amp; other)</pre>

    <pre><a name="CBSeqsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBSeqfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseSequence"></a>Class OFParseSequence&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseSequence">ParseSequence</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects with a callback to report matching
      input.</p>
    <p>See the documentation of <a href="Parse.html#ParseSequence">ParseSequence</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseSequence1">OFParseSequence</a></td>
        <td>(<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[],
          const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseSequence2">OFParseSequence</a></td>
        <td>(const <a href="Parse.html#OMParseSequence">OFParseSequence</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseSequence">~OFParseSequence</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseSequence">OFParseSequence</a>&amp;</td>
        <td><a href="Parse.html#OFSeqoperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseSequence">OFParseSequence</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFSeqfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseSequence1"></a>OFParseSequence (<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
                 T&amp; objToNotify, <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1,
                 unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseSequence2"></a>OFParseSequence (const OFParseSequence&amp; other)</pre>
    <pre><a name="~OFParseSequence"></a>virtual ~OFParseSequence ()</pre>
    <pre><a name="OFSeqoperator="></a>OFParseSequence&amp; operator= (const OFParseSequence&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFSeqfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseSelection"></a>Class ParseSelection</h1>
    <p>Derived from: <a href="Parse.html#ParseSequence">ParseSequence</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list.</p>
    <p>If an object is found matching the parsed intput, the sequence is
      considered as parsed successfully</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseSelection1">ParseSelection</a></td>
        <td>(ParseObject* apObjectList[], const char* description, unsigned int max = 1,
          unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseSelection2">ParseSelection</a></td>
        <td>(const <a href="Parse.html#ParseSelection">ParseSelection</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~ParseSelection">~ParseSelection</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseSelection">ParseSelection</a>&amp;</td>
        <td><a href="Parse.html#POSeloperator=">operator=</a></td>
        <td>(const <a href="Parse.html#ParseSelection">ParseSelection</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#POSeldoParse">doParse</a></td>
        <td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
          bool optional) throw (std::string)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseSelection1"></a>ParseSelection (const char* value, const char* description, unsigned int max = 1,
                unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>apObjectList</i> specifies the list of ParseObject
          where one must be found to fullfill the selection.</p>
        <p>The parameters <i>max</i> and <i>min</i> specify the maximal and
          minimal number how often the selection must or may be repeated.</p></dd>
    </dl>
    <pre><a name="ParseSelection2"></a>ParseSelection (const ParseSelection&amp; other)</pre>
    <pre><a name="~ParseSelection"></a>virtual ~ParseSelection ()</pre>

    <pre><a name="POSeloperator="></a>ParseSelection&amp; operator= (const ParseSelection&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="POSeldoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd><p>Returns <i>PARSE_OK</i> if the the selection has been parsed
          successfully (one objects found and the minimal cardinality of the
          selection is fullfilled.</p>
        <p>If no element of the sequence matches the parsed input or the minimal
          cardinality is not fullfilled, <i>PARSE_ERROR</i> is returned.</p>
        <p>If an object of the selection returns a hard error (&lt; 0) while
          or any error occured for a selection which is not optional, an
          exception is thrown.</p></dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseSelection"></a>Class CBParseSelection</h1>
    <p>Derived from: <a href="Parse.html#ParseSelection">ParseSelection</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list  with a
      callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseSelection">ParseSelection</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseSelection1">CBParseSelection</a></td>
        <td>(<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
          <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseSelection2">CBParseSelection</a></td>
        <td>(const <a href="Parse.html#CBParseSelection">CBParseSelection</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~CBParseSelection">~CBParseSelection</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#CBParseSelection">CBParseSelection</a>&amp;</td>
        <td><a href="Parse.html#CBSeloperator=">operator=</a></td>
        <td>(const <a href="Parse.html#CBParseSelection">CBParseSelection</a>&amp; other)</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="Parse.html#CBSelsetCallback">setCallback</a></td>
        <td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#CBSelfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseSelection1"></a>CBParseSelection (<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
                  <a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback, unsigned int max = 1,
                  unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseSelection2"></a>CBParseSelection (const CBParseSelection&amp; other)</pre>
    <pre><a name="~CBParseSelection"></a>virtual ~CBParseSelection ()</pre>
    <pre><a name="CBSeloperator="></a>CBParseSelection&amp; operator= (const CBParseSelection&amp; other)</pre>

    <pre><a name="CBSelsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBSelfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseSelection"></a>Class OFParseSelection&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseSelection">ParseSelection</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list  with a
      callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseSelection">ParseSelection</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseSelection1">OFParseSelection</a></td>
        <td>(<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[],
          const char* description, T&amp; objToNotify,
          <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback,
          unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#OFParseSelection2">OFParseSelection</a></td>
        <td>(const <a href="Parse.html#OMParseSelection">OFParseSelection</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="Parse.html#~OFParseSelection">~OFParseSelection</a></td><td>()</td></tr>
      <tr valign="top"><td><a href="Parse.html#OMParseSelection">OFParseSelection</a>&amp;</td>
        <td><a href="Parse.html#OFSeloperator=">operator=</a></td>
        <td>(const <a href="Parse.html#OMParseSelection">OFParseSelection</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="Parse.html#OFSelfound">found</a></td>
        <td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseSelection1"></a>OFParseSelection (<a href="Parse.html#ParseObject">ParseObject</a>* apObjectList[], const char* description,
                 T&amp; objToNotify, <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max = 1,
                 unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseSelection2"></a>OFParseSelection (const OFParseSelection&amp; other)</pre>
    <pre><a name="~OFParseSelection"></a>virtual ~OFParseSelection ()</pre>
    <pre><a name="OFSeloperator="></a>OFParseSelection&amp; operator= (const OFParseSelection&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFSelfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>
  </body>
</html>
