<!-- $Id: Parse.html,v 1.4 2000/04/02 19:27:14 Markus Exp $ -->

<html>
  <head>
    <title>General Reference: Parser</title>
  </head>

  <body>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">General parser-information</h1>
    <p>Classes to parse objects and sequences of objects from a stream. If an
      object is found it is possible to start an action for this event.</p>

    <p>The classes of the parser exists in 3 variants:</p>
    <ul>
      <li>The first variant reports matching objects with a virtual
	function called <i>found</i>. These classes have the prefix
	<i>Parse</i>.</li>
      <li>The second calls a C-style function if an object was found and has
	therefore a function-pointer as parameter of the constructor(s). These
	classes	have a prefix of <i>CBParse</i>. The callbacks have the type
        <i><a name="PARSECALLBACK">PARSECALLBACK</a></i> which are pointer to
	functions with a const char*-paramter returning an integer.</li>
      <li>The third calls a C++-style function if an object was found and has
	therefore an object and a pointer to a memberfunction as parameter of
	he constructor(s). These classes starts with <i>OMParse</i>. The object
	can be of any type; the callback a <a name="PTCALLBACK"><i>T::*PTCALLBACK</i></a>
	which is a object-member expecting an const char*-paramter and returning
	an integer.</li>
    </ul>

    <p>Any of this functions must return the following values (which  specifies
      how the parsing should be continued):</p>
    <ul>
      <li><b>0</b>: Parsing (actually callback) OK</li>
      <li><b>&gt; 0</b>: Error while parsing; parsing can be continued (in
	sequences, ...)</li>
      <li><b>&lt; 0</b>: Error while parsing; abort parsing (unrecoverable
	error)</li>
    </ul>

    <p>If possible use the error-values (PARSE_OK, PARSE_ERROR, PARSE_CB_ERROR,
      PARSE_CB_ABORT) in the error-enum of <a href="Parse.html#ParseObject">
	ParseObject</a>.</p>

    <p>To minimize the usage of storage the parser can be compiled with the
      the macro <i>MULTIBUFFER</i> defined. This causes the buffer holding the
      actual parsed data to be allocated and released everytime a parse-object
      is parsed and therefore in a worse performance. Alternatively the method
      <a href="Parse.html#POAttfreeBuffer">ParseAttomic::freeBuffer</a> can
      be called (but better not while an object is parsed).</p>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseObject">Class ParseObject</a></h1>
    <p>Derived from: <i>None</i></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Abstract base-class for parsing objects. It contains methods of general
      purpose.</p>

    <p><b>Note</b>: The passed const char*-parameters are only stored and not
      copied, so ensure that they are valid during the lifetime of each
      parse-object!</p>

    <hr noshade="noshade">
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseObject1">ParseObject</a></td>
	<td>(const char* description, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseObject2">ParseObject</a></td>
	<td>(const <a href="Parse.html#ParseObject">ParseObject</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseObject">~ParseObject</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseObject">ParseObject</a>&amp;</td>
	<td><a href="Parse.html#POoperator=">operator=</a></td>
	<td>(const <a href="Parse.html#ParseObject">ParseObject</a>&amp; other)</td></tr>
      
      <tr valign="top"><td>const char*</td>
	<td><a href="Parse.html#POgetDescription">getDescription</a></td>
	<td>() const</td></tr>
      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#POsetDescription">setDescription</a></td>
	<td>(const char* desc)</td></tr>
      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#POsetSkipWS">setSkipWS</a></td>
	<td>(bool skipWhitespace)</td></tr>

      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#POskipWS">skipWS</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream)</td></tr>
      <tr valign="top"><td>int</td>
	<td><a href="Parse.html#POparse">parse</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw
	  (std::string)</td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POdoParse">doParse</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
	  bool optional) = 0</td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POfound">found</a></td>
	<td>(const char* pFoundValue)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseObject1">ParseObject (const char* description, bool skipWhitespace = true)</a></pre>
    <dl>
      <dd>Constructor; the parameter <i>description</i> must contain a
	description of the object, <i>skipWhitespace</i> defines if white-spaces
	should be skipped <b>after</b> sucessful parsing this object.
	<p><b>Note</b>: The description must be valid during the lifetime (or
	  at least the usage) of the object!</p></dd>
    </dl>
    <pre><a name="ParseObject2">ParseObject (const ParseObject& other)</a></pre>
    <pre><a name="~ParseObject">virtual ~ParseObject ()</a></pre>

    <pre><a name="POoperator=">ParseObject&amp; operator= (const ParseObject&amp; other)</a></pre>

    <h4>Accessing values</h4>
    <pre><a name="POgetDescription">const char* getDescription () const</a></pre>
    <dl>
      <dd>Retrieves the pointer to the description specified to this object.</dd>
    </dl>
    <pre><a name="POsetDescription">void setDescription (const char* desc)</a></pre>
    <dl>
      <dd>Changes the description of the object</dd>
    </dl>
    <pre><a name="POsetSkipWS">void setSkipWS (bool skipWhitespace)</a></pre>
    <dl>
      <dd>Sets the flag if whitespaces should be skipped after sucessfully
	parsing data matching the object.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a>void skipWS (</a><a href="XStream.html#Xistream">Xistream</a>&amp; stream) const</a></pre>
    <dl>
      <dd>Skips all whitespace characters (blank, tabulator, carriage return
	and line feed) from the current position in the passed stream.</dd>
    </dl>
    <pre><a name="POparse">int parse (</a><a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</a></pre>
    <dl>
      <dd>Tries to parse data matching the information stored with this
	parse-object from the passed stream. If this parsing is successful (the
	parsed data matches) this function returns <i>PARSE_OK</i>; else a
	non-zero value. Errors larger than 0 are <i>soft errors</i> and the
	parsing can be continued, errors less than 0 are <i>hard errors</i> and
	the parsing is stopped.</dd>

      <dt>&nbsp;&nbsp;&nbsp;&nbsp;Throws:</dt><dd>std::string with a description of
	the expected and the found data</dd>
    </dl>
    <pre><a name="POdoParse">virtual int doParse (</a><a href="XStream.html#Xistream">Xistream</a>&amp; stream)</a></pre>
    <dl>
      <dd>Pure virtual method defining the interface for the actual
	parse-method for the different parse-objects; to be implemented by the
	derived classes.

	<p>If this parsing is successful (the parsed data matches) this
	  function must return <i>PARSE_OK</i>; else a non-zero value. Errors
	  larger than 0 are <i>soft errors</i> and the parsing can be continued,
	  errors less than 0 are <i>hard errors</i> and the parsing is stopped.</p>
	<p>If possible used the predefined error-codes <i>PARSE_ERROR</i>,
	  <i>PARSE_CB_ERROR</i> and <i>PARSE_CB_ABORT</i>. Unrecoverable
	  (<i>hard</i>) errors can also be reported with an (explaining)
	  exception.</p></dd>
    </dl>
    <pre><a name="POfound">virtual int found (const char* pFoundValue)</a></pre>
    <dl>
      <dd>Callback to notify caller that an object has found itself during
	parsing. This callback can report its status with the return codes
	<i>PARSE_OK</i> or 0 for OK, <i>PARSE_CB_ERROR</i> or any other number
	larger than 0 for <i>soft errors</i> and <i>PARSE_CB_ABORT</i> or any
	number below 0 for <i>hard errors</i>.  Unrecoverable (<i>hard</i>)
	errors can also be reported with an (explaining) exception.</dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POcheckIntegrity">virtual int checkIntegrity () const</a></pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseEOF">Class ParseEOF</a></h1>
    <p>Derived from: <a href="Parse.html#ParseObject">ParseObject</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF).</p>

    <hr noshade="noshade">
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseEOF1">ParseEOF</a></td><td>()</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseEOF">~ParseEOF</a></td><td>()</td></tr>

      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POEOFdoParse">doParse</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
	  bool optional) = 0</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseEOF1">ParseEOF ()</a></pre>
    <pre><a name="~ParseEOF">virtual ~ParseEOF ()</a></pre>

    <h4>Parsing</h4>
    <pre><a name="POEOFdoParse">virtual int doParse (</a><a href="XStream.html#Xistream">Xistream</a>&amp; stream)</a></pre>
    <dl>
      <dd>Returns <i>PARSE_OK</i>; if the end of the stream has been
	reached; <i>PARSE_ERROR</i> if not.</dd>
    </dl>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="CBParseEOF">Class CBParseEOF</a></h1>
    <p>Derived from: <a href="Parse.html#ParseEOF">ParseEOF</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade="noshade">
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#CBParseEOF1">CBParseEOF</a></td>
	<td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~CBParseEOF">~CBParseEOF</a></td><td>()</td></tr>

      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#CBEOFsetCallback">setCallback</a></td>
	<td>(<a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#CBEOFfound">found</a></td>
	<td>(const char* pFoundValue)</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseEOF1">CBParseEOF (</a><a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a> callback)</a></pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="~CBParseEOF">virtual ~CBParseEOF ()</a></pre>

    <pre><a name="CBEOFsetCallback">void setCallback (</a><a href="Parse.html#PARSECALLBACK">PARSECALLBACK</a>)</a></pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBEOFfound">virtual int found (const char* pFoundValue)</a></pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
	result.</i></dd>
    </dl>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseAttomic">Class ParseAttomic</a></h1>
    <p>Derived from: <a href="Parse.html#ParseObject">ParseObject</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse an attomic value; Base-class of all attomic values.</p>

    <p>The member <i>pValue</i> has the following semantic: A parsed character
      is valid if it occures in the pValue-list, where the backslash (\)
      escapes the next charater to the following meaning:</p>

    <ul>
      <li><b>A</b> ... Any alphabethic character is valid</li>
      <li><b>X</b> ... Any alphanumeric character is valid</li>
      <li><b>9</b> ... Any number is valid</li>
      <li><b>0</b> ... The zero-character (\0) is valid</li>
      <li><b>n</b> ... The line-feed-character (\n) is valid</li>
      <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
      <li><b>\</b> ... The backslash itself is valid</li>
      <li><b>blank ( )</b> ... Any whitespace is valid</li>
      <li><b>*</b> ... Any character is valid</li>
    </ul>

    <p>The members <i>maxCard</i> and <i>minCard</i> specify how many characters
      the object can or must have. If there are less matching characters parsed,
      the object is considered as not found; after reaching the upper border,
      parsing is stopped (for this object).</p>

    <hr noshade="noshade">
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseAttomic1">ParseAttomic</a></td>
	<td>(const char* value, const char* description, unsigned int max = 1,
	  unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseAttomic2">ParseAttomic</a></td>
	<td>(const <a href="Parse.html#ParseAttomic">ParseAttomic</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseAttomic">~ParseAttomic</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseAttomic">ParseAttomic</a>&amp;</td>
	<td><a href="Parse.html#POAttoperator=">operator=</a></td>
	<td>(const <a href="Parse.html#ParseAttomic">ParseAttomic</a>&amp; other)</td></tr>

      <tr valign="top"><td>const char*</td>
	<td><a href="Parse.html#POAttgetValue">getValue</a></td><td>() const</td></tr>
      <tr valign="top"><td>unsigned int</td>
	<td><a href="Parse.html#POAttgetMaxCard">getMaxCard</a></td>
	<td>() const</td></tr>
      <tr valign="top"><td>unsigned int</td>
	<td><a href="Parse.html#POAttgetMinCard">getMinCard</a></td>
	<td>() const</td></tr>

      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#POAttsetValue">setValue</a></td>
	<td>(const char* value)</td></tr>
      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#POAttsetMaxCard">setMaxCard</a></td>
	<td>(unsigned int val)</td></tr>
      <tr valign="top"><td>void</td>
	<td><a href="Parse.html#POAttsetMinCard">setMinCard</a></td>
	<td>(unsigned int val)</td></tr>

      <tr valign="top"><td>static void</td>
	<td><a href="Parse.html#POAttfreeBuffer">freeBuffer</a></td><td>()</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POAttcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
      <tr valign="top"><td>virtual bool</td>
	<td><a href="Parse.html#POAttcheckValue">checkValue</a></td><td>(char ch)</td></tr>

      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POAttdoParse">doParse</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream,
	  bool optional) = 0</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseAttomic1">ParseAttomic (const char* value, const char* description, unsigned int max = 1,
              unsigned int min = 1, bool skipWhitespace = true)</a></pre>
    <dl>
      <dd>Constructor; sets the neccessary data of this object.
	<p>The parameter <i>value</i> specifies the valid characters for the
	  object, which can either be listed or specified by a type behind a
	  backslash (\) with the following characters:</p>

	<ul type="bullet">
	  <li><b>A</b> ... Any alphabethic character is valid</li>
	  <li><b>X</b> ... Any alphanumeric character is valid</li>
	  <li><b>9</b> ... Any number is valid</li>
	  <li><b>0</b> ... The zero-character (\0) is valid</li>
	  <li><b>n</b> ... The line-feed-character (\n) is valid</li>
	  <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
	  <li><b>\</b> ... The backslash itself is valid</li>
	  <li><b>blank ( )</b> ... Any whitespace is valid</li>
	  <li><b>*</b> ... Any character is valid</li>
	</ul>

	<p>That means a value like "\9abcdeABCDE" would report all
	  hexadecimal values as valid. <b>Note</b>: The backslash (\) is a
	  character itself, so in a C-file this definition must be written as
	  "\\9abcdeABCDE"!</p>

	<p>The parameters <i>max</i> and <i>min</i> specify the maximal and
	  minimal number of characters this object may contain.</p></dd>
    </dl>
    <pre><a name="ParseAttomic2">ParseAttomic (const ParseAttomic&amp; other)</a></pre>
    <pre><a name="~ParseAttomic">virtual ~ParseAttomic ()</a></pre>

    <pre><a name="POAttoperator=">ParseAttomic&amp; operator= (const ParseAttomic&amp; other)</a></pre>

    <pre><a name="POAttfreeBuffer">static void freeBuffer</a></pre>
    <dl>
      <dd>Frees the buffer which is used to store the parsed data. Use with
	care (only at the end of parsing and not during parsing a single
	object).

      <p>By default the parse-buffer is freed during the cleanup at the
	  termination of the program or (if compiled with the macro
	  MULTIBUFFER defined) everytime an attomic object finishes its
	  parsing (successful or not).</p></dd>
    </dl>

    <h4>Accessing values</h4>
    <pre><a name="POAttgetValue">const char* getValue () const</a></pre>
    <dl>
      <dd>Returns a pointer to the stored valid characters.</dd>
    </dl>
    <pre><a name="POAttsetValue">setValue (const char* value)</a></pre>
    <dl>
      <dd>Changes the valid characters. This parameter must be valid (not
	freed) for the whole lifetime (usage) of the object.</dd>
    </dl>
    <pre><a name="POAttgetMaxCard">unsigned int getMaxCard () const</a></pre>
    <dl>
      <dd>Returns the maximal number of characters this object may match while
	parsing.</dd>
    </dl>
    <pre><a name="POAttsetMaxCard">setMaxCard (unsigned int val)</a></pre>
    <dl>
      <dd>Changes the maximal number of characters this object may match while
	parsing.</dd>
    </dl>
    <pre><a name="POAttgetMinCard">unsigned int getMinCard () const</a></pre>
    <dl>
      <dd>Returns the minimal number of characters this object must match while
	parsing.</dd>
    </dl>
    <pre><a name="POAttsetMinCard">setMinCard (unsigned int val)</a></pre>
    <dl>
      <dd>Changes the minimal number of characters this object must match while
	parsing.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="POAttdoParse">virtual int doParse (</a><a href="XStream.html#Xistream">Xistream</a>&amp; stream)</a></pre>
    <dl>
      <dd>Returns <i>PARSE_OK</i>; if the end of the stream has been reached;
	<i>PARSE_ERROR</i> if not.</dd>
    </dl>
    <pre><a name="POAttcheckValue">virtual bool checkValue (char ch) const</a></pre>
    <dl>
      <dd>Checks if ch is valid according the value-list of the object. See the
	<a href="Parse.html#ParseAttomic1">constructor</a> or the
	<a href="Parse.html#ParseAttomic">general information</a> at the
	beginning of the documentation to this class for further information</dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POAttcheckIntegrity">virtual int checkIntegrity () const</a></pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseText">Class ParseText</a></h1>
    <p>Derived from: <a href="Parse.html#ParseAttomic">ParseAttomic</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.</p>

    <p>Parsing of this element is stopped, if any of the characters in the
      abort-parameters is found (or the maximal cardinality is reached).</p>

    <hr noshade="noshade">
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseText1">ParseText</a></td>
	<td>(const char* abort, const char* description, unsigned int max = 1,
	  unsigned int min = 1, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseText2">ParseText</a></td>
	<td>(const <a href="Parse.html#ParseText">ParseText</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseText">~ParseText</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseText">ParseText</a>&amp;</td>
	<td><a href="Parse.html#POTxtoperator=">operator=</a></td>
	<td>(const <a href="Parse.html#ParseText">ParseText</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual bool</td>
	<td><a href="Parse.html#POTxtcheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseText1">ParseText (const char* abort, const char* description, unsigned int max = 1,
           unsigned int min = 1, bool skipWhitespace = true)</a></pre>
    <dl>
      <dd>Constructor; sets the neccessary data of this object.
	<p>The parameter <i>abort</i> specifies the characters which ends the
	  parsing for this object.</p></dd>
    </dl>

    <pre><a name="ParseText2">ParseText (const ParseText&amp; other)</a></pre>
    <pre><a name="~ParseText">virtual ~ParseText ()</a></pre>

    <pre><a name="POTxtoperator=">ParseText&amp; operator= (const ParseText&amp; other)</a></pre>

    <pre><a name="POTxtcheckValue">virtual bool checkValue (char ch) const</a></pre>
    <dl>
      <dd>Checks if the parsed value is according the abort-list of the object.
	If the parsed character is inside the list, false is returned; if not
	true.</dd>
    </dl>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseTextEsc">Class ParseTextEsc</a></h1>
    <p>Derived from: <a href="Parse.html#ParseText">ParseText</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.</p>

    <p>Parsing of this element is stopped, if the maximal cardinality is
      reached or any of the characters in the abort-parameters is found which
      is not succeeded by a certain (defined) character.</p>
    <p>This class enables parsing analogue to strings in C. A C-string is
      terminated with a quote ("), except if the quote follows a backslash (\).
      The only difference is that both quote and backslash can be specified and
      therefor be every charcter.</p>

    <hr noshade="noshade">
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseTextEsc1">ParseTextEsc</a></td>
	<td>(const char* abort, const char* description, unsigned int max = 1,
	  unsigned int min = 1, char escape = '\\', bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseTextEsc2">ParseTextEsc</a></td>
	<td>(const <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseTextEsc">~ParseTextEsc</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseTextEsc">ParseTextEsc</a>&amp;</td>
	<td><a href="Parse.html#POTxEoperator=">operator=</a></td>
	<td>(const <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual bool</td>
	<td><a href="Parse.html#POTxEcheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseTextEsc1">ParseTextEsc (const char* abort, const char* description, unsigned int max = 1,
              unsigned int min = 1, char escape = '\\', bool skipWhitespace = true)</a></pre>
    <dl>
      <dd>Constructor; sets the neccessary data of this object.
	<p>The parameter <i>abort</i> specifies the characters which ends the
	  parsing for this object (if it is not succeeded by the character
	  defined with the parameter <i>escape</i>).</p></dd>
    </dl>

    <pre><a name="ParseTextEsc2">ParseTextEsc (const ParseTextEsc&amp; other)</a></pre>
    <pre><a name="~ParseTextEsc">virtual ~ParseTextEsc ()</a></pre>

    <pre><a name="POTxEoperator=">ParseTextEsc&amp; operator= (const ParseTextEsc&amp; other)</a></pre>

    <pre><a name="POTxEcheckValue">virtual bool checkValue (char ch) const</a></pre>
    <dl>
      <dd>Checks if the parsed value is according the abort-list of the object.
	If the parsed character is inside the list and not succeeded by the
	escape-character, false is returned; if not true.</dd>
    </dl>

    <hr noshade="noshade">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseExact">Class ParseExact</a></h1>
    <p>Derived from: <a href="Parse.html#ParseExact">ParseExact</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!)</p>
    <p>The min- and max-members are not totally wasted; they could be used to
      define the minimal length of certain keywords which would be valid even
      if just written in a short(er) form.</p>

    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseExact1">ParseExact</a></td>
	<td>(const char* value, const char* description, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseExact2">ParseExact</a></td>
	<td>(const char* value, const char* description, unsigned int max,
	  unsigned int min, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseExact3">ParseExact</a></td>
	<td>(const <a href="Parse.html#ParseExact">ParseExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseExact">~ParseExact</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseExact">ParseExact</a>&amp;</td>
	<td><a href="Parse.html#POExaoperator=">operator=</a></td>
	<td>(const <a href="Parse.html#ParseExact">ParseExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POExacheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
      <tr valign="top"><td>virtual bool</td>
	<td><a href="Parse.html#POExacheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseExact1">ParseExact (const char* value, const char* description, bool skipWhitespace = true)</a></pre>
    <pre><a name="ParseExact2">ParseExact (const char* value, const char* description, unsigned int max,
            unsigned int min, bool skipWhitespace = true)</a></pre>
    <dl>
      <dd>The parameters <i>min</i> and <i>max</i> could be used to define a
	minimal length of a keyword. This word would be valid if at least min
	characters would be parsed, but other (longer) versions of the word
	would also be valid.
    </dl>

    <pre><a name="ParseExact3">ParseExact (const ParseExact&amp; other)</a></pre>
    <pre><a name="~ParseExact">virtual ~ParseExact ()</a></pre>

    <pre><a name="POExaoperator=">ParseExact&amp; operator= (const ParseExact&amp; other)</a></pre>

    <pre><a name="POExacheckValue">virtual bool checkValue (char ch) const</a></pre>
    <dl>
      <dd>Retruns true, if the passed character is exactly equal (case-sensitive!)
	than the one in the actual position of the object; else false.</dd>
    </dl>
    <pre><a name="POExacheckIntegrity">virtual int checkIntegrity () const</a></pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
	<td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="ParseUpperExact">Class ParseUpperExact</a></h1>
    <p>Derived from: <a href="Parse.html#ParseAttomic">ParseAttomic</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade="noshade">
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!)</p>
    <p>The min- and max-members are not totally wasted; they could be used to
      define the minimal length of certain keywords which would be valid even
      if just written in a short(er) form.</p>

    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseUpperExact1">ParseUpperExact</a></td>
	<td>(const char* value, const char* description, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseUpperExact2">ParseUpperExact</a></td>
	<td>(const char* value, const char* description, unsigned int max,
	  unsigned int min, bool skipWhitespace = true)</td></tr>
      <tr valign="top"><td></td><td><a href="Parse.html#ParseUpperExact3">ParseUpperExact</a></td>
	<td>(const <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>&amp; other)</td></tr>
      <tr valign="top"><td>virtual</td>
	<td><a href="Parse.html#~ParseUpperExact">~ParseUpperExact</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="Parse.html#ParseUpperExact">ParseUpperExact</a>&amp;</td>
	<td><a href="Parse.html#POUExoperator=">operator=</a></td>
	<td>(const <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>&amp; other)</td></tr>

      <tr valign="top"><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
	<td><a href="Parse.html#POUExcheckIntegrity">checkIntegrity</a></td><td>() const</td></tr>
      <tr valign="top"><td>virtual bool</td>
	<td><a href="Parse.html#POUExcheckValue">checkValue</a></td><td>(char ch)</td></tr>
    </table>

    <hr noshade="noshade">
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseUpperExact1">ParseUpperExact (const char* value, const char* description, bool skipWhitespace = true)</a></pre>
    <pre><a name="ParseUpperExact2">ParseUpperExact (const char* value, const char* description, unsigned int max,
            unsigned int min, bool skipWhitespace = true)</a></pre>
    <dl>
      <dd>The parameters <i>min</i> and <i>max</i> could be used to define a
	minimal length of a keyword. This word would be valid if at least min
	characters would be parsed, but other (longer) versions of the word
	would also be valid.
    </dl>

    <pre><a name="ParseUpperExact3">ParseUpperExact (const ParseUpperExact&amp; other)</a></pre>
    <pre><a name="~ParseUpperExact">virtual ~ParseUpperExact ()</a></pre>

    <pre><a name="POUExoperator=">ParseUpperExact&amp; operator= (const ParseUpperExact&amp; other)</a></pre>

    <pre><a name="POUExcheckValue">virtual bool checkValue (char ch) const</a></pre>
    <dl>
      <dd>Retruns true, if the passed character is exactly equal (not
	case-sensitive!) than the one in the actual position of the object;
	else false.</dd>
    </dl>
    <pre><a name="POUExcheckIntegrity">virtual int checkIntegrity () const</a></pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>
  </body>
</html>
