<!-- $Id: Parse.html,v 1.12 2001/10/19 19:49:47 markus Exp $ -->

<html>
  <head>
    <title>General Reference: Parser</title>
    <meta name="description" content="Documentation of general parser">
    <meta name="keywords" content="Documentation, Docu, Parser, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <a name="General"></a>
  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">General parser-information</h1>
    <p>Classes to parse objects and sequences of objects from a stream. If an
      object is found it is possible to start an action for this event.</p>

    <p>The classes of the parser exists in 3 variants:</p>
    <ul>
      <li>The first variant reports matching objects with a virtual
        function called <i>found</i>. These classes have the prefix
        <i>Parse</i>.</li>
      <li>The second calls a C-style function if an object was found and has
        therefore a function-pointer as parameter of the constructor(s). These
        classes have a prefix of <i>CBParse</i>. The callbacks have the type
        <i><a name="PARSECALLBACK"></a>PARSECALLBACK</i> which are pointer to
        functions with a const char*-paramter returning an integer.</li>
      <li>The third calls a C++-style function if an object was found and has
        therefore an object and a pointer to a memberfunction as parameter of
        he constructor(s). These classes starts with <i>OFParse</i>. The object
        can be of any type; the callback a <a name="PTCALLBACK"></a><i>T::*PTCALLBACK</i>
        which is a object-member expecting an const char*-paramter and returning
        an integer.</li>
    </ul>

    <p>Any of this functions must return the following values (which  specifies
      how the parsing should be continued):</p>
    <dl compact>
      <dt><b>0</b></dt>
      <dd>Parsing (actually callback) OK</dd>
      <dt><b>&gt; 0</b></dt>
      <dd>Error while parsing; parsing can be continued (in sequences, ...)</dd>
      <dt><b>&lt; 0</b></dt>
      <dd>Error while parsing; abort parsing (unrecoverable error)</dd>
    </dl>

    <p>If possible use the error-values (PARSE_OK, PARSE_ERROR, PARSE_CB_ERROR,
      PARSE_CB_ABORT) in the error-enum of <a href="Parse.html#ParseObject">
	ParseObject</a>.</p>

    <p>To minimize the usage of storage the parser can be compiled with the
      the macro <i>MULTIBUFFER</i> defined. This causes the buffer holding the
      actual parsed data to be allocated and released everytime a parse-object
      is parsed and therefore in a worse performance. Alternatively the method
      <a href="Parse.html#POAttfreeBuffer">ParseAttomic::freeBuffer</a> can
      be called (but better not while an object is parsed).</p>

    <hr noshade><a name="ParseObject"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseObject</h1>
    <p>Derived from
      <i>none</i>
      <br>
      Derived by:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <a href="Parse.html#ParseEOF">ParseEOF</a>
      <a href="Parse.html#ParseSequence">ParseSequence</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <h2>Description</h2>
    <p>Abstract base-class for parsing objects. It contains methods of general
      purpose.</p>

    <p><b>Note</b>: The passed const char*-parameters are only stored and not
      copied, so ensure that they are valid during the lifetime of each
      parse-object!</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseObject1"><b>ParseObject</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseObject2"><b>ParseObject</b></a></td>
        <td><tt>(<tt>const</tt> <a href="ParseObject.html#ParseObject"><b>ParseObject</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POdoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><font color="blue">stream</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">optional</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <tt><font color="purple">char</font></tt>*</tt> </td>
        <td><a href="Parse.html#POgetDescription"><b>getDescription</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ParseObject.html#ParseObject"><b>ParseObject</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POoperator="><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ParseObject.html#ParseObject"><b>ParseObject</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POparse"><b>parse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistram"><b>Xistream</b></a>&amp; <tt><font color="blue">stream</font></tt>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POsetDescription"><b>setDescription</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">desc</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POsetSkipWS"><b>setSkipWS</b></a></td>
        <td><tt>(<tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POskipWS"><b>skipWS</b></a></td>
        <td><tt>(<a href="XStream.html#Xistram"><b>Xistream</b></a>&amp; <tt><font color="blue">stream</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseObject"><b>~ParseObject</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseObject1"></a>ParseObject (const char* description, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; the parameter <i>description</i> must contain a
        description of the object, <i>skipWhitespace</i> defines if white-spaces
        should be skipped <b>after</b> sucessful parsing this object.</p>
      <p><b>Note</b>: The description must be valid during the lifetime (or
        at least the usage) of the object!</p></dd>
    </dl>
    <pre><a name="ParseObject2"></a>ParseObject (const ParseObject&amp; other)</pre>
    <pre><a name="~ParseObject"></a>virtual ~ParseObject ()</pre>

    <pre><a name="POoperator="></a>ParseObject&amp; operator= (const ParseObject&amp; other)</pre>

    <h4>Accessing values</h4>
    <pre><a name="POgetDescription"></a>const char* getDescription () const</pre>
    <dl>
      <dd>Retrieves the pointer to the description specified to this object.</dd>
    </dl>
    <pre><a name="POsetDescription"></a>void setDescription (const char* desc)</pre>
    <dl>
      <dd>Changes the description of the object</dd>
    </dl>
    <pre><a name="POsetSkipWS"></a>void setSkipWS (bool skipWhitespace)</pre>
    <dl>
      <dd>Sets the flag if whitespaces should be skipped after sucessfully
        parsing data matching the object.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="POskipWS"></a>void skipWS (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) const</pre>
    <dl>
      <dd>Skips all whitespace characters (blank, tabulator, carriage return
        and line feed) from the current position in the passed stream.</dd>
    </dl>
    <pre><a name="POparse"></a>int parse (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd>Tries to parse data matching the information stored with this
        parse-object from the passed stream. If this parsing is successful (the
        parsed data matches) this function returns <i>PARSE_OK</i>; else a
        non-zero value. Errors larger than 0 are <i>soft errors</i> and the
        parsing can be continued, errors less than 0 are <i>hard errors</i> and
        the parsing is stopped.</dd>

      <dt>&nbsp;&nbsp;&nbsp;&nbsp;Throws:</dt><dd>std::string with a description of
        the expected and the found data</dd>
    </dl>
    <pre><a name="POdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool optional)</pre>
    <dl>
      <dd><p>Pure virtual method defining the interface for the actual
        parse-method for the different parse-objects; to be implemented by the
        derived classes.</p>

        <p>The parameter <i>optional</i> specifies if the object has to be
          found or is optional (like in
          <a href="Parse.html#ParseSelection">selections</a>).</p>

        <p>If this parsing is successful (the parsed data matches) this
          function must return <i>PARSE_OK</i>; else a non-zero value. Errors
          larger than 0 are <i>soft errors</i> and the parsing can be continued,
          errors less than 0 are <i>hard errors</i> and the parsing is stopped.</p>
        <p>If possible used the predefined error-codes <i>PARSE_ERROR</i>,
          <i>PARSE_CB_ERROR</i> and <i>PARSE_CB_ABORT</i>. Unrecoverable
          (<i>hard</i>) errors can also be reported with an (explaining)
          exception.</p></dd>
    </dl>
    <pre><a name="POfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Callback to notify caller that an object has found itself during
        parsing. This callback can report its status with the return codes
        <i>PARSE_OK</i> or 0 for OK, <i>PARSE_CB_ERROR</i> or any other number
        larger than 0 for <i>soft errors</i> and <i>PARSE_CB_ABORT</i> or any
        number below 0 for <i>hard errors</i>.  Unrecoverable (<i>hard</i>)
        errors can also be reported with an (explaining) exception.</dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade><a name="ParseEOF">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"></a>Class ParseEOF</h1>
    <p>Derived from
      <a href="Parse.html#ParseObject">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseEOF">CBParseEOF</a>
      <a href="Parse.html#OMParseEOF">OFParseEOF&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ParseEOF.html#ParseEOF"><b>ParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POEOFdoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><font color="blue">stream</font></tt>, <tt><font color="purple">bool</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseEOF"><b>~ParseEOF</b></a></td>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseEOF1"></a>ParseEOF ()</pre>
    <pre><a name="~ParseEOF"></a>virtual ~ParseEOF ()</pre>

    <h4>Parsing</h4>
    <pre><a name="POEOFdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream, bool)</pre>
    <dl>
      <dd>Returns <i>PARSE_OK</i>; if the end of the stream has been
        reached; <i>PARSE_ERROR</i> if not.</dd>
    </dl>

    <hr noshade><a name="CBParseEOF"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseEOF</h1>
    <p>Derived from
      <a href="ParseEOF.html">ParseEOF</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseEOF"><b>CBParseEOF</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><font color="blue">callback</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBEOFsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><font color="blue">callback</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseEOF"><b>~CBParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBEOFfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseEOF1"></a>CBParseEOF (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="~CBParseEOF"></a>virtual ~CBParseEOF ()</pre>

    <pre><a name="CBEOFsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBEOFfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseEOF"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseEOF&lt;T&gt;</h1>
    <p>Derived from
      <a href="ParseEOF.html">ParseEOF</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseEOF"><b>CBParseEOF</b></a></td>
        <td><tt>(<tt><font color="navy">T</font>&amp;</tt> <tt><font color="blue">objToNotify</font></tt>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <tt><font color="blue">callback</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseEOF"><b>~CBParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFEOFfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseEOF1"></a>OFParseEOF (T&amp; objToNotify, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="~OFParseEOF"></a>virtual ~OFParseEOF ()</pre>

    <h4>Parsing</h4>
    <pre><a name="OFEOFfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseAttomic"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseAttomic</h1>
    <p>Derived from:
      <a href="Parse.html#ParseObject">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseAttomic">CBParseAttomic</a>
      <a href="Parse.html#OMParseAttomic">OFParseAttomic&lt;T&gt;</a>
      <a href="Parse.html#ParseExact">ParseExact</a>
      <a href="Parse.html#ParseText">ParseText</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse an attomic value; Base-class of all attomic values.</p>

    <p>The member <i>pValue</i> has the following semantic: A parsed character
      is valid if it occures in the pValue-list, where the backslash (\)
      escapes the next charater to the following meaning:</p>

    <ul>
      <li><b>A</b> ... Any alphabethic character is valid</li>
      <li><b>X</b> ... Any alphanumeric character is valid</li>
      <li><b>9</b> ... Any number is valid</li>
      <li><b>0</b> ... The zero-character (\0) is valid</li>
      <li><b>n</b> ... The line-feed-character (\n) is valid</li>
      <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
      <li><b>\</b> ... The backslash itself is valid</li>
      <li><b>blank ( )</b> ... Any whitespace is valid</li>
      <li><b>*</b> ... Any character is valid</li>
    </ul>

    <p>The members <i>maxCard</i> and <i>minCard</i> specify how many characters
      the object can or must have. If there are less matching characters parsed,
      the object is considered as not found; after reaching the upper border,
      parsing is stopped (for this object).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseAttomic1"><b>ParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseAttomic2"><b>ParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POAttfreeBuffer"><b>freeBuffer</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POAttgetMaxCard"><b>getMaxCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POAttgetMinCard"><b>getMinCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <tt><font color="purple">char</font></tt>*</tt> </td>
        <td><a href="Parse.html#POAttgetValue"><b>getValue</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POAttoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POAttsetMaxCard"><b>setMaxCard</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">val</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POAttsetMinCard"><b>setMinCard</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">val</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POAttsetValue"><b>setValue</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseAttomic"><b>~ParseAttomic</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POAttcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="Parse.html#POAttcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual <font color="purple">int</font></tt></td>
        <td><a href="Parse.html#POAttdoParse"><b>doParse</b></a></td>
        <td>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <font color="blue">stream</font>,
	  <font color="purple">bool</font> <font color="blue">optional</font>) throw (<font color="purple">std::string</font>)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseAttomic1"></a>ParseAttomic (const char* value, const char* description, unsigned int max = 1,
              unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
	<p>The parameter <i>value</i> specifies the valid characters for the
	  object, which can either be listed or specified by a type behind a
	  backslash (\) with the following characters:</p>

  <ul type="disc">
	  <li><b>A</b> ... Any alphabethic character is valid</li>
	  <li><b>X</b> ... Any alphanumeric character is valid</li>
	  <li><b>9</b> ... Any number is valid</li>
	  <li><b>0</b> ... The zero-character (\0) is valid</li>
	  <li><b>n</b> ... The line-feed-character (\n) is valid</li>
	  <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
	  <li><b>\</b> ... The backslash itself is valid</li>
	  <li><b>blank ( )</b> ... Any whitespace is valid</li>
	  <li><b>*</b> ... Any character is valid</li>
	</ul>

	<p>That means a value like "\9abcdeABCDE" would report all
	  hexadecimal values as valid. <b>Note</b>: The backslash (\) is a
	  character itself, so in a C-file this definition must be written as
	  "\\9abcdeABCDE"!</p>

	<p>The parameters <i>max</i> and <i>min</i> specify the maximal and
	  minimal number of characters this object may contain.</p></dd>
    </dl>
    <pre><a name="ParseAttomic2"></a>ParseAttomic (const ParseAttomic&amp; other)</pre>
    <pre><a name="~ParseAttomic"></a>virtual ~ParseAttomic ()</pre>

    <pre><a name="POAttoperator="></a>ParseAttomic&amp; operator= (const ParseAttomic&amp; other)</pre>

    <pre><a name="POAttfreeBuffer"></a>static void freeBuffer ()</pre>
    <dl>
      <dd><p>Frees the buffer which is used to store the parsed data. Use with
          care (only at the end of parsing and not during parsing a single
          object).</p>

        <p>By default the parse-buffer is freed during the cleanup at the
          termination of the program or (if compiled with the macro
          MULTIBUFFER defined) everytime an attomic object finishes its
          parsing (successful or not).</p></dd>
    </dl>

    <h4>Accessing values</h4>
    <pre><a name="POAttgetValue"></a>const char* getValue () const</pre>
    <dl>
      <dd>Returns a pointer to the stored valid characters.</dd>
    </dl>
    <pre><a name="POAttsetValue"></a>setValue (const char* value)</pre>
    <dl>
      <dd>Changes the valid characters. This parameter must be valid (not
        freed) for the whole lifetime (usage) of the object.</dd>
    </dl>
    <pre><a name="POAttgetMaxCard"></a>unsigned int getMaxCard () const</pre>
    <dl>
      <dd>Returns the maximal number of characters this object may match while
        parsing.</dd>
    </dl>
    <pre><a name="POAttsetMaxCard"></a>void setMaxCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the maximal number of characters this object may match while
        parsing.</dd>
    </dl>
    <pre><a name="POAttgetMinCard"></a>unsigned int getMinCard () const</pre>
    <dl>
      <dd>Returns the minimal number of characters this object must match while
        parsing.</dd>
    </dl>
    <pre><a name="POAttsetMinCard"></a>void setMinCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the minimal number of characters this object must match while
        parsing.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="POAttdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream">Xistream</a>&amp; stream, bool optional) throw (std::string)</pre>
    <dl>
      <dd><p>Returns <i>PARSE_OK</i> if data matching the object is found (and
          the callback does not report something different).</p>
        <p>It is a soft error (<i>PARSE_ERROR</i>) if the minimal cardinality is
          not fullfilled.</p>
        <p>If parsing is optional or the error is recoverable (&gt; 0), the
          parsed data is pushed back into the stream and <i>PARSE_ERROR</i> is
          returned.</p>
        <p>If parsing is not optional and the error is not recoverable (&lt; 0),
          an exception (std::string) is thrown.</p></dd>
    </dl>
    <pre><a name="POAttcheckValue"></a>virtual bool checkValue (char ch)</pre>
    <dl>
      <dd>Checks if ch is valid according the value-list of the object. See the
        <a href="Parse.html#ParseAttomic1">constructor</a> or the
        <a href="Parse.html#ParseAttomic">general information</a> at the
          beginning of the documentation to this class for further information</dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POAttcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade><a name="CBParseAttomic">

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"></a>Class CBParseAttomic</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse attomic values with a callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseAttomic1"><b>CBParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</a></b> <tt><font color="blue">callback</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseAttomic2"><b>CBParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseAttomic"><b>CBParseAttomic</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseAttomic"><b>CBParseAttomic</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBAttoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseAttomic"><b>CBParseAttomic</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBAttsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><font color="blue">callback</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseAttomic"><b>~CBParseAttomic</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBAttfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseAttomic1"></a>CBParseAttomic (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
                unsigned int max = 1, unsigned int min = 1,
                bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseAttomic2"></a>CBParseAttomic (const CBParseAttomic&amp; other)</pre>
    <pre><a name="~CBParseAttomic"></a>virtual ~CBParseAttomic ()</pre>
    <pre><a name="CBAttoperator="></a>CBParseAttomic&amp; operator= (const CBParseAttomic&amp; other)</pre>

    <pre><a name="CBAttsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBAttfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseAttomic"></a>Class OFParseAttomic&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse attomic values with a callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td></td>
        <td><a href="Parse.html#OFParseAttomic1"><b>OFParseAttomic</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</a></b> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font> = 1, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font> = 1, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseAttomic2"><b>OFParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseAttomic"><b>OFParseAttomic</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OFParseAttomic"><b>OFParseAttomic</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFAttoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseAttomic"><b>OFParseAttomic</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseAttomic"><b>~OFParseAttomic</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFAttfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseAttomic1"></a>OFParseAttomic (const char* value, const char* description, T&amp; objToNotify,
                <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max = 1,
                unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseAttomic2"></a>OFParseAttomic (const OFParseAttomic&amp; other)</pre>
    <pre><a name="~OFParseAttomic"></a>virtual ~OFParseAttomic ()</pre>
    <pre><a name="OFAttoperator="></a>OFParseAttomic&amp; operator= (const OFParseAttomic&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFAttfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseText"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseText</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseText">CBParseText</a>
      <a href="Parse.html#OMParseText">OFParseText&lt;T&gt;</a>
      <a href="Parse.html#ParseTextEsc">ParseTextEsc</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.</p>

    <p>Parsing of this element is stopped, if any of the characters in the
      abort-parameters is found (or the maximal cardinality is reached).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseText1"><b>ParseText</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">abort</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseText2"><b>ParseText</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseText"><b>ParseText</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseText"><b>ParseText</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POTxtoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseText"><b>ParseText</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseText"><b>~ParseText</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="Parse.html#POTxtcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseText1"></a>ParseText (const char* abort, const char* description, unsigned int max,
           unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>abort</i> specifies the characters which ends the
          parsing for this object.</p></dd>
    </dl>

    <pre><a name="ParseText2"></a>ParseText (const ParseText&amp; other)</pre>
    <pre><a name="~ParseText"></a>virtual ~ParseText ()</pre>

    <pre><a name="POTxtoperator="></a>ParseText&amp; operator= (const ParseText&amp; other)</pre>

    <pre><a name="POTxtcheckValue"></a>virtual bool checkValue (char ch)</pre>
    <dl>
      <dd>Checks if the parsed value is according the abort-list of the object.
        If the parsed character is inside the list, false is returned; if not
        true.</dd>
    </dl>

    <hr noshade><a name="CBParseText"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseText</h1>
    <p>Derived from:
      <a href="Parse.html#ParseText">ParseText</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseText"><b>ParseText</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseText1"><b>CBParseText</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">abort</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font> = 1, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseText2"><b>CBParseText</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseText"><b>CBParseText</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseText"><b>CBParseText</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBTxtoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseText"><b>CBParseText</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBTxtsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseText"><b>~CBParseText</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBTxtfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseText1"></a>CBParseText (const char* abort, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
             unsigned int max, unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseText2"></a>CBParseText (const CBParseText&amp; other)</pre>
    <pre><a name="~CBParseText"></a>virtual ~CBParseText ()</pre>
    <pre><a name="CBTxtoperator="></a>CBParseText&amp; operator= (const CBParseText&amp; other)</pre>

    <pre><a name="CBTxtsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBTxtfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseText"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseText&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseText">ParseText</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseText">ParseText</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td></td>
        <td><a href="Parse.html#OFParseText1"><b>OFParseText</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">abort</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</a></b> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font> = 1, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseText2"><b>OFParseText</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseText"><b>OFParseText</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OFParseText"><b>OFParseText</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFTxtoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseText"><b>OFParseText</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseText"><b>~OFParseText</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFTxtfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseText1"></a>OFParseText (const char* abort, const char* description, T&amp; objToNotify,
             <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max,
             unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseText2"></a>OFParseText (const OFParseText&amp; other)</pre>
    <pre><a name="~OFParseText"></a>virtual ~OFParseText ()</pre>
    <pre><a name="OFTxtoperator="></a>OFParseText&amp; operator= (const OFParseText&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFTxtfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseTextEsc"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseTextEsc</h1>
    <p>Derived from:
      <a href="Parse.html#ParseText">ParseText</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseTextEsc">CBParseTextEsc</a>
      <a href="Parse.html#OMParseTextEsc">OFParseTextEsc&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.
      However, parsing is continued if those characters are preceeded by a
      escape-character (which "escapes" the special meaning of that character).</p>

    <p>Parsing of this element is stopped, if the maximal cardinality is
      reached or any of the characters in the abort-parameters is found which
      is not succeeded by a certain (defined) character.</p>

    <p>This class enables parsing analogue to strings in C. A C-string is
      terminated with a quote ("), except if the quote follows a backslash (\).
      The only difference is that both quote and backslash can be specified and
      therefor be every charcter.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseTextEsc1"><b>ParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">abort</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">char</font></tt> <tt><font color="blue">escape</font></tt> = '\\', <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseTextEsc2"><b>ParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POTxEoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseTextEsc"><b>~ParseTextEsc</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="Parse.html#POTxEcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseTextEsc1"></a>ParseTextEsc (const char* abort, const char* description, unsigned int max,
              unsigned int min = 1, char escape = '\\', bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>abort</i> specifies the characters which ends the
          parsing for this object (if it is not succeeded by the character
          defined with the parameter <i>escape</i>).</p></dd>
    </dl>

    <pre><a name="ParseTextEsc2"></a>ParseTextEsc (const ParseTextEsc&amp; other)</pre>
    <pre><a name="~ParseTextEsc"></a>virtual ~ParseTextEsc ()</pre>

    <pre><a name="POTxEoperator="></a>ParseTextEsc&amp; operator= (const ParseTextEsc&amp; other)</pre>

    <pre><a name="POTxEcheckValue"></a>virtual bool checkValue (char ch)</pre>
    <dl>
      <dd>Checks if the parsed value is according the abort-list of the object.
        If the parsed character is inside the list and not succeeded by the
        escape-character, false is returned; if not true.</dd>
    </dl>

    <hr noshade><a name="CBParseTextEsc"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseTextEsc</h1>
    <p>Derived from:
      <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseTextEsc1"><b>CBParseTextEsc</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">abort</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font> = 1, <font color="purple">char</font> <font color="blue">escape</font> = '\\', <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseTextEsc2"><b>CBParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseTextEsc"><b>CBParseTextEsc</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseTextEsc"><b>CBParseTextEsc</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBTxEoperator="><tt><font color="black"><b>operator</b></font></tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseTextEsc"><b>CBParseTextEsc</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBTxEsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseTextEsc"><b>~CBParseTextEsc</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBTxEfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseTextEsc1"></a>CBParseTextEsc (const char* abort, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
                unsigned int max, unsigned int min = 1, char escape = '\\',
                bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseTextEsc2"></a>CBParseTextEsc (const CBParseText&amp; other)</pre>
    <pre><a name="~CBParseTextEsc"></a>virtual ~CBParseTextEsc ()</pre>
    <pre><a name="CBTxEoperator="></a>CBParseTextEsc&amp; operator= (const CBParseTextEsc&amp; other)</pre>

    <pre><a name="CBTxEsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBTxEfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseTextEsc"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseTextEsc&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseTextEsc">ParseTextEsc</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseTextEsc1"><b>OFParseTextEsc</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">abort</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a>  <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font> = 1, <font color="purple">char</font> <font color="blue">escape</font> = '\\', <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseTextEsc2"><b>OFParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseTextEsc"><b>OFParseTextEsc</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseTextEsc"><b>OFParseTextEsc</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFTxEoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseTextEsc"><b>OFParseTextEsc</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~OFParseTextEsc"><b>~OFParseTextEsc</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFTxEfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseTextEsc1"></a>OFParseTextEsc (const char* abort, const char* description, T&amp; objToNotify,
                <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max, unsigned int min = 1,
                char escape = '\\', bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseTextEsc2"></a>OFParseTextEsc (const OFParseTextEsc&amp; other)</pre>
    <pre><a name="~OFParseTextEsc"></a>virtual ~OFParseTextEsc ()</pre>
    <pre><a name="OFTxEoperator="></a>OFParseTextEsc&amp; operator= (const OFParseTextEsc&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFTxEfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseExact">CBParseExact</a>
      <a href="Parse.html#OMParseExact">OFParseExact&lt;T&gt;</a>
      <a href="Parse.html#ParseUpperExact">ParseUpperExact</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!)</p>

    <p>The min- and max-members are not totally wasted; they could be
      used to define the minimal length of certain keywords which would
      be valid even if just written in a short(er) form (although the
      main reason for them is that I didn't want to re-consider the
      class-hierarchy anymore).</p>

    <p><b>Note</b>: This class uses <i>strlen</i> to get the length of value
      so don't use it to check for text with a '\0' inside!</p>

    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseExact1"><b>ParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseExact2"><b>ParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseExact3"><b>ParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseExact"><b>ParseExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseExact"><b>ParseExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POExaoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseExact"><b>ParseExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseExact"><b>~ParseExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POExacheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="Parse.html#POExacheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseExact1"></a>ParseExact (const char* value, const char* description, bool skipWhitespace = true)</pre>
    <pre><a name="ParseExact2"></a>ParseExact (const char* value, const char* description, unsigned int max,
            unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>The parameters <i>min</i> and <i>max</i> could be used to define a
        minimal length of a keyword. This word would be valid if at least min
        characters would be parsed, but other (longer) versions of the word
        would also be valid.</dd>
    </dl>

    <pre><a name="ParseExact3"></a>ParseExact (const ParseExact&amp; other)</pre>
    <pre><a name="~ParseExact"></a>virtual ~ParseExact ()</pre>

    <pre><a name="POExaoperator="></a>ParseExact&amp; operator= (const ParseExact&amp; other)</pre>

    <pre><a name="POExacheckValue"></a>virtual bool checkValue (char ch)</pre>
    <dl>
      <dd>Retruns true, if the passed character is exactly equal (case-sensitive!)
        than the one in the actual position of the object; else false.</dd>
    </dl>
    <pre><a name="POExacheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade><a name="CBParseExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseExact">ParseExact</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseExact"><b>ParseExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseExact1"><b>CBParseExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#CBParseExact2"><b>CBParseExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseExact3"><b>CBParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseExact"><b>CBParseExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseExact"><b>CBParseExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBExaoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseExact"><b>CBParseExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBExasetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~CBParseExact"><b>~CBParseExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBExafound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseExact1"></a>CBParseExact (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
              bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseExact2"></a>CBParseExact (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
              unsigned int max, unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback. With the <i>min</i>- and <i>max</i>-
        parameters it is possible to parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="CBParseExact3"></a>CBParseExact (const CBParseExact&amp; other)</pre>
    <pre><a name="~CBParseExact"></a>virtual ~CBParseExact ()</pre>
    <pre><a name="CBExaoperator="></a>CBParseExact&amp; operator= (const CBParseExact&amp; other)</pre>

    <pre><a name="CBExasetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBExafound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseExact&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseExact">ParseExact</a></p>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseExact"><b>ParseExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseExact1"><b>OFParseExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>,  <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a>  <font color="blue">callback</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseExact2"><b>OFParseExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>,  <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a>  <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseExact3"><b>OFParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseExact"><b>OFParseExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseExact"><b>OFParseExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFExaoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseExact"><b>OFParseExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~OFParseExact"><b>~OFParseExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFExafound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseExact1"></a>OFParseExact (const char* value, const char* description, T&amp; objToNotify,
              <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseExact2"></a>OFParseExact (const char* value, const char* description, T&amp; objToNotify,
              <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max,
              unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback. With the <i>min</i>- and <i>max</i>-
        parameters it is possible to parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="OFParseExact3"></a>OFParseExact (const OFParseExact&amp; other)</pre>
    <pre><a name="~OFParseExact"></a>virtual ~OFParseExact ()</pre>
    <pre><a name="OFExaoperator="></a>OFParseExact&amp; operator= (const OFParseExact&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFExafound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseUpperExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseUpperExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseUpperExact">CBParseUpperExact</a>
      <a href="Parse.html#OMParseUpperExact">OFParseUpperExact&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!)</p>

    <p>The min- and max-members are not totally wasted; they could be
      used to define the minimal length of certain keywords which would
      be valid even if just written in a short(er) form (although the
      main reason for them is that I didn't want to re-consider the
      class-hierarchy anymore).</p>

    <p><b>Note</b>: This class uses <i>strlen</i> to get the length of value
      so don't use it to check for text with a '\0' inside!</p>

    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseUpperExact1"><b>ParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseUpperExact2"><b>ParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseUpperExact3"><b>ParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html"><tt><font color="navy"><b>ParseUpperExact</b></font></tt></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POUExoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseUpperExact"><b>~ParseUpperExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POUExcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="Parse.html#POUExcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseUpperExact1"></a>ParseUpperExact (const char* value, const char* description,
                 bool skipWhitespace = true)</pre>
    <pre><a name="ParseUpperExact2"></a>ParseUpperExact (const char* value, const char* description, unsigned int max,
                 unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>The parameters <i>min</i> and <i>max</i> could be used to define a
        minimal length of a keyword. This word would be valid if at least min
        characters would be parsed, but other (longer) versions of the word
        would also be valid.</dd>
    </dl>

    <pre><a name="ParseUpperExact3"></a>ParseUpperExact (const ParseUpperExact&amp; other)</pre>
    <pre><a name="~ParseUpperExact"></a>virtual ~ParseUpperExact ()</pre>

    <pre><a name="POUExoperator="></a>ParseUpperExact&amp; operator= (const ParseUpperExact&amp; other)</pre>

    <pre><a name="POUExcheckValue"></a>virtual bool checkValue (char ch)</pre>
    <dl>
      <dd>Retruns true, if the passed character is exactly equal (not
        case-sensitive!) than the one in the actual position of the object;
        else false.</dd>
    </dl>
    <pre><a name="POUExcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade><a name="CBParseUpperExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseUpperExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseUpperExact1"><b>CBParseUpperExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseUpperExact2"><b>CBParseUpperExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseUpperExact3"><b>CBParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseUpperExact"><b>CBParseUpperExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseUpperExact"><b>CBParseUpperExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBUExoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseUpperExact"><b>CBParseUpperExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBUExsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseUpperExact"><b>~CBParseUpperExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBUExfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseUpperExact1"></a>CBParseUpperExact (const char* value, const char* description,
                   <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseUpperExact2"></a>CBParseUpperExact (const char* value, const char* description,
                   <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, unsigned int max,
                   unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback. With the <i>min</i>- and <i>max</i>-
        parameters it is possible to parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="CBParseUpperExact3"></a>CBParseUpperExact (const CBParseUpperExact&amp; other)</pre>
    <pre><a name="~CBParseUpperExact"></a>virtual ~CBParseUpperExact ()</pre>
    <pre><a name="CBUExoperator="></a>CBParseUpperExact&amp; operator= (const CBParseUpperExact&amp; other)</pre>

    <pre><a name="CBUExsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBUExfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseUpperExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseUpperExact&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseUpperExact1"><b>OFParseUpperExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</a></b> <font color="blue">callback</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseUpperExact2"><b>OFParseUpperExact</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">value</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</a></b> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font>, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseUpperExact3"><b>OFParseUpperExact</b></a></td>
        <td><tt>(const <a href="Parse.html#OMParseUpperExact"><b>OFParseUpperExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseUpperExact"><b>OFParseUpperExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFUExoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(const <a href="Parse.html#CBParseUpperExact"><b>OFParseUpperExact</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~OFParseUpperExact"><b>~OFParseUpperExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt>virtual <font color="purple">int</font></tt> </td>
        <td><a href="Parse.html#OFUExfound"><b>found</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">pFoundValue</font>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseUpperExact1"></a>OFParseUpperExact (const char* value, const char* description, T&amp; objToNotify,
                   <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseUpperExact2"></a>OFParseUpperExact (const char* value, const char* description, T&amp; objToNotify,
                   <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max,
                   unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.
        With the <i>min</i>- and <i>max</i>- parameters it is possible to
        parse abbreviable keywords.</dd>
    </dl>
    <pre><a name="OFParseUpperExact3"></a>OFParseUpperExact (const OFParseUpperExact&amp; other)</pre>
    <pre><a name="~OFParseUpperExact"></a>virtual ~OFParseUpperExact ()</pre>
    <pre><a name="OFUExoperator="></a>OFParseUpperExact&amp; operator= (const OFParseUpperExact&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFUExfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseSequence"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseSequence</h1>
    <p>Derived from:
      <a href="Parse.html#ParseObject">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseSequence">CBParseSequence</a>
      <a href="Parse.html#OMParseSequence">OFParseSequence&lt;T&gt;</a>
      <a href="Parse.html#ParseSelection">ParseSelection</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects (sequences).</p>

    <p>A sequence is only considered parsed successfully, if all of
      its elements are parsed successfully (in the order specified by
      the sequence).</p>

    <p>Errors while parsing cause a <i>soft error</i> (meaning parsing
      can be continued) only for the first element; errors for further
      elements cause <i>hard errors</i> (which are not recoverable and
      parsing is ended).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSequence1"><b>ParseSequence</b></a></td>
        <td><tt>(<a href="Parse.html#ParseObject"><tt><font color="navy"><b>ParseObject</b></font></tt></a>* <tt><font color="blue">apObjectList[]</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSequence2"><b>ParseSequence</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POSeqgetMaxCard"><b>getMaxCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POSeqgetMinCard"><b>getMinCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POSeqoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POSeqsetMaxCard"><b>setMaxCard</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">val</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#POSeqsetMinCard"><b>setMinCard</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">val</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseSequence"><b>~ParseSequence</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POSeqcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POSeqdoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><font color="blue">stream</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">optional</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseSequence1"></a>ParseSequence (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
               unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>apObjectList</i> specifies the list of ParseObject
          which must be found in serie to fullfill the sequence.</p>
        <p>The parameters <i>max</i> and <i>min</i> specify the maximal and
          minimal number how often the sequence must or may be repeated.</p></dd>
    </dl>
    <pre><a name="ParseSequence2"></a>ParseSequence (const ParseSequence&amp; other)</pre>
    <pre><a name="~ParseSequence"></a>virtual ~ParseSequence ()</pre>

    <pre><a name="POSeqoperator="></a>ParseSequence&amp; operator= (const ParseSequence&amp; other)</pre>

    <h4>Accessing values</h4>
    <pre><a name="POSeqgetMaxCard"></a>unsigned int getMaxCard () const</pre>
    <dl>
      <dd>Returns the maximal number how often the sequence may be repeated.</dd>
    </dl>
    <pre><a name="POSeqsetMaxCard"></a>void setMaxCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the maximal number how often the sequence may be repeated.</dd>
    </dl>
    <pre><a name="POSeqgetMinCard"></a>unsigned int getMinCard () const</pre>
    <dl>
      <dd>Returns the minimal number how often the sequence must be repeated.</dd>
    </dl>
    <pre><a name="POSeqsetMinCard"></a>void setMinCard (unsigned int val)</pre>
    <dl>
      <dd>Changes the minimal number how often the sequence must be repeated.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="POSeqdoParse"></a>virtual int doParse (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd><p>Returns <i>PARSE_OK</i> if the the sequence has been parsed
          successfully (all objects found and the minimal cardinality of the
          sequence is fullfilled (this is also true, if a soft error (&gt; 0)
          occurs while parsing the first element of the sequence).</p>
        <p>If there is a soft error parsing the first element of the sequence
          before the mininmal cardinality is fullfilled or with any other
          element of the sequence, <i>PARSE_ERROR</i> is returned; hard errors
          causes an exception to be thrown.</p></dd>
    </dl>

    <h4>Status-handling</h4>
    <pre><a name="POSeqcheckIntegrity"></a>virtual int checkIntegrity () const</pre>
    <dl>
      <dd>Checks if this object is in a valid state.</dd>
    </dl>

    <hr noshade><a name="CBParseSequence"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseSequence</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects with a callback to report matching
      input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSequence1"><b>CBParseSequence</b></a></td>
        <td><tt>(<a href="ParseObject.html"><tt><font color="navy"><b>ParseObject</b></font></tt></a>* <tt><font color="blue">apObjectList[]</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><font color="blue">callback</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSequence2"><b>CBParseSequence</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSequence"><b>CBParseSequence</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseSequence"><b>CBParseSequence</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBSeqoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSequence"><b>CBParseSequence</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBSeqsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><font color="blue">callback</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseSequence"><b>~CBParseSequence</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBSeqfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseSequence1"></a>CBParseSequence (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
                 <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, unsigned int max = 1,
                 unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseSequence2"></a>CBParseSequence (const CBParseSequence&amp; other)</pre>
    <pre><a name="~CBParseSequence"></a>virtual ~CBParseSequence ()</pre>
    <pre><a name="CBSeqoperator="></a>CBParseSequence&amp; operator= (const CBParseSequence&amp; other)</pre>

    <pre><a name="CBSeqsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBSeqfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseSequence"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseSequence&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects with a callback to report matching
      input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSequence1"><b>OFParseSequence</b></a></td>
        <td><tt>(<a href="ParseObject.html"><tt><font color="navy"><b>ParseObject</b></font></tt></a>* <tt><font color="blue">apObjectList[]</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</a></b> <font color="blue">callback</font>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSequence2"><b>OFParseSequence</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSequence"><b>OFParseSequence</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseSequence"><b>OFParseSequence</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFSeqoperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSequence"><b>OFParseSequence</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseSequence"><b>~OFParseSequence</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFSeqfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseSequence1"></a>OFParseSequence (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
                 T&amp; objToNotify, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max = 1,
                 unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseSequence2"></a>OFParseSequence (const OFParseSequence&amp; other)</pre>
    <pre><a name="~OFParseSequence"></a>virtual ~OFParseSequence ()</pre>
    <pre><a name="OFSeqoperator="></a>OFParseSequence&amp; operator= (const OFParseSequence&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFSeqfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>

    <hr noshade><a name="ParseSelection"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseSelection</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseSelection">CBParseSelection</a>
      <a href="Parse.html#OMParseSelection">OFParseSelection&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObject out of a list.</p>

    <p>If an object matching the parsed intput is found, the sequence
      is considered as parsed successfully.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSelection1"><b>ParseSelection</b></a></td>
        <td><tt>(<a href="ParseObject.html"><tt><font color="navy"><b>ParseObject</b></font></tt></a>* <tt><font color="blue">apObjectList[]</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSelection2"><b>ParseSelection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POSeloperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseSelection"><b>~ParseSelection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#POSeldoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><font color="blue">stream</font></tt>, <tt><font color="purple">bool</font></tt> <tt><font color="blue">optional</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="ParseSelection1"></a>ParseSelection (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
                unsigned int max = 1, unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p>
        <p>The parameter <i>apObjectList</i> specifies the list of ParseObject
          where one must be found to fullfill the selection.</p>
        <p>The parameters <i>max</i> and <i>min</i> specify the maximal and
          minimal number how often the selection must or may be repeated.</p></dd>
    </dl>
    <pre><a name="ParseSelection2"></a>ParseSelection (const ParseSelection&amp; other)</pre>
    <pre><a name="~ParseSelection"></a>virtual ~ParseSelection ()</pre>

    <pre><a name="POSeloperator="></a>ParseSelection&amp; operator= (const ParseSelection&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="POSeldoParse"></a>virtual int doParse (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd><p>Returns <i>PARSE_OK</i> if the the selection has been parsed
          successfully (one objects found and the minimal cardinality of the
          selection is fullfilled.</p>
        <p>If no element of the sequence matches the parsed input or the minimal
          cardinality is not fullfilled, <i>PARSE_ERROR</i> is returned.</p>
        <p>If an object of the selection returns a hard error (&lt; 0) while
          or any error occured for a selection which is not optional, an
          exception is thrown.</p></dd>
    </dl>

    <hr noshade><a name="CBParseSelection"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseSelection</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSelection">ParseSelection</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list  with a
      callback to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSelection1"><b>CBParseSelection</b></a></td>
        <td><tt>(<a href="ParseObject.html"><font color="navy"><b>ParseObject</b></font></a>* <font color="blue">apObjectList[]</font>, const <font color="purple">char</font>* <font color="blue">description</font>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <font color="blue">callback</font>, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">max</font> = 1, <font color="navy">unsigned</font> <font color="purple">int</font> <font color="blue">min</font> = 1, <font color="purple">bool</font> <font color="blue">skipWhitespace</font> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSelection2"><b>CBParseSelection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSelection"><b>CBParseSelection</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseSelection"><b>CBParseSelection</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBSeloperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSelection"><b>CBParseSelection</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="Parse.html#CBSelsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><font color="blue">callback</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseSelection"><b>~CBParseSelection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#CBSelfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="CBParseSelection1"></a>CBParseSelection (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
                  <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, unsigned int max = 1,
                  unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the callback.</dd>
    </dl>
    <pre><a name="CBParseSelection2"></a>CBParseSelection (const CBParseSelection&amp; other)</pre>
    <pre><a name="~CBParseSelection"></a>virtual ~CBParseSelection ()</pre>
    <pre><a name="CBSeloperator="></a>CBParseSelection&amp; operator= (const CBParseSelection&amp; other)</pre>

    <pre><a name="CBSelsetCallback"></a>void setCallback (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="CBSelfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback with the passed parameter and returns its
        result.</dd>
    </dl>

    <hr noshade><a name="OMParseSelection"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseSelection&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSelection">ParseSelection</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list  with a
      callback to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSelection1"><b>OFParseSelection</b></a></td>
        <td><tt>(<a href="ParseObject.html"><tt><font color="navy"><b>ParseObject</b></font></tt></a>* <tt><font color="blue">apObjectList[]</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">description</font></tt>, <font color="navy">T</font>&amp; <font color="blue">objToNotify</font>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</a></b> <font color="blue">callback</font>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">max</font></tt> = 1, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">min</font></tt> = 1, <tt><font color="purple">bool</font></tt> <tt><font color="blue">skipWhitespace</font></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSelection2"><b>OFParseSelection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSelection"><b>OFParseSelection</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseSelection"><b>OFParseSelection</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFSeloperator="><tt><font color="black"><b>operator</b></font>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSelection"><b>OFParseSelection</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseSelection"><b>~OFParseSelection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="Parse.html#OFSelfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pFoundValue</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="OFParseSelection1"></a>OFParseSelection (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
                 T&amp; objToNotify, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max = 1,
                 unsigned int min = 1, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor setting the object to notify and its callback-method.</dd>
    </dl>
    <pre><a name="OFParseSelection2"></a>OFParseSelection (const OFParseSelection&amp; other)</pre>
    <pre><a name="~OFParseSelection"></a>virtual ~OFParseSelection ()</pre>
    <pre><a name="OFSeloperator="></a>OFParseSelection&amp; operator= (const OFParseSelection&amp; other)</pre>

    <h4>Parsing</h4>
    <pre><a name="OFSelfound"></a>virtual int found (const char* pFoundValue)</pre>
    <dl>
      <dd>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</dd>
    </dl>
  </body>
</html>
