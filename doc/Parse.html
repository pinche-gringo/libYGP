<!-- -*-HTML-*- -->
<!-- $Id: Parse.html,v 1.20 2003/02/14 20:37:31 markus Exp $ -->

<html>
  <head>
    <title>General Reference: Parser</title>
    <meta name="description" content="Documentation of general parser">
    <meta name="keywords" content="Documentation, Docu, Parser, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center"><a name="General"></a>General parser-information</h1>
    <p>Classes to parse objects and sequences of objects from a stream. If an
      object is found it is possible to perform an action.</p>

    <p>There are 3 kind of parsing objects: Attomic ones, which enables the
      parsing of some kind of data; special ones, to perform special tasks
      and sequences to &quot;glue&quot; together a set of objects.</p>

    <p>The following attomic objects exists:
    <dl>
      <dt><a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a></dt>
      <dd>Parses a specified number of specified characters.</dd>
      <dt><a href="Parse.html#ParseText"><b>ParseText</b></a></dt>
      <dd>Parses a specified number of characters until one of specified
        characters is found.</dd>
      <dt><a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a></dt>
      <dd>As ParseText, but this terminating characters can be escaped.</dd>
      <dt><a href="Parse.html#ParseExact"><b>ParseExact</b></a></dt>
      <dd>Parses (a part) of the specified characters in that sequence.</dd>
      <dt><a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a></dt>
      <dd>As ParseExact, but ignores the case.</dd>
    </dl>

    <p>The following special objects exists:
    <dl>
      <dt><a href="Parse.html#ParseEOF"><b>ParseEOF</b></a></dt>
      <dd>&quot;Parses&quot; or matches the end of the file.</dd>
      <dt><a href="Parse.html#ParseSkip"><b>ParseSkip</b></a></dt>
      <dd>Skips the specified number of characters (from the current position).</dd>
    </dl>

    <p>The following sequences exists:
    <dl>
      <dt><a href="Parse.html#ParseSequence"><b>ParseSequence</b></a></dt>
      <dd>All of its children must be found in that order.</dd>
      <dt><a href="Parse.html#ParseSelection"><b>ParseSelection</b></a></dt>
      <dd>One of its children must be found; stopps parsing if one matches.</dd>
    </dl>

    <p>All of these classes exists in 3 variants:</p>
    <ul>
      <li>The first variant reports matching objects with a virtual
        function called <code>found</code>. These classes have the prefix
        <code>Parse</code>.</li>
      <li>The second calls a C-style function if an object was found and has
        therefore a function-pointer as parameter of the constructor(s). These
        classes have a prefix of <code>CBParse</code>. The callbacks have the type
        <code><a name="PARSECALLBACK"></a>PARSECALLBACK</code> which are pointer to
        functions with a const char*-paramter returning an integer.</li>
      <li>The third calls a C++-style function if an object was found and has
        therefore an object and a pointer to a memberfunction as parameter of
        he constructor(s). These classes starts with <code>OFParse</code>. The object
        can be of any type; the callback a <a name="PTCALLBACK"></a><code>T::*PTCALLBACK</code>
        which is a object-member expecting an const char*-paramter and returning
        an integer.</li>
    </ul>

    <p>Any of this functions must return the following values (which specifies
      how the parsing should be continued):</p>
    <dl compact>
      <dt><b>0</b></dt>
      <dd>Parsing (actually callback) OK</dd>
      <dt><b>&gt; 0</b></dt>
      <dd>Error in callback; parsing can be continued (in sequences, ...)</dd>
      <dt><b>&lt; 0</b></dt>
      <dd>Error in callback; abort parsing (unrecoverable error)</dd>
    </dl>

    <p>If possible use the error-values (<code>PARSE_OK</code> (0),
      <code>PARSE_ERROR</code> (1), <code>PARSE_CB_ERROR</code> (2),
      <code>PARSE_CB_ABORT</code> (-1)) in the error-enum of
        <a href="Parse.html#ParseObject">ParseObject</a>.</p>

    <p>The parser is re-entrant and thread-safe; meaning objects can be parsed
      simultanously in different processes and/or threads.</p>

    <p>To free memory, the static member
      <a href="Parse.html#POfreeBuffer">ParseObject::freeBuffer</a> can
      be called (but better not while an object is parsed).</p>

    <hr noshade><a name="ParseObject"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseObject</h1>
    <p>Derived from
      <i>none</i>
      <br>
      Derived by:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <a href="Parse.html#ParseEOF">ParseEOF</a>
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <a href="Parse.html#ParseSkip">ParseSkip</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <h2>Description</h2>
    <p>Abstract base-class for parsing objects. It contains methods of general
      purpose.</p>

    <p><b>Note</b>: The passed const char*-parameters are only stored and not
      copied, so ensure that they are valid during the lifetime of each
      parse-object!</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseObject1"><b>ParseObject</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseObject2"><b>ParseObject</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseObject"><b>ParseObject</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POdoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><span style="color:blue">stream</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">optional</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">pFoundValue</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">length</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POfreeBuffer"><b>freeBuffer</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <tt><span style="color:purple">char</span></tt>*</tt> </td>
        <td><a href="Parse.html#POgetDescription"><b>getDescription</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseObject"><b>ParseObject</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POoperator="><tt><span style="color:black"><b>operator=</b></span></tt><tt></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseObject"><b>ParseObject</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POparse"><b>parse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistram"><b>Xistream</b></a>&amp; <tt><span style="color:blue">stream</span></tt>) throw (<span style="color:purple">std::string</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POsetDescription"><b>setDescription</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">desc</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POsetSkipWS"><b>setSkipWS</b></a></td>
        <td><tt>(<tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POskipWS"><b>skipWS</b></a></td>
        <td><tt>(<a href="XStream.html#Xistram"><b>Xistream</b></a>&amp; <tt><span style="color:blue">stream</span></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseObject"><b>~ParseObject</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>
    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseObject1"></a> <b>ParseObject</b> (const char* description, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor</p>
        <p>The description must be valid during the lifetime (or at least the usage)
          of the object!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>description</code>: Description of the object (what it parses)</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped after sucessfully parsing the object</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>description</code> valid ASCIIZ string != NULL</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseObject2"></a> <b>ParseObject</b> (const ParseObject&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseObject"></a> <b>~ParseObject</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POoperator="></a>ParseObject&amp; <b>operator=</b> (const ParseObject&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ParseObject&amp;: Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POfreeBuffer"></a>void <b>freeBuffer</b> ()</pre>
    <dl>
      <dd><p>Frees the buffer which is used to store the parsed data. Use with
          care (only at the end of parsing and not during parsing a single
          object).</p></dd>
    </dl>

    <h3 style="color:navy">Accessing values</h3>
    <pre><a name="POgetDescription"></a>const char* <b>getDescription</b> () const</pre>
    <dl>
      <dd><p>Retrieves the pointer to the description specified to this object.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>const char*: Pointer to description</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POsetDescription"></a>void <b>setDescription</b> (const char* desc)</pre>
    <dl>
      <dd><p>Changes the description of the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>desc</code>: New description of the object (what is parsed)</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="POsetSkipWS"></a>void <b>setSkipWS</b> (bool skipWhitespace)</pre>
    <dl>
      <dd><p>Sets the flag if whitespaces should be skipped <b>after</b> sucessfully
        parsing data matching the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped after sucessfully parsing the object</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="POskipWS"></a>void <b>skipWS</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) const</pre>
    <dl>
      <dd><p>Skips all whitespace characters (blank, tabulator, carriage return
        and line feed) from the current position in the passed stream.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Source from which to read</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="POparse"></a>int <b>parse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd><p>Tries to parse data matching the information stored with this
        parse-object from the passed stream. If this parsing is successful (the
        parsed data matches) this function returns <code>PARSE_OK</code>; else a
        non-zero value. Errors bigger than 0 are <b>soft errors</b> and the
        parsing can be continued, errors less than 0 are <b>hard errors</b> and
        the parsing is stopped.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Source from which to read</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status of parsing</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: Message describing the problem in case of a hard error (containing read and expected data)</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POdoParse"></a>int <b>doParse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool optional)</pre>
    <dl>
      <dd><p>Pure virtual method defining the interface for the actual
        parse-method for the different parse-objects; to be implemented by the
        derived classes.</p>

        <p>Attomic and special parse objects should return <code>PARSE_OK</code>,
          <code>PARSE_ERROR</code> or the value returned by their found-method to indicate
          their success and sequences should handle them approbiately.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Source from which to read</dd>
          <dd><code>optional</code>: Flag, if parsing this object is optionaland therefore may fail)</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status of parsing</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int)</pre>
    <dl>
      <dd><p>Callback to notify that an object has found itself during
        parsing. Callback can report its status with the return codes
        <code>PARSE_OK</code> or 0, <code>PARSE_CB_ERROR</code> or any other number
        bigger than 0 for <b>soft errors</b> and <code>PARSE_CB_ABORT</code> or any
        number below 0 for <b>hard errors</b>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd>Unused: Length of found value</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Status-handling</h3>
    <pre><a name="POcheckIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks if this object is in a valid state.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseEOF"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseEOF</h1>
    <p>Derived from
      <a href="Parse.html#ParseObject">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseEOF">CBParseEOF</a>
      <a href="Parse.html#OMParseEOF">OFParseEOF&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseEOF"><b>ParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POEOFdoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><span style="color:blue">stream</span></tt>, <tt><span style="color:purple">bool</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseEOF"><b>~ParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseEOF1"></a><b>ParseEOF</b> ()</pre>
    <dl>
      <dd><p>Defaultconstructor</p></dd>
    </dl>
    <hr>
    <pre><a name="~ParseEOF"></a> <b>~ParseEOF</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <h3 style="color:navy">Parsing</h3>
    <pre><a name="POEOFdoParse"></a>int <b>doParse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool)</pre>
    <dl>
      <dd><p>Checks for end-of-file in the passed stream and returns the appropiate value.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: <code>PARSE_OK</code> if at end-of-file; else <code>PARSE_ERROR</code></dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseEOF"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseEOF</h1>
    <p>Derived from
      <a href="Parse.html#ParseEOF">ParseEOF</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseEOF"><b>CBParseEOF</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBEOFsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseEOF"><b>~CBParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBEOFfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">pFoundValue</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">length</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>
    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseEOF1"></a><b>CBParseEOF</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback)</pre>
    <dl>
      <dd>Constructor setting the callback to report success of parsing.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>
    <pre><a name="~CBParseEOF"></a> <b>~CBParseEOF</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBEOFsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>


    <h3 style="color:navy">Parsing</h3>

    <pre><a name="CBEOFfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameters and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>pFoundValue != NULL, len == 0</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseEOF"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseEOF&lt;T&gt;</h1>
    <p>Derived from
      <a href="Parse.html#ParseEOF">ParseEOF</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse the end of a file (EOF) with a callback to report
      matching input.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseEOF"><b>OFParseEOF</b></a></td>
        <td><tt>(<tt><span style="color:navy">T</span>&amp;</tt> <tt><span style="color:blue">objToNotify</span></tt>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseEOF"><b>~OFParseEOF</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFEOFfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">pFoundValue</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">length</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseEOF1"></a><b>OFParseEOF</b> (T&amp; objToNotify, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback)</pre>
    <dl>
      <dd><p>Constructor setting the object to notify and its callback-method.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>objToNotify</code>: Object to report success</dd>
          <dd><code>callback</code>: Pointer to member to inform about successfull parsing</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseEOF"></a><b>~OFParseEOF</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFEOFfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd>Calls the defined callback with the passed
        parameter and returns its result.</dd>
      <dd><p>Calls the defined callback of the specified object with the passed 
        parameters and returns its result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>pFoundValue != NULL, len == 0</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseSkip"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseSkip</h1>
    <p>Derived from
      <a href="ParseObject.html">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseSkip">CBParseSkip</a>
      <a href="Parse.html#OMParseSkip">OFParseSkip&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to skip some characters (from the current position in the stream).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSkip1"><b>ParseSkip</b></a></td>
        <td><tt>(<tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">bytes</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSkip2"><b>ParseSkip</b></a></td>
        <td><tt>(<tt>const</tt> <a href="ParseSkip.html#ParseSkip"><b>ParseSkip</b></a>&amp; <tt><span style="color:blue;">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple;">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSkipdoParse"><b>doParse</b></a></td>
        <td><tt>(<tt><a href="XStream.html#Xistream"><b>Xistream</b></a></tt>&amp; <tt><span style="color:blue;">stream</span></tt>, <tt><span style="color:purple;">bool</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSkipgetOffset"><b>getOffset</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ParseSkip.html#ParseSkip"><b>ParseSkip</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POSkipoperator="><tt><span style="color:black;"><b>operator=</b></span></tt><tt> </tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ParseSkip.html#ParseSkip"><b>ParseSkip</b></a>&amp; <tt><span style="color:blue;">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple;">void</span></tt></tt> </td>
        <td><a href="Parse.html#POSkipsetOffset"><b>setOffset</b></a></td>
        <td><tt>(<tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">val</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseSkip"><b>~ParseSkip</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
    </table>
    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseSkip1"></a><b>ParseSkip</b> (unsigned int bytes)</pre>
    <dl>
      <dd><p>Defaultconstructor; Creates the object with the number of bytes to
        skip, each time this object is parsed.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>bytes</code>: Number of bytes to skip from current position</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseSkip2"></a> <b>ParseSkip</b> (const ParseSkip&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseSkip"></a> <b>~ParseSkip</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POSkipoperator="></a>ParseSkip&amp; <b>operator=</b> (const ParseSkip&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ParseSkip&amp;: Reference to this</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="POSkipgetOffset"></a>unsigned int <b>getOffset</b> () const</pre>
    <dl>
      <dd><p>Returns the offset which should be skipped, each time the object is parsed.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned int: Offset to skip</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POSkipsetOffset"></a>void <b>setOffset</b> (unsigned int bytes) const</pre>
    <dl>
      <dd><p>Sets the offset which should be skipped, each time the object is parsed.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>bytes</code>: Number of bytes to skip from current position</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="POSkipdoParse"></a>int <b>doParse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool)</pre>
    <dl>
      <dd><p>Checks for end-of-file in the passed stream and returns the appropiate value.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: <code>PARSE_OK</code> if at end-of-file; else <code>PARSE_ERROR</code></dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseSkip"></a>

    <table align=center border=0 cellspacing=10>
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseSkip</h1>
    <p>Derived from
      <a href="ParseSkip.html">ParseSkip</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to skip some characters (from the current position in the stream)
      with a callback to inform about the event.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSkip1"><b>CBParseSkip</b></a></td>
        <td><tt>(<tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">bytes</span></tt>, <tt><span style="color:navy;">PARSECALLBACK</span></tt> <tt><span style="color:blue;">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSkip2"><b>CBParseSkip</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSkip"><b>CBParseSkip</b></a>&amp; <tt><span style="color:blue;">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseSkip"><b>CBParseSkip</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBSkipoperator="><tt><span style="color:black;"><b>operator=</b></span></tt><tt> </tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSkip"><b>CBParseSkip</b></a>&amp;)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple;">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBSkipsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<tt><span style="color:navy;">PARSECALLBACK</span></tt> <tt><span style="color:blue;">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseSkip"><b>~CBParseSkip</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple;">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBSkipfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
    </table>
    <hr noshade>
    <h2>Member descriptions</h2>
    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseSkip1"></a><b>CBParseSkip</b> (unsigned int bytes, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback)</pre>
    <dl>
      <dd>Constructor setting the callback to report success of parsing.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>bytes</code>: Number of bytes to skip from current position</dd>
          <dd><code>callback</code>: Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>
    <pre><a name="CBParseSkip2"></a> <b>CBParseSkip</b> (const CBParseSkip&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseSkip"></a> <b>~CBParseSkip</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBSkipoperator="></a>CBParseSkip&amp; <b>operator=</b> (const CBParseSkip&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ParseSkip&amp;: Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBSkipsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>

    <pre><a name="CBSkipfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameters and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>pFoundValue != NULL, len == 0</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseSkip"></a>

    <table align=center border=0 cellspacing=10>
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td>
      <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseSkip&lt;T&gt;</h1>
    <p>Derived from
      <a href="ParseSkip.html">ParseSkip</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to skip some characters (from the current position in the stream)
      with a callback to inform about the event.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSkip1"><b>OFParseSkip</b></a></td>
        <td><tt>(<tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">bytes</span></tt>, <tt><span style="color:navy;">PARSECALLBACK</span></tt> <tt><span style="color:blue;">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSkip2"><b>OFParseSkip</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseSkip"><b>OFParseSkip</b></a>&amp; <tt><span style="color:blue;">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OFParseSkip"><b>OFParseSkip</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFSkipoperator="><tt><span style="color:black;"><b>operator=</b></span></tt><tt> </tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseSkip"><b>OFParseSkip</b></a>&amp;)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseSkip"><b>~OFParseSkip</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple;">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFSkipfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
    </table>
    <hr noshade>
    <h2>Member descriptions</h2>
    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseSkip1"></a><b>OFParseSkip</b> (unsigned int bytes, T&amp; objToNotify, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback)</pre>
    <dl>
      <dd>Constructor setting the callback to report success of parsing.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>bytes</code>: Number of bytes to skip from current position</dd>
          <dd><code>T</code>: Object to notify</dd>
          <dd><code>callback</code>: Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>
    <pre><a name="OFParseSkip2"></a> <b>OFParseSkip</b> (const OFParseSkip&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseSkip"></a> <b>~OFParseSkip</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFSkipoperator="></a>OFParseSkip&amp; <b>operator=</b> (const OFParseSkip&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator; copies the values stored in <code>other</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ParseSkip&amp;: Reference to this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>

    <pre><a name="OFSkipfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameters and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>pFoundValue != NULL, len == 0</dd></dl></dd>
    </dl>


    <hr noshade><a name="ParseAttomic"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseAttomic</h1>
    <p>Derived from:
      <a href="Parse.html#ParseObject">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseAttomic">CBParseAttomic</a>
      <a href="Parse.html#OMParseAttomic">OFParseAttomic&lt;T&gt;</a>
      <a href="Parse.html#ParseExact">ParseExact</a>
      <a href="Parse.html#ParseText">ParseText</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse an attomic value; Base-class of all attomic values.</p>

    <p>The member <i>pValue</i> has the following semantic: A parsed character
      is valid if it occures in the pValue-list, where the backslash (\)
      escapes the next charater to the following meaning:</p>

    <ul>
      <li><b>A</b> ... Any alphabethic character is valid</li>
      <li><b>X</b> ... Any alphanumeric character is valid</li>
      <li><b>9</b> ... Any number is valid</li>
      <li><b>0</b> ... The zero-character (\0) is valid</li>
      <li><b>n</b> ... The line-feed-character (\n) is valid</li>
      <li><b>r</b> ... The carriage-return-character (\r) is valid</li>
      <li><b>\</b> ... The backslash itself is valid</li>
      <li><b>blank ( )</b> ... Any whitespace is valid</li>
      <li><b>*</b> ... Any character is valid</li>
    </ul>

    <p>The members <code>maxCard</code> and <code>minCard</code> specify how many characters
      the object can or must have. If there are less matching characters parsed,
      the object is considered as not found; after reaching the upper border,
      parsing is stopped (for this object).</p>

    <p><code>skipWhitespace</code> does exactly that, after an object was parsed
      successfully.</p>

    <p>The parameter <code>reportData</code> specifies, if the parsed data should be
      stored and reported via the found-method. Setting to false disables also
      putting back previously parsed data, so only do that, if parsing always succeeds
      and you don't care about the parsed contents!</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseAttomic1"><b>ParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseAttomic2"><b>ParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POAttgetMaxCard"><b>getMaxCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POAttgetMinCard"><b>getMinCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <tt><span style="color:purple">char</span></tt>*</tt> </td>
        <td><a href="Parse.html#POAttgetValue"><b>getValue</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POAttoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POAttsetMaxCard"><b>setMaxCard</b></a></td>
        <td><tt>(<tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">val</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POAttsetMinCard"><b>setMinCard</b></a></td>
        <td><tt>(<tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">val</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POAttsetValue"><b>setValue</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseAttomic"><b>~ParseAttomic</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POAttcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">bool</span></tt></tt> </td>
        <td><a href="Parse.html#POAttcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">ch</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual <span style="color:purple">int</span></tt></td>
        <td><a href="Parse.html#POAttdoParse"><b>doParse</b></a></td>
        <td>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <span style="color:blue">stream</span>,
	  <span style="color:purple">bool</span> <span style="color:blue">optional</span>) throw (<span style="color:purple">std::string</span>)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>
    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseAttomic1"></a> <b>ParseAttomic</b> (const char* value, const char* description, unsigned int max,
               unsigned int min, bool skipWhitespace, bool reportData)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: List of valid characters (see class description)</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag if parsed data should be stored and reported via the virtual found method</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseAttomic1"></a> <b>ParseAttomic</b> (const ParseAttomic&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseAttomic2"></a> <b>~ParseAttomic</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POAttoperator="></a>ParseAttomic&amp; <b>operator=</b> (const ParseAttomic&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Accessing values</h3>
    <pre><a name="POAttgetValue"></a>const char* <b>getValue</b> () const</pre>
    <dl>
      <dd><p>Returns a pointer to the stored valid characters.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>const char*: Pointer to array of the valid characters.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POAttsetValue"></a><b>setValue</b> (const char* value)</pre>
    <dl>
      <dd><p>Changes the valid characters. This parameter must be valid (not
        freed) for the whole lifetime (usage) of the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Pointer to array of valid characters (zero-terminated)</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="POAttgetMaxCard"></a>unsigned int <b>getMaxCard</b> () const</pre>
    <dl>
      <dd><p>Returns the maximal number of characters this object may match while
        parsing.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned int: Maximal number the object can be parsed.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POAttsetMaxCard"></a>void <b>setMaxCard</b> (unsigned int val)</pre>
    <dl>
      <dd><p>Changes the maximal number of characters this object may match while
        parsing.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>val</code>: New maximal number the object can be parsed.</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="POAttgetMinCard"></a>unsigned int <b>getMinCard</b> () const</pre>
    <dl>
      <dd><p>Returns the minimal number of characters this object must match while
        parsing.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned int: Minimal number the object must be parsed.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POAttsetMinCard"></a>void <b>setMinCard</b> (unsigned int val)</pre>
    <dl>
      <dd><p>Changes the minimal number of characters this object must match while
        parsing.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>val</code>: New minimal number the object must be parsed.</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="POAttdoParse"></a>int <b>doParse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool optional) throw (std::string)</pre>
    <dl>
      <dd><p>Tries to parse the object from the stream, as long as checkValue reports
         the input as valid (or as to ignore, by returning -1). Returns <code>PARSE_OK</code> if data matching the object is found (and
          the callback does not report something different).</p>
        <p>It is a soft error (<code>PARSE_ERROR</code>) if the minimal cardinality is
          not fullfilled.</p>
        <p>If parsing is optional or the error is recoverable (&gt; 0), the
          parsed data is pushed back into the stream and <code>PARSE_ERROR</code> is
          returned.</p>
        <p>If parsing is not optional and the error is not recoverable (&lt; 0),
          an exception (std::string) is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Source from which to read</dd>
          <dd><code>optional</code>: Flag, if node must be found</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: In case of a not recoverable error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POAttcheckValue"></a>int <b>checkValue</b> (char ch)</pre>
    <dl>
      <dd><p>Checks if the passed character is valid according to pValue. Valid are every characters specified in pValue. If pValue contains
        a backslash (\) the next character has a special meaning:</p>
        <ul>
          <li><b>9</b>: ch is valid if it is a digit</li>
          <li><b>A</b>: ch is valid if it is alphabetic</li>
          <li><b>X</b>: ch is valid if it is alphanumeric</li>
          <li><b>' ' (blank)</b>: ch is valid if it is a white-space</li>
          <li><b>0</b>: ch is valid if it is the zero-character (\0)</li>
          <li><b>\</b>: ch is valid if it is the back-slash (\)</li>
          <li><b>r</b>: ch is valid if it is carriage-return (\r)</li>
          <li><b>n</b>: ch is valid if it is line-feed (\n)</li>
          <li><b>*</b>: ch is valid.</li>
          <li> Else: ch is valid if it equal to this char</li></ul></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>ch</code>: Character to check for validity</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Result; 1 if <code>ch</code> valid, -1 if it should be just ignored. Else 0</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Status-handling</h3>
    <pre><a name="POAttcheckIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks if this object is in a valid state.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseAttomic"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseAttomic</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse attomic values with a callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseAttomic1"><b>CBParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseAttomic2"><b>CBParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseAttomic"><b>CBParseAttomic</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseAttomic"><b>CBParseAttomic</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBAttoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseAttomic"><b>CBParseAttomic</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBAttsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseAttomic"><b>~CBParseAttomic</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBAttfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseAttomic1"></a><b>CBParseAttomic</b> (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
                unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: List of valid characters (see class description)</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseAttomic2"></a><b>CBParseAttomic</b> (const CBParseAttomic&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseAttomic"></a> <b>~CBParseAttomic</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBAttoperator="></a>CBParseAttomic&amp; <b>operator=</b> (const CBParseAttomic&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="CBAttsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="CBAttrfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center"><a name="OMParseAttomic"></a>Class OFParseAttomic&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse attomic values with a callback to report matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseAttomic"><b>ParseAttomic</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td></td>
        <td><a href="Parse.html#OFParseAttomic1"><b>OFParseAttomic</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span> = 1, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span> = 1, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseAttomic2"><b>OFParseAttomic</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseAttomic"><b>OFParseAttomic</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OFParseAttomic"><b>OFParseAttomic</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFAttoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseAttomic"><b>OFParseAttomic</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseAttomic"><b>~OFParseAttomic</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFAttfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseAttomic1"></a><b>OFParseAttomic</b> (const char* value, const char* description, T&amp; objToNotify,
                <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max,
                unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: List of valid characters (see class description)</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseAttomic2"></a><b>OFParseAttomic</b> (const OFParseAttomic&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseAttomic"></a><b>~OFParseAttomic</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFAttoperator="></a>OFParseAttomic&amp; <b>operator=</b> (const OFParseAttomic&amp; other)</pre>
    <dl>
      <dd><p>Assignment operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
      </dl></dd>
    </dl>
    <hr>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFAttfound"></a>int <b>found</b> (const char* pFoundValue)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseText"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseText</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseText">CBParseText</a>
      <a href="Parse.html#OMParseText">OFParseText&lt;T&gt;</a>
      <a href="Parse.html#ParseTextEsc">ParseTextEsc</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.</p>

    <p>Parsing of this element is stopped, if any of the characters in the
      abort-parameters is found (or the maximal cardinality is reached).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseText1"><b>ParseText</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">abort</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseText2"><b>ParseText</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseText"><b>ParseText</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseText"><b>ParseText</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POTxtoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseText"><b>ParseText</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseText"><b>~ParseText</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">bool</span></tt></tt> </td>
        <td><a href="Parse.html#POTxtcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">ch</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseText1"></a><b>ParseText</b> (const char* abort, const char* description, unsigned int max,
           unsigned int min, bool skipWhitespace, bool reportData)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>abort</code>: Characters ending parsing of the object.</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag if parsed data should be stored and reported via the virtual found method</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseText2"></a><b>ParseText</b> (const ParseText&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseText"></a> <b>~ParseText</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POTxtoperator="></a>ParseText&amp; <b>operator=</b> (const ParseText&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="checkValue"></a>int <b>checkValue</b> (char ch)</pre>
    <dl>
      <dd><p>Checks if the parsed value is according the abort-list of the object.</p>
        <p>Valid are every characters <b>not</b> in <code>pValue</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>ch</code>: Char to check</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>boolean: Result; true if <code>ch</code> does not match any of those values.</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseText"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseText</h1>
    <p>Derived from:
      <a href="Parse.html#ParseText">ParseText</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseText"><b>ParseText</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseText1"><b>CBParseText</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">abort</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span> = 1, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseText2"><b>CBParseText</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseText"><b>CBParseText</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseText"><b>CBParseText</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBTxtoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseText"><b>CBParseText</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBTxtsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseText"><b>~CBParseText</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBTxtfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseText1"></a><b>CBParseText</b> (const char* abort, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
             unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>abort</code>: Characters ending parsing of the object.</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseText2"></a><b>CBParseText</b> (const CBParseText&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseText"></a> <b>~CBParseText</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBTxtoperator="></a>CBParseText&amp; <b>operator=</b> (const CBParseText&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBTxtsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="CBTxtfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseText"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseText&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseText">ParseText</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>
    <p>See the documentation of <a href="Parse.html#ParseText">ParseText</a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td></td>
        <td><a href="Parse.html#OFParseText1"><b>OFParseText</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">abort</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span> = 1, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseText2"><b>OFParseText</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseText"><b>OFParseText</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OFParseText"><b>OFParseText</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFTxtoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseText"><b>OFParseText</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseText"><b>~OFParseText</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFTxtfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseText1"></a><b>OFParseText</b> (const char* abort, const char* description, T&amp; objToNotify,
             <a href="Parse.html#PTCALLBACK">PTCALLBACK</a> callback, unsigned int max,
             unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>abort</code>: Characters ending parsing of the object.</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseText2"></a><b>OFParseText</b> (const OFParseText&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseText"></a><b>~OFParseText</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFTxtoperator="></a>OFParseText&amp; <b>operator=</b> (const OFParseText&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFTxtfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseTextEsc"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseTextEsc</h1>
    <p>Derived from:
      <a href="Parse.html#ParseText">ParseText</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseTextEsc">CBParseTextEsc</a>
      <a href="Parse.html#OMParseTextEsc">OFParseTextEsc&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a text-value until specified abort-characters are found.
      However, parsing is continued if those characters are preceeded by a
      escape-character (which "escapes" the special meaning of that character).</p>

    <p>Parsing of this element is stopped, if the maximal cardinality is
      reached or any of the characters in the abort-parameters is found which
      is not succeeded by a certain (defined) character.</p>

    <p>This class enables parsing analogue to strings in C. A C-string is
      terminated with a quote (&quot;), except if the quote follows a single backslash
      (\). The only difference is that both quote and backslash can be specified and
      therefor be every charcter.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseTextEsc1"><b>ParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">abort</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">escape</span></tt> = '\\', <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseTextEsc2"><b>ParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POTxEoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseTextEsc"><b>~ParseTextEsc</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">bool</span></tt></tt> </td>
        <td><a href="Parse.html#POTxEcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">ch</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>
    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseTextEsc1"></a> <b>ParseTextEsc</b> (const char* abort, const char* description, unsigned int max, unsigned int min, char escape, bool skipWhitespace, bool reportData)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>abort</code>: List of valid characters</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>escape</code>: Character which escapes characters in value</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped after sucessfully parsing the object</dd>
          <dd><code>reportData</code>: Flag if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>abort != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseTextEsc2"></a><b>ParseTextEsc</b> (const ParseTextEsc&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseTextEsc"></a>virtual <b>~ParseTextEsc</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POTxEoperator="></a>ParseTextEsc&amp; <b>operator=</b> (const ParseTextEsc&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POTxEcheckValue"></a>int <b>checkValue</b> (char ch)</pre>
    <dl>
      <dd><p>Checks if the parsed value is according the abort-list of the object.</p>
        <p>Valid are every characters <b>not</b> in <code>pValue</code> or even those if they
          are preceeded ("escaped") by the character specified by
          escape (unless this itself is preceeded by itself).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>ch</code>: Char to check</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>boolean: Result; 1 if valid, 0 if not or -1 if character should be ignored</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseTextEsc"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseTextEsc</h1>
    <p>Derived from:
      <a href="Parse.html#ParseTextEsc">ParseTextEsc</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseTextEsc1"><b>CBParseTextEsc</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">abort</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span> = 1, <span style="color:purple">char</span> <span style="color:blue">escape</span> = '\\', <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseTextEsc2"><b>CBParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseTextEsc"><b>CBParseTextEsc</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseTextEsc"><b>CBParseTextEsc</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBTxEoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseTextEsc"><b>CBParseTextEsc</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBTxEsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseTextEsc"><b>~CBParseTextEsc</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBTxEfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseTextEsc1"></a><b>CBParseTextEsc</b> (const char* abort, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
                unsigned int max, unsigned int min = 1, char escape = '\\',
                bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>abort</code>: Characters ending parsing of the object.</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>escape</code>: Character which escapes characters in value</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseTextEsc2"></a><b>CBParseTextEsc</b> (const CBParseTextEsc&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseTextEsc"></a> <b>~CBParseTextEsc</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBTxEoperator="></a>CBParseTextEsc&amp; <b>operator=</b> (const CBParseTextEsc&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBTxEsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd>Changes the callback to the passed parameter.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="found"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseTextEsc"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseTextEsc&lt;T&gt;</h1>
    <p>Derived from: <a href="Parse.html#ParseTextEsc">ParseTextEsc</a></p>

    <p>Header-file: Parse.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse text until an abort-character with a callback to report
      matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseTextEsc"><b>ParseTextEsc</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseTextEsc1"><b>OFParseTextEsc</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">abort</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a>  <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span> = 1, <span style="color:purple">char</span> <span style="color:blue">escape</span> = '\\', <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseTextEsc2"><b>OFParseTextEsc</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseTextEsc"><b>OFParseTextEsc</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseTextEsc"><b>OFParseTextEsc</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFTxEoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OFParseTextEsc"><b>OFParseTextEsc</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~OFParseTextEsc"><b>~OFParseTextEsc</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFTxEfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseTextEsc1"></a><b>OFParseTextEsc</b> (const char* abort, const char* description, T&amp; objToNotify,
                <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max, unsigned int min = 1,
                char escape = '\\', bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor setting the object to notify and its callback-method.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>abort</code>: Characters ending parsing of the object.</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>escape</code>: Character which escapes characters in value</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseTextEsc2"></a><b>OFParseTextEsc</b> (const OFParseTextEsc&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseTextEsc"></a><b>~OFParseTextEsc</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFTxEoperator="></a>OFParseTextEsc&amp; <b>operator=</b> (const OFParseTextEsc&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFTxEfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseExact">CBParseExact</a>
      <a href="Parse.html#OMParseExact">OFParseExact&lt;T&gt;</a>
      <a href="Parse.html#ParseUpperExact">ParseUpperExact</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!)</p>

    <p>The min- and max-members are not totally wasted; they could be
      used to define the minimal length of certain keywords which would
      be valid even if just written in a short(er) form and/or to include
      values with a zero ('\0') character into the value to parse (although the
      main reason for them is that I didn't want to re-consider the
      class-hierarchy anymore).</p>

    <p><b>Note</b>: This class uses <code>strlen</code> to get the length of value
      so don't use its first constructor to check for text with a '\0' inside!</p>

    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseExact1"><b>ParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseExact2"><b>ParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseExact3"><b>ParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseExact"><b>ParseExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseExact"><b>ParseExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POExaoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseExact"><b>ParseExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseExact"><b>~ParseExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POExacheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">bool</span></tt></tt> </td>
        <td><a href="Parse.html#POExacheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">ch</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseExact1"></a> <b>ParseExact</b> (const char* value, const char* description, bool skipWhitespace, bool reportData)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseExact2"></a><b>ParseExact</b> (const char* value, const char* description, unsigned int max,
            unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object</p>
        <p>The parameters <code>min</code> and <code>max</code> could be used to define a
          minimal length of a keyword. This word would be valid if at least min
          characters would be parsed, but other (longer) versions of the word
          would also be valid.</p>
        <p>Another possible usage is to add the zero character (`\0') into the value
          to parse.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseExact3"></a><b>ParseExact</b> (const ParseExact&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseExact"></a> <b>~ParseExact</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POExaoperator="></a>ParseExact&amp; <b>operator=</b> (const ParseExact&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POExacheckValue"></a>int <b>checkValue</b> (char ch)</pre>
    <dl>
      <dd><p>Checks if the passed character is exactly equal (case-sensitive!)
        than the one in the actual position of the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>ch</code>: Char to check</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>boolean: Result; true if valid</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POExacheckIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks the constraints of the object</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseExact">ParseExact</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseExact"><b>ParseExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseExact1"><b>CBParseExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#CBParseExact2"><b>CBParseExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseExact3"><b>CBParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseExact"><b>CBParseExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseExact"><b>CBParseExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBExaoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseExact"><b>CBParseExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBExasetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~CBParseExact"><b>~CBParseExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBExafound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseExact1"></a><b>CBParseExact</b> (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
              bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor; sets the neccessary data for this object.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseExact2"></a><b>CBParseExact</b> (const char* value, const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
              unsigned int max, unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object</p>
        <p>The parameters <code>min</code> and <code>max</code> could be used to define a
          minimal length of a keyword. This word would be valid if at least min
          characters would be parsed, but other (longer) versions of the word
          would also be valid.</p>
        <p>Another possible usage is to add the zero character (`\0') into the value
          to parse.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseExact3"></a><b>CBParseExact</b> (const CBParseExact&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseExact"></a> <b>~CBParseExact</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBExaoperator="></a>CBParseExact&amp; <b>operator=</b> (const CBParseExact&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBExasetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="CBExafound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseExact&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseExact">ParseExact</a></p>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseExact"><b>ParseExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseExact1"><b>OFParseExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>,  <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a>  <span style="color:blue">callback</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseExact2"><b>OFParseExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>,  <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a>  <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseExact3"><b>OFParseExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseExact"><b>OFParseExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseExact"><b>OFParseExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFExaoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseExact"><b>OFParseExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~OFParseExact"><b>~OFParseExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFExafound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseExact1"></a><b>OFParseExact</b> (const char* value, const char* description, T&amp; objToNotify,
              <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor setting the object to notify and its callback-method.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseExact2"></a><b>OFParseExact</b> (const char* value, const char* description, T&amp; objToNotify,
              <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max,
              unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor setting the object to notify and its callback-method.</p>
        <p>The parameters <code>min</code> and <code>max</code> could be used to define a
          minimal length of a keyword. This word would be valid if at least min
          characters would be parsed, but other (longer) versions of the word
          would also be valid.</p>
        <p>Another possible usage is to add the zero character (`\0') into the value
          to parse.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <pre><a name="OFParseExact3"></a><b>OFParseExact</b> (const OFParseExact&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseExact"></a><b>~OFParseExact</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFExaoperator="></a>OFParseExact&amp; <b>operator=</b> (const OFParseExact&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFExafound"></a>int <b>found</b> (const char* pFoundValue)</pre>
    <dl>
      <dd><p>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseUpperExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseUpperExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseAttomic">ParseAttomic</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseUpperExact">CBParseUpperExact</a>
      <a href="Parse.html#OMParseUpperExact">OFParseUpperExact&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!)</p>

    <p>The min- and max-members are not totally wasted; they could be
      used to define the minimal length of certain keywords which would
      be valid even if just written in a short(er) form and/or to include
      values with a zero character ('\0') (although the
      main reason for them is that I didn't want to re-consider the
      class-hierarchy anymore).</p>

    <p><b>Note</b>: This class uses <i>strlen</i> to get the length of value
      so don't its first constructor to check for text with a '\0' inside!</p>

    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseUpperExact1"><b>ParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true))</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseUpperExact2"><b>ParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true, <tt><span style="color:purple;">bool</span></tt> <tt><span style="color:blue;">reportData</span></tt> = true))</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseUpperExact3"><b>ParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html"><tt><span style="color:navy"><b>ParseUpperExact</b></span></tt></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POUExoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseUpperExact"><b>~ParseUpperExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POUExcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">bool</span></tt></tt> </td>
        <td><a href="Parse.html#POUExcheckValue"><b>checkValue</b></a></td>
        <td><tt>(<tt><span style="color:purple">char</span></tt> <tt><span style="color:blue">ch</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseUpperExact1"></a><b>ParseUpperExact</b> (const char* value, const char* description,
                 bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseUpperExact2"></a><b>ParseUpperExact</b> (const char* value, const char* description, unsigned int max,
                 unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object</p>
        <p>The parameters <code>min</code> and <code>max</code> could be used to define a
          minimal length of a keyword. This word would be valid if at least min
          characters would be parsed, but other (longer) versions of the word
          would also be valid.</p>
        <p>Another possible usage is to add the zero character (`\0') into the value
          to parse.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseUpperExact3"></a><b>ParseUpperExact</b> (const ParseUpperExact&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseUpperExact"></a> <b>~ParseUpperExact</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POUExoperator="></a>ParseUpperExact&amp; <b>operator=</b> (const ParseUpperExact&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POUExccheckValue"></a>int <b>checkValue</b> (char ch)</pre>
    <dl>
      <dd><p>Checks if the passed character is exactly equal (not case-sensitive!)
        than the one in the actual position of the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>ch</code>: Char to check</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>boolean: Result; true if valid</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POUExccheckIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks the constraints of the object</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseUpperExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseUpperExact</h1>
    <p>Derived from:
      <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseUpperExact1"><b>CBParseUpperExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseUpperExact2"><b>CBParseUpperExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseUpperExact3"><b>CBParseUpperExact</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseUpperExact"><b>CBParseUpperExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseUpperExact"><b>CBParseUpperExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBUExoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseUpperExact"><b>CBParseUpperExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBUExsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseUpperExact"><b>~CBParseUpperExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBUExfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseUpperExact1"></a><b>CBParseUpperExact</b> (const char* value, const char* description,
                   <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd>Constructor; sets the neccessary data for this object.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseUpperExact2"></a><b>CBParseUpperExact</b> (const char* value, const char* description,
                   <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback, unsigned int max,
                   unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object</p>
        <p>The parameters <code>min</code> and <code>max</code> could be used to define a
          minimal length of a keyword. This word would be valid if at least min
          characters would be parsed, but other (longer) versions of the word
          would also be valid.</p>
        <p>Another possible usage is to add the zero character (`\0') into the value
          to parse.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
          <dd><code>reportData</code>: Flag, if data should be stored and reported</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseUpperExact3"></a><b>CBParseUpperExact</b> (const CBParseUpperExact&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseUpperExact"></a> <b>~CBParseUpperExact</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBUExoperator="></a>CBParseUpperExact&amp; <b>operator=</b> (const CBParseUpperExact&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBUExsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="found"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseUpperExact"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseUpperExact&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseUpperExact">ParseUpperExact</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse exactly a certain text (not case-sensitive!) with a callback
      to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseUpperExact"><b>ParseUpperExact</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseUpperExact1"><b>OFParseUpperExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseUpperExact2"><b>OFParseUpperExact</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">value</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span>, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td> </td>
        <td><a href="Parse.html#OFParseUpperExact3"><b>OFParseUpperExact</b></a></td>
        <td><tt>(const <a href="Parse.html#OMParseUpperExact"><b>OFParseUpperExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseUpperExact"><b>OFParseUpperExact</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFUExoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(const <a href="Parse.html#CBParseUpperExact"><b>OFParseUpperExact</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="Parse.html#~OFParseUpperExact"><b>~OFParseUpperExact</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt>virtual <span style="color:purple">int</span></tt> </td>
        <td><a href="Parse.html#OFUExfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseUpperExact1"></a><b>OFParseUpperExact</b> (const char* value, const char* description, T&amp; objToNotify,
                   <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor setting the object to notify and its callback-method.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseUpperExact2"></a><b>OFParseUpperExact</b> (const char* value, const char* description, T&amp; objToNotify,
                   <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max,
                   unsigned int min, bool skipWhitespace = true)</pre>
    <dl>
      <dd><p>Constructor setting the object to notify and its callback-method.</p>
        <p>The parameters <code>min</code> and <code>max</code> could be used to define a
          minimal length of a keyword. This word would be valid if at least min
          characters would be parsed, but other (longer) versions of the word
          would also be valid.</p>
        <p>Another possible usage is to add the zero character (`\0') into the value
          to parse.</dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Sequence of characters to parse in that order</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd><code>value</code> != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseUpperExact3"></a><b>OFParseUpperExact</b> (const OFParseUpperExact&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseUpperExact"></a><b>~OFParseUpperExact</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFUExoperator="></a>OFParseUpperExact&amp; <b>operator=</b> (const OFParseUpperExact&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFUExfound"></a>int <b>found</b> (const char* pFoundValue)</pre>
    <dl>
      <dd><p>Calls the defined callback of the specified object with the passed
        parameter and returns its result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseSequence"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseSequence</h1>
    <p>Derived from:
      <a href="Parse.html#ParseObject">ParseObject</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseSequence">CBParseSequence</a>
      <a href="Parse.html#OMParseSequence">OFParseSequence&lt;T&gt;</a>
      <a href="Parse.html#ParseSelection">ParseSelection</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects (sequences).</p>

    <p>A sequence is only considered parsed successfully, if all of
      its elements are parsed successfully (in the order specified by
      the sequence).</p>

    <p>Errors while parsing cause a <i>soft error</i> (meaning parsing
      can be continued) only for the first element; errors for further
      elements cause <i>hard errors</i> (which are not recoverable and
      parsing is ended).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSequence1"><b>ParseSequence</b></a></td>
        <td><tt>(<a href="Parse.html#ParseObject"><tt><span style="color:navy"><b>ParseObject</b></span></tt></a>* <tt><span style="color:blue">apObjectList[]</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSequence2"><b>ParseSequence</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSeqgetMaxCard"><b>getMaxCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSeqgetMinCard"><b>getMinCard</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POSeqoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POSeqsetMaxCard"><b>setMaxCard</b></a></td>
        <td><tt>(<tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">val</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#POSeqsetMinCard"><b>setMinCard</b></a></td>
        <td><tt>(<tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">val</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseSequence"><b>~ParseSequence</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSeqcheckIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSeqdoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><span style="color:blue">stream</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">optional</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseSequence1"></a> <b>ParseSequence</b> (ParseObject* apObjectList[], const char* description, unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pObjectList</code>: NULL-terminated array of pointers to objects to parse</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>apObjectList != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseSequence2"></a> <b>ParseSequence</b> (const ParseSequence&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseSequence"></a> <b>~ParseSequence</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POSeqoperator="></a>ParseSequence&amp; <b>operator=</b> (const ParseSequence&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to  this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Accessing values</h3>
    <pre><a name="POSeqgetMaxCard"></a>unsigned int <b>getMaxCard</b> () const</pre>
    <dl>
      <dd><p>Returns the maximal number how often the sequence may be repeated.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned int: Maximal number the object can be parsed.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POSeqsetMaxCard"></a>void <b>setMaxCard</b> (unsigned int val)</pre>
    <dl>
      <dd><p>Changes the maximal number how often the sequence may be repeated</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>val</code>: New maximal number the object can be parsed.</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="POSeqgetMinCard"></a>unsigned int <b>getMinCard</b> () const</pre>
    <dl>
      <dd><p>Returns the minimal number how often the sequence must be repeated.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>unsigned int: Minimal number the object must be parsed.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="POSeqsetMinCard"></a>void <b>setMinCard</b> (unsigned int val)</pre>
    <dl>
      <dd><p>Changes the minimal number how often the sequence must be repeated.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>val</code>: New minimal number the object must be parsed.</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="POSeqdoParse"></a>int <b>doParse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool optional) throw (std::string)</pre>
    <dl>
      <dd><p>Tries to parse the objects of the sequence from the stream, as long as
         every object reports <code>PARSE_OK</code>.</p>
        <p>It is a soft error (<code>PARSE_ERROR</code>) if the minimal cardinality is
          not fullfilled.</p>
        <p>If parsing is not optional and/or the error is not recoverable (&lt; 0),
          an exception (std::string) is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Source from which to read</dd>
           <dd><code>optional</code>: Flag, if node must be found</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: In case of a not recoverable error</dd></dl></dd>
      </dl></dd>
    </dl>
    <hr>

    <h3 style="color:navy">Status-handling</h3>
    <pre><a name="POSeqcheckIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks the constraints of the object</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseSequence"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseSequence</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects with a callback to report matching
      input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSequence1"><b>CBParseSequence</b></a></td>
        <td><tt>(<a href="Parse.html"><tt><span style="color:navy"><b>ParseObject</b></span></tt></a>* <tt><span style="color:blue">apObjectList[]</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSequence2"><b>CBParseSequence</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSequence"><b>CBParseSequence</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseSequence"><b>CBParseSequence</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBSeqoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSequence"><b>CBParseSequence</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBSeqsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseSequence"><b>~CBParseSequence</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBSeqfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseSequence1"></a><b>CBParseSequence</b> (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
                 unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pObjectList</code>: NULL-terminated array of pointers to objects to parse</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseSequence2"></a><b>CBParseSequence</b> (const CBParseSequence&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseSequence"></a> <b>~CBParseSequence</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBSeqoperator="></a>CBParseSequence&amp; <b>operator=</b> (const CBParseSequence&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBSeqsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="CBSeqfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseSequence"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseSequence&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse series of ParseObjects with a callback to report matching
      input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSequence"><b>ParseSequence</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSequence1"><b>OFParseSequence</b></a></td>
        <td><tt>(<a href="Parse.html"><tt><span style="color:navy"><b>ParseObject</b></span></tt></a>* <tt><span style="color:blue">apObjectList[]</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <span style="color:blue">callback</span>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSequence2"><b>OFParseSequence</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSequence"><b>OFParseSequence</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseSequence"><b>OFParseSequence</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFSeqoperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSequence"><b>OFParseSequence</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseSequence"><b>~OFParseSequence</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFSeqfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseSequence1"></a><b>OFParseSequence</b> (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description, T&amp; objToNotify,
                 <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pObjectList</code>: NULL-terminated array of pointers to objects to parse</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseSequence2"></a><b>OFParseSequence</b> (const OFParseSequence&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseSequence"></a><b>~OFParseSequence</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFSeqoperator="></a>OFParseSequence&amp; <b>operator=</b> (const OFParseSequence&amp; other)</pre>
    <dl>
      <dd><p>Assignment operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFSeqfound"></a>int <b>found</b> (const char* pFoundValue)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="ParseSelection"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class ParseSelection</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSequence">ParseSequence</a>
      <br>
      Derived by:
      <a href="Parse.html#CBParseSelection">CBParseSelection</a>
      <a href="Parse.html#OMParseSelection">OFParseSelection&lt;T&gt;</a></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObject out of a list.</p>

    <p>If an object matching the parsed intput is found, the sequence
      is considered as parsed successfully.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSelection1"><b>ParseSelection</b></a></td>
        <td><tt>(<a href="Parse.html"><tt><span style="color:navy"><b>ParseObject</b></span></tt></a>* <tt><span style="color:blue">apObjectList[]</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#ParseSelection2"><b>ParseSelection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#POSeloperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~ParseSelection"><b>~ParseSelection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#POSeldoParse"><b>doParse</b></a></td>
        <td><tt>(<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; <tt><span style="color:blue">stream</span></tt>, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">optional</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="ParseSelection1"></a>ParseSelection (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description,
                unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data of this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pObjectList</code>: NULL-terminated array of objects to parse</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>max</code>: Maximal cardinality</dd>
          <dd><code>min</code>: Minimal cardinality</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>apObjectList != NULL &amp;&amp; !ParseObject::checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ParseSelection2"></a> <b>ParseSelection</b> (const ParseSelection&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~ParseSelection"></a> <b>~ParseSelection</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="POSeloperator="></a>ParseSelection&amp; <b>operator=</b> (const ParseSelection&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="POSeldoParse"></a>int <b>doParse</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream, bool optional) throw (std::string)</pre>
    <dl>
      <dd><p>Tries to parse the objects of the selection from the stream, until
         one object reports <code>PARSE_OK</code>.</p>
        <p>It is a soft error (<code>PARSE_ERROR</code>) if the minimal cardinality is
          not fullfilled.</p>
        <p>If parsing is not optional and/or the error is not recoverable (&lt; 0),
          an exception (std::string) is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Source from which to read</dd>
          <dd><code>optional</code>: Flag, if node must be found</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>PARSE_OK if selection found; PARSE_ERROR if not</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: In case of a not recoverable error</dd></dl></dd>
    </dl>

    <hr noshade><a name="CBParseSelection"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="cross_index.html">Cross Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class CBParseSelection</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSelection">ParseSelection</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list  with a
      callback to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSelection1"><b>CBParseSelection</b></a></td>
        <td><tt>(<a href="Parse.html"><span style="color:navy"><b>ParseObject</b></span></a>* <span style="color:blue">apObjectList[]</span>, const <span style="color:purple">char</span>* <span style="color:blue">description</span>, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <span style="color:blue">callback</span>, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">max</span> = 1, <span style="color:navy">unsigned</span> <span style="color:purple">int</span> <span style="color:blue">min</span> = 1, <span style="color:purple">bool</span> <span style="color:blue">skipWhitespace</span> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#CBParseSelection2"><b>CBParseSelection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSelection"><b>CBParseSelection</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#CBParseSelection"><b>CBParseSelection</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#CBSeloperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#CBParseSelection"><b>CBParseSelection</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="Parse.html#CBSelsetCallback"><b>setCallback</b></a></td>
        <td><tt>(<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> <tt><span style="color:blue">callback</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~CBParseSelection"><b>~CBParseSelection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#CBSelfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="CBParseSelection1"></a><b>CBParseSelection</b> (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description, <a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a> callback,
                  unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pObjectList</code>: NULL-terminated array of pointers to objects to parse</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>calback</code>: Callback to notify of successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="CBParseSelection2"></a><b>CBParseSelection</b> (const CBParseSelection&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="~CBParseSelection"></a> <b>~CBParseSelection</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="CBSeloperator="></a>CBParseSelection&amp; <b>operator=</b> (const CBParseSelection&amp; other)</pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="CBSelsetCallback"></a>void <b>setCallback</b> (<a href="Parse.html#PARSECALLBACK"><b>PARSECALLBACK</b></a>)</pre>
    <dl>
      <dd><p>Changes the callback to the passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>callback</code> Pointer to function to inform about successfull parsing</dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="CBSelfound"></a>int <b>found</b> (const char* pFoundValue, unsigned int len)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>

    <hr noshade><a name="OMParseSelection"></a>

    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
        <td><a href="Parse.html#General">General parser-information</a></td></tr>
    </table>

    <h1 align="center">Class OFParseSelection&lt;T&gt;</h1>
    <p>Derived from:
      <a href="Parse.html#ParseSelection">ParseSelection</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;Parse.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse a selection of one ParseObjects out of a list  with a
      callback to report matching input.</p>

    <p>See the documentation of <a href="Parse.html#ParseSelection"><b>ParseSelection</b></a>
      for further details.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSelection1"><b>OFParseSelection</b></a></td>
        <td><tt>(<a href="Parse.html"><tt><span style="color:navy"><b>ParseObject</b></span></tt></a>* <tt><span style="color:blue">apObjectList[]</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">description</span></tt>, <span style="color:navy">T</span>&amp; <span style="color:blue">objToNotify</span>, <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> <span style="color:blue">callback</span>, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">max</span></tt> = 1, <tt><span style="color:navy">unsigned</span></tt> <tt><span style="color:purple">int</span></tt> <tt><span style="color:blue">min</span></tt> = 1, <tt><span style="color:purple">bool</span></tt> <tt><span style="color:blue">skipWhitespace</span></tt> = true)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="Parse.html#OFParseSelection2"><b>OFParseSelection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSelection"><b>OFParseSelection</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="Parse.html#OMParseSelection"><b>OFParseSelection</b></a>&amp;</tt> </td>
        <td><a href="Parse.html#OFSeloperator="><tt><span style="color:black"><b>operator=</b></span></tt></a></td>
        <td><tt>(<tt>const</tt> <a href="Parse.html#OMParseSelection"><b>OFParseSelection</b></a>&amp; <tt><span style="color:blue">other</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="Parse.html#~OFParseSelection"><b>~OFParseSelection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="Parse.html#OFSelfound"><b>found</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pFoundValue</span></tt>, <tt><span style="color:navy;">unsigned</span></tt> <tt><span style="color:purple;">int</span></tt> <tt><span style="color:blue;">len</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3 style="color:navy">Management functions</h3>
    <pre><a name="OFParseSelection1"></a><b>OFParseSelection</b> (<a href="Parse.html#ParseObject"><b>ParseObject</b></a>* apObjectList[], const char* description, T&amp; objToNotify,
                 <a href="Parse.html#PTCALLBACK"><b>PTCALLBACK</b></a> callback, unsigned int max, unsigned int min, bool skipWhitespace)</pre>
    <dl>
      <dd><p>Constructor; sets the neccessary data for this object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pObjectList</code>: NULL-terminated array of pointers to objects to parse</dd>
          <dd><code>description</code>: Description of object (what it parses)</dd>
          <dd><code>objToNofity</code>: Object to notify</dd>
          <dd><code>callback</code> Pointer to object member to inform about successfull parsing</dd>
          <dd><code>max</code>: Maximal cardinality, how often can the object be parsed</dd>
          <dd><code>min</code>: Minimal cardinality, how often must the object be parsed</dd>
          <dd><code>skipWhitespace</code>: Flag if <b>trailing</b> whitespaces should be skipped</dd>
      </dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>!checkIntegrity ()</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="OFParseSelection2"></a><b>OFParseSelection</b> (const OFParseSelection&amp; other)</pre>
    <dl>
      <dd><p>Copy-constructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~OFParseSelection"></a><b>~OFParseSelection</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="OFSeloperator="></a>OFParseSelection&amp; <b>operator=</b> (const OFParseSelection&amp; other)</pre>
    <dl>
      <dd><p>Assignment operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to clone</dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Reference to this</dd></dl></dd>
      </dl></dd>
    </dl>

    <h3 style="color:navy">Parsing</h3>
    <pre><a name="OFSelfound"></a>int <b>found</b> (const char* pFoundValue)</pre>
    <dl>
      <dd><p>Calls the defined callback with the passed parameter and returns its
        result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pFoundValue</code>: Pointer to found value</dd>
          <dd><code>len</code>: Length of found data</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0 OK</dd></dl></dd>
    </dl>
  </body>
</html>
