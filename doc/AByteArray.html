<!-- -*-HTML-*- -->

<!-- $Id: AByteArray.html,v 1.8 2002/11/30 05:57:17 markus Exp $ -->

<html>
  <head>
    <title>General Reference: AByteArray</title>
    <meta name="description" content="Documentation of AByteArray-class">
    <meta name="keywords" content="Documentation, Docu, AByteArray, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2001-09-15">
    <meta name="DC.Rights" content="Anticopyright (A) 2001, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class AByteArray</h1>
    <p>Derived from: <a href="AttrVal.html">AttributValue</a>
      <br>
      Derived by: <i>none</i>
    </p>

    <p>#include &lt;AByteArray.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class for raw character-values. As every AttributValue is supports undefined
      values.</p>

    <p>In counterpart to the std::string-class this class distinguishes between an
      empty value and not defined (as every AttributValue).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray"><b>AByteArray</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray4"><b>AByteArray</b></a></td>
        <td><tt>(<tt><font color="purple">int</font></tt> <tt><font color="blue">length</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray3"><b>AByteArray</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">length</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray5"><b>AByteArray</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray6"><b>AByteArray</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pSource</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray7"><b>AByteArray</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pSource</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">length</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray8"><b>AByteArray</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">std::string</font></tt>&amp; <tt><font color="blue">str</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="AByteArray.html#AByteArray2"><b>AByteArray</b></a></td>
        <td><tt>(<tt>const</tt> <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#append"><b>append</b></a></td>
        <td><tt>(<tt>const</tt> <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <tt><font color="blue">o</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#append5"><b>append</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">std::string</font></tt>&amp; <tt><font color="blue">str</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#append2"><b>append</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pSource</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#append3"><b>append</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pSource</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">length</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#append4"><b>append</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#assign"><b>assign</b></a></td>
        <td><tt>(<tt>const</tt> <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#assign4"><b>assign</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">std::string</font></tt>&amp; <tt><font color="blue">str</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#assign2"><b>assign</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pValue</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#assign3"><b>assign</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pValue</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">length</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#assign5"><b>assign</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>const</tt> <tt><font color="purple">char</font></tt></tt>&amp; </td>
        <td><a href="AByteArray.html#at"><b>at</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">pos</font></tt>) const throw (<tt><font color="navy">out_of_range</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">char</font></tt>&amp;</tt> </td>
        <td><a href="AByteArray.html#at2"><b>at</b></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">pos</font></tt>) throw (<tt><font color="navy">out_of_range</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#compare5"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">other</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#compare2"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">std::string</font></tt>&amp; <tt><font color="blue">other</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#compare4"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">other</font></tt>, <tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">length</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#compare3"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">other</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#compare2"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <tt><font color="blue">other</font></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>const</tt> <tt><font color="purple">char</font></tt>*</tt> </td>
        <td><a href="AByteArray.html#data"><b>data</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="AByteArray.html#define"><b>define</b></a></td>
        <td><tt>()</tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="AByteArray.html#empty"><b>empty</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#length"><b>length</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator="><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator=4"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator=2"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pValue</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator=3"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">std::string</font></tt>&amp; <tt><font color="blue">str</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator+=4"><tt><font color="black"><b>operator</b></font></tt><tt>+=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">std::string</font></tt>&amp; <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator+=2"><tt><font color="black"><b>operator</b></font></tt><tt>+=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator+="><tt><font color="black"><b>operator</b></font></tt><tt>+=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="AByteArray.html"><b>AByteArray</b></a>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator+=3"><tt><font color="black"><b>operator</b></font></tt><tt>+=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">char</font></tt></tt> </td>
        <td><a href="AByteArray.html#operator[]"><tt><font color="black"><b>operator</b></font></tt><tt>[]</tt></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">pos</font></tt>) const throw (<tt><font color="navy">out_of_range</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">char</font></tt>&amp;</tt> </td>
        <td><a href="AByteArray.html#operator[]2"><tt><font color="black"><b>operator</b></font></tt><tt>[]</tt></a></td>
        <td><tt>(<tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt> <tt><font color="blue">pos</font></tt>) const throw (<tt><font color="navy">out_of_range</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+2"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+3"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+4"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+5"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+6"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt>friend <a href="AByteArray.html"><b>AByteArray</b></a></tt></td>
        <td><a href="AByteArray.html#operator+7"><tt><font color="black"><b>operator</b></font>+</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator=="><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator==2"><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator==3"><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator==4"><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator==5"><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator==6"><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator==7"><tt><font color="black"><b>operator</b></font>==</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!="><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!=2"><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!=3"><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!=4"><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
	     const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!=5"><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!=6"><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operator!=7"><tt><font color="black"><b>operator</b></font>!=</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt2"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt3"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt4"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
	     const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt5"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt6"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt7"><tt><font color="black"><b>operator</b></font>&lt;</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt2"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt3"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt4"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
	     const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt5"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt6"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt7"><tt><font color="black"><b>operator</b></font>&gt;</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt="><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt=2"><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt=3"><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt=4"><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
	     const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt=5"><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt=6"><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorlt=7"><tt><font color="black"><b>operator</b></font>&lt;=</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt="><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt=2"><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">std::string</font>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt=3"><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
          const <font color="purple">char</font>* <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt=4"><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">lhs</font>,
	     const <font color="purple">char</font> <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt=5"><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <font color="purple">std::string</font>&amp; <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt=6"><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>
      <tr valign="top"><td>friend <tt><font color="purple">bool</font></tt></td>
        <td><a href="AByteArray.html#operatorgt=7"><tt><font color="black"><b>operator</b></font>&gt;=</tt></a></td>
        <td><tt>(const <font color="purple">char</font> <font color="blue">lhs</font>,
          const <a href="AByteArray.html"><b>AByteArray</b></a>&amp; <font color="blue">rhs</font>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="navy">std::string</font></tt></tt> </td>
        <td><a href="AByteArray.html#toString"><b>toString</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="AByteArray.html#undefine"><b>undefine</b></a></td>
        <td><tt>()</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="AByteArray.html#~AByteArray"><b>~AByteArray</b></a></td>
        <td><tt>()</tt>;</td></tr>

      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="AByteArray.html#checkIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><font color="navy">Management functions</font></h3>
    <pre><a name="AByteArray"></a><b>AByteArray</b> ()</pre>
    <dl>
      <dd><p>Defaultconstructor; the value is not defined</p></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray2"></a><b>AByteArray</b> (const AByteArray&amp; other)</pre>
    <dl>
      <dd><p>Copyconstructor</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Object to copy</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray3"></a><b>AByteArray</b> (unsigned int length)</pre>
    <dl>
      <dd><p>Constructor; the object is created with reserved memory of &lt;length&gt;
        bytes (to minimize further re-allocation of memory in case of appending).</p>
	<p>Although the object contains no value it is defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>length</code>: Number of bytes to reserve</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray4"></a><b>AByteArray</b> (int length)</pre>
    <dl>
      <dd><p>Constructor; the object is created with reserved memory of &lt;length&gt;
        bytes (to minimize further re-allocation of memory in case of appending).</p>
	<p>Although the object contains no value it is defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>length</code>: Number of bytes to reserve</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray5"></a><b>AByteArray</b> (char ch)</pre>
    <dl>
      <dd><p>Constructor; the character is set in the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>ch</code>: Value to set in the object</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray6"></a><b>AByteArray</b> (const char* pSource)</pre>
    <dl>
      <dd><p>Constructor; the input is copied into the object</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pSource</code>: Pointer to the initial value</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pSource</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray7"></a><b>AByteArray</b> (const char* pSource, unsigned int length)</pre>
    <dl>
      <dd><p>Constructor; exactly length bytes (including zero-bytes) from
             the input are copied into the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pSource</code>: Pointer to the initial value</dd>
                  <dd><code>length</code>: Number of the character array to copy</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pSource</code> must be a valid pointer to a character array
              of at least <code>length</code> bytes</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="AByteArray8"></a><b>AByteArray</b> (const std::string&amp; str)</pre>
    <dl>
      <dd><p>Constructor; the string is copied into the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>str</code>: String to use as initial value</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="~AByteArray"></a>virtual <b>~AByteArray</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd></dl>
    <hr>
    <pre><a name="operator="></a>AByteArray&amp; <b>operator=</b> (const AByteArray&amp; other)</pre>
    <dl>
      <dd><p>Assignment operator; if the other object specifies a differnt object,
         its content is copied.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Object to duplicate</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator=2"></a>AByteArray&amp; <b>operator=</b> (const char* pValue)</pre>
    <dl>
      <dd><p>Assigns the passed value to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pValue</code>: Pointer to the initial value</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pValue</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator=3"></a>AByteArray&amp; <b>operator=</b> (const std::string&amp; str)</pre>
    <dl>
      <dd><p>Assigns the passed string to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>str</code>: String to use as initial value</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator=4"></a>AByteArray&amp; <b>operator=</b> (char ch)</pre>
    <dl>
      <dd><p>Assigns the character to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>ch</code>: Value to set in the object</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="assign"></a>AByteArray&amp; <b>assign</b> (const AByteArray&amp; other)</pre>
    <dl>
      <dd><p>If the other object specifies a differnt object, its content is copied.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Object to duplicate</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="assign2"></a>AByteArray&amp; <b>assign</b> (const char* pValue)</pre>
    <dl>
      <dd><p>Assigns the passed value to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pValue</code>: Pointer to the initial value</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pValue</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="assign3"></a>AByteArray&amp; <b>assign</b> (const char* pValue, unsigned int length)</pre>
    <dl>
      <dd><p>Assigns len bytes of the passed value to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pValue</code>: Pointer to the initial value</dd>
                  <dd><code>length</code>: Number of the character array to copy</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pValue</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="assign4"></a>AByteArray&amp; <b>assign</b> (const std::string&amp; str)</pre>
    <dl>
      <dd><p>Assigns the passed string to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>str</code>: String to use as initial value</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="assign5"></a>AByteArray&amp; <b>assign</b> (char ch)</pre>
    <dl>
      <dd><p>Assigns the character to the object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>ch</code>: Value to set in the object</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="define"></a>void <b>define</b> ()</pre>
    <dl>
      <dd><p>Defines the object and sets the value to empty.</p></dd>
    </dl>

    <hr>
    <pre><a name="undefine"></a>void <b>undefine</b> ()</pre>
    <dl>
      <dd><p>Undefines the object and deletes its contents.</p></dd>
    </dl>

    <h3><font color="navy">Query of data</font></h3>
    <pre><a name="operator[]"></a>char <b>operator[]</b> (unsigned int pos) const throw (out_of_range)</pre>
    <dl>
      <dd><p>Retrieves the byte at the specified position.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pos</code>: Position to return</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The character at the specified position</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
            <dd><code>out_of_range</code> if the position is bigger
               than the number of stored characters</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator[]2"></a>const char&amp; <b>operator[]</b> (unsigned int pos) throw (out_of_range)</pre>
    <dl>
      <dd><p>Retrieves a reference to the byte at the specified position.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pos</code>: Position to return</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to the character at the specified position</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
            <dd><code>out_of_range</code> if the position is bigger
               than the number of stored characters</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="at"></a>const char&amp; <b>at</b> (unsigned int pos) const throw (out_of_range)</pre>
    <dl>
      <dd><p>Retrieves a reference to the byte at the specified position.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pos</code>: Position to return</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to the character at the specified position</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
            <dd><code>out_of_range</code> if the position is bigger
               than the number of stored characters</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="at2"></a>char&amp; <b>at</b> (unsigned int pos) throw (out_of_range)</pre>
    <dl>
      <dd><p>Retrieves a reference to the byte at the specified position.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pos</code>: Position to return</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to the character at the specified position</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
            <dd><code>out_of_range</code> if the position is bigger
               than the number of stored characters</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="length"></a>int <b>length</b> () const</pre>
    <dl>
      <dd><p>Returns the number of characters stored in the object.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The number of characters stored in the object</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="data"></a>const char* <b>data</b> () const</pre>
    <dl>
      <dd><p>Returns a pointer to the stored data.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A pointer to the stored data. If the object is undefined a
                NULL-pointer is returned.</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="empty"></a>bool <b>empty</b> () const</pre>
    <dl>
      <dd><p>Returns if the object has data stored.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True, if the object is defined and has a length of at least 1
                character; else false</dd></dl></dd>
    </dl>

    <h3><font color="navy">Conversion</font></h3>
    <pre><a name="toString"></a>virtual std::string <b>toString</b> () const</pre>
    <dl>
      <dd><p>Converts the object into a string.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A string representing the object. If the object is not defined, the
                returned string is empty.</dd></dl></dd>
    </dl>

    <h3><font color="navy">Concatinating</font></h3>
    <pre><a name="operator+="></a>AByteArray&amp; <b>operator+=</b> (const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Appends the contents of rhs to the object. The object is afterwards
             defined if either of the two AByteArrays have been defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>rhs</code>: Object to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+=2"></a>AByteArray&amp; <b>operator+=</b> (const char* rhs)</pre>
    <dl>
      <dd><p>Appends the characters rhs is pointing to to the object. If rhs is at
          least one character long, the object is set to be defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>rhs</code>: Character array to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+=3"></a>AByteArray&amp; <b>operator+=</b> (const char rhs)</pre>
    <dl>
      <dd><p>Appends the passed character to the object. The object is set to be
             defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>rhs</code>: Character to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+=4"></a>AByteArray&amp; <b>operator+=</b> (const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Appends the data of the string to the object. If the string is not
             empty, the object is set to be defined</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>rhs</code>: String to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="append"></a>AByteArray&amp; <b>append</b> (const AByteArray&amp; o)</pre>
    <dl>
      <dd><p>Appends the contents of rhs to the object. The object is afterwards
             defined if either of the two AByteArrays have been defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>o</code>: Object to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="append2"></a>AByteArray&amp; <b>append</b> (const char* pSource)</pre>
    <dl>
      <dd><p>Appends the characters pSource is pointing to to the object. If pSource
          is at least one character long, the object is set to be defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pSource</code>: Character array to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pSource</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="append3"></a>AByteArray&amp; <b>append</b> (const char* pSource, unsigned int length)</pre>
    <dl>
      <dd><p>Appends length characters of the array pSource is pointing to to
          the object. If length is at least one, the object is set to be defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>pSource</code>: Character array to append</dd>
            <dd><code>length</code>: Number of characters to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>pSource</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="append4"></a>AByteArray&amp; <b>append</b> (const char ch)</pre>
    <dl>
      <dd><p>Appends the passed character to the object. The object is set to be
             defined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>rhs</code>: Character to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="append5"></a>AByteArray&amp; <b>append</b> (const std::string&amp; str)</pre>
    <dl>
      <dd><p>Appends the data of the string to the object. If the string is not
             empty, the object is set to be defined</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>rhs</code>: String to append</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>A reference to this</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="operator+"></a>AByteArray&amp; <b>operator+</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+2"></a>AByteArray&amp; <b>operator+</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+3"></a>AByteArray&amp; <b>operator+</b> (const char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+4"></a>AByteArray&amp; <b>operator+</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+5"></a>AByteArray&amp; <b>operator+</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+6"></a>AByteArray&amp; <b>operator+</b> (const AByteArray&amp; lhs, const char rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator+7"></a>AByteArray&amp; <b>operator+</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Concatenates rhs to lhs and returns the result.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of concatenation</dd>
            <dd><code>rhs</code>: Right-hand-side of concatenation</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>The concatinated byte array</dd></dl></dd>
    </dl>

    <h3><font color="navy">Comparison</font></h3>
    <pre><a name="compare"></a>int <b>compare</b> (const AByteArray&amp; other)</pre>
    <dl>
      <dd><p>Compares the values of two byte arrays.</p>
        <p>Undefined values are considered to be smaller than every value;
          if both values are undefined, they are considered as equal.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Object to compare</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>&lt;0: this &lt; other; &gt;0: this > other; 0 else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="compare2"></a>int <b>compare</b> (const std::string&amp; other)</pre>
    <dl>
      <dd><p>Compares the byte array with a string.</p>
        <p>Undefined values are considered to be smaller than any string.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: String to compare</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>&lt;0: this &lt; other; &gt;0: this > other; 0 else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="compare3"></a>int <b>compare</b> (const char* other)</pre>
    <dl>
      <dd><p>Compares the byte array with a character array.</p>
        <p>Undefined values equals the NULL pointer, but are considered to be smaller
          than any other character array.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Character array to compare</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>&lt;0: this &lt; other; &gt;0: this > other; 0 else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>other</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="compare4"></a>int <b>compare</b> (const char* other, unsigned int length)</pre>
    <dl>
      <dd><p>Compares the byte array with length bytes of the passed character array.</p>
        <p>Undefined values equals the NULL pointer, but are considered to be smaller
          than any other character array.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Character array to compare</dd>
            <dd><code>length</code>: Length of data to compare</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>&lt;0: this &lt; other; &gt;0: this > other; 0 else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>other</code> must be a valid pointer to a
              character array with at least length elements</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="compare5"></a>int <b>compare</b> (char other)</pre>
    <dl>
      <dd><p>Compares the byte array with a single character.</p>
        <p>Undefined values are considered to be smaller than any character.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>other</code>: Character to compare</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>&lt;0: this &lt; other; &gt;0: this > other; 0 else</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="operator=="></a>friend bool <b>operator==</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two byte arrays for equalness (equal
          characters and length or both undefined).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator==2"></a>friend bool <b>operator==</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for equalness (equal
          characters and length).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator==3"></a>friend bool <b>operator==</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for equalness (equal
          characters and length). The NULL pointer equals an undefined object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator==4"></a>friend bool <b>operator==</b> (const AByteArray&amp; lhs, char rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for equalness (equal
          character and <code>lhs</code> only one character long).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator==5"></a>friend bool <b>operator==</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for equalness (equal
          characters and length).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator==6"></a>friend bool <b>operator==</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for equalness (equal
          characters and length). The NULL pointer equals an undefined object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator==7"></a>friend bool <b>operator==</b> (char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for equalness (equal
          character and <code>rhs</code> only one character long).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="operator!="></a>friend bool <b>operator!=</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two byte arrays for unequalness (unequal
          characters and/or length or only one defined).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>False if the objects are equal; true else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator!=2"></a>friend bool <b>operator!=</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for unequalness (unequal
          characters and/or length).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>False if the objects are equal; true else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator!=3"></a>friend bool <b>operator!=</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for unequalness (unequal
          characters and/or length).  An undefined objects is different to
          everything excpet a NULL-pointer.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator!=4"></a>friend bool <b>operator!=</b> (const AByteArray&amp; lhs, char rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for unequalness (unequal
          character or <code>lhs</code> not exactly one character long).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
      <dd>Compares the two sides of the equation and returns true if they have a
        different value.</dd>
    </dl>
    <hr>
    <pre><a name="operator!=5"></a>friend bool <b>operator!=</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for unequalness (unequal
          characters and/or length).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>False if the objects are equal; true else</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator!=6"></a>friend bool <b>operator!=</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for unequalness (unequal
          characters and/or length).  An undefined objects is different to
          everything excpet a NULL-pointer.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator!=7"></a>friend bool <b>operator!=</b> (char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the values of two objects for unequalness (unequal
          character or <code>lhs</code> not exactly one character long).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if the objects are equal; false else</dd></dl></dd>
    </dl>

    <hr>
    <pre><a name="operatorlt"></a>friend bool <b>operator&lt;</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt2"></a>friend bool <b>operator&lt;</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt3"></a>friend bool <b>operator&lt;</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt4"></a>friend bool <b>operator&lt;</b> (const AByteArray&amp; lhs, char rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt5"></a>friend bool <b>operator&lt;</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt6"></a>friend bool <b>operator&lt;</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt7"></a>friend bool <b>operator&lt;</b> (char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) precedes the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller; false else</dd></dl></dd>
      <dd></dd>
    </dl>

    <hr>
    <pre><a name="operatorgt"></a>friend bool <b>operator&gt;</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt2"></a>friend bool <b>operator&gt;</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt3"></a>friend bool <b>operator&gt;</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt4"></a>friend bool <b>operator&gt;</b> (const AByteArray&amp; lhs, char rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt5"></a>friend bool <b>operator&gt;</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt6"></a>friend bool <b>operator&gt;</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt7"></a>friend bool <b>operator&gt;</b> (char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        (lexicographically) follows the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger; false else</dd></dl></dd>
      <dd></dd>
    </dl>

    <hr>
    <pre><a name="operatorlt="></a>friend bool <b>operator&lt;=</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt=2"></a>friend bool <b>operator&lt;=</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt=3"></a>friend bool <b>operator&lt;=</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>rhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt=4"></a>friend bool <b>operator&lt;=</b> (const AByteArray&amp; lhs, char rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt=5"></a>friend bool <b>operator&lt;=</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt=6"></a>friend bool <b>operator&lt;=</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorlt=7"></a>friend bool <b>operator&lt;=</b> (char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) follow the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically smaller or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>

    <hr>
    <pre><a name="operatorgt="></a>friend bool <b>operator&gt;=</b> (const AByteArray&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt=2"></a>friend bool <b>operator&gt;=</b> (const AByteArray&amp; lhs, const std::string&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt=3"></a>friend bool <b>operator&gt;=</b> (const AByteArray&amp; lhs, const char* rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt=4"></a>friend bool <b>operator&gt;=</b> (const AByteArray&amp; lhs, char rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt=5"></a>friend bool <b>operator&gt;=</b> (const std::string&amp; lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt=6"></a>friend bool <b>operator&gt;=</b> (const char* lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value except the NULL pointer!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
            <dd><code>lhs</code> must be a valid pointer to a zero-terminated
              character array</dd></dl></dd>
      <dd></dd>
    </dl>
    <hr>
    <pre><a name="operatorgt=7"></a>friend bool <b>operator&gt;=</b> (char lhs, const AByteArray&amp; rhs)</pre>
    <dl>
      <dd><p>Compares the two sides of the equation and returns true if the left-hand-side
        does <b>not</b> (lexicographically) precede the right-hand-side.</p>
        <p>An undefined byte array is smaller than any value!</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
            <dd><code>lhs</code>: Left-hand-side of comparison</dd>
            <dd><code>rhs</code>: Right-hand-side of comparison</dd></dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>True if <code>lhs</code> is lexicographically bigger or equal; false else</dd></dl></dd>
      <dd></dd>
    </dl>

    <hr>
    <pre><a name="checkIntegrity"></a>int <b>checkIntegrity</b> () const</pre>
    <dl>
      <dd><p>Checks the internal state of the object for integrity.</p>
        <p>The class has the following invariants:</p>
        <p><ul>
          <li>The length of the data is not larger than the allocated area</li>
          <li>If the length is not 0, a value must be allocated</li></ul></p></dd>
      <dd><dl><dt><b>Returns</b></dt>
            <dd>1 if the data is larger than the allocated memory,<br>
                2 if the length of the data is not 0, but no memory is reserved,<br>
                0 if the object is integer</dd></dl></dd>
    </dl>
  </body>
</html>
