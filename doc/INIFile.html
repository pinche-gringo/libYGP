<!-- -*-HTML-*- -->
<!-- $Id: INIFile.html,v 1.8 2003/02/17 03:19:24 markus Rel $ -->

<html>
  <head>
    <title>General Reference: INIFile</title>
    <meta name="description" content="Documentation of INIFile-classes">
    <meta name="keywords" content="Documentation, Docu, INI-file, section, INIFile, INISection, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-05-10">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center"><a name="INIFile">Class INIFile</a></h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information of an INI-file. In the first level this
      only includes reading of an INI-file and assigning the found values to
      some variables. In the future this might be enhanced to writing
      INI-files too.</p>

    <p>Technically this works by binding names (strings) to the addresses of
      variables (in attributes). Whenever a key matching those names is found,
      the apropiate value of the key is (tried to) assigned to the variable.</p>

    <p>This attributes are grouped into sections (every attribute principally
      belongs to a section. And a section ends with the start of a new
      section.). The result is an OS/2- and Windoze-like INI-file with
      the following syntax:</p>

    <pre>    [Section1]
    Attribute1=Value1
    Attribute2=2

    [Section2]
    Attribute3=01012000</pre>

    <p>There are some predefined macros to make the generation of the
      data-structure to parse an INI-file easier. They must be used in that
      (top-down) order.</p>

    <dl>
      <dt><b>INIFILE (file)</b></dt>
      <dd><p>Defines an object of type INIFile named _inifile_;</p></dd>
      <dt><b>INISECTION (name)</b></dt>
      <dd><p>Defines an object of type INISection. Both the defined variable and
          the section-name in the INI-file are called <i>name</i>.</p>
	<p><b>Note</b>: This macro defines a variable (of type
	  INISection) called <i>name</i>.</p></dd>
      <dt><b>INIATTR (section, type, name)</b></dt>
      <dd><p>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and (also) name <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
      <dt><b>INIATTR2 (section, type, attr, name)</b></dt>
      <dd><p>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and name <i>attr</i>.</p>
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
      <dt><b>INILIST(name)</b></dt>
      <dd><p>Defines a section to parse a list. Both the section and the variable
        containing the list are called name.</p>
      <dt><b>INILIST2(section, name)</b></dt>
      <dd><p>Defines a section to parse a list. The section in the INI file is called
          section and its values are stored in the array (vector) name.</p>
    </dl>

    <h3>Example to parse the INI-file (called <i>Test.ini</i>) above:</h3>


    <pre>    int Attribute1;
    std::string attr2;
    ADate Attribute3;

    INIFILE ("Test.ini");
    INISECTION (Section1);
    INIATTR (Attribute1, int, Attribute1);
    INIATTR2 (Local, std::string, attr2, Attribute2);
    INISECTION (Section2);
    INIATTR (Local, ADate, Attribute3);</pre>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="INIFile.html#IFaddEntity"><b>addEntity</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:navy">Entity</span></tt>&amp; <tt><span style="color:blue">obj</span></tt>, <a href="INIFile.html#INISection"><tt><span style="color:navy"><b>INISection</b></span></tt></a>&amp; <tt><span style="color:blue">section</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="INIFile.html#IFaddEntity2"><b>addEntity</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:navy">Entity</span></tt>&amp; <tt><span style="color:blue">obj</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">section</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="INIFile.html#IFaddSection"><b>addSection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="INIFile.html#INISection"><tt><span style="color:navy"><b>INISection</b></span></tt></a>&amp; <tt><span style="color:blue">section</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="INIFile.html#INISection"><tt><span style="color:navy"><b>INISection</b></span></tt></a>*</tt> </td>
        <td><a href="INIFile.html#IFaddSection2"><b>addSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">section</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><a href="XStream.html#Xifstream"><b>Xifstream</b></a></tt>&</tt> </td>
        <td><a href="INIFile.html#IFgetFile"><b>getFile</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#INIFile1"><b>INIFile</b></a></td>
        <td><tt>(const <span style="color:purple">char</span>* <span style="color:blue">name</span>) const throw (<span style="color:purple">std::string</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">void</span></tt></tt> </td>
        <td><a href="INIFile.html#IFread"><b>read</b></a></td>
        <td><tt>() const throw (<span style="color:purple">std::string</span>&amp;)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:purple;">void</span></tt></tt> </td>
        <td><a href="INIFile.html#write"><b>write</b></a></td>
        <td><tt>(<tt><span style="color:navy;">std::ostream</span></tt>&amp; <tt><span style="color:blue;">stream</span></tt>, <tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">section</span></tt>, <tt>const</tt> <a href="Entity.html"><tt><span style="color:navy;"><b>Entity</b></span></tt></a>&amp; <tt><span style="color:blue;">obj</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><span style="color:purple;">void</span></tt></tt> </td>
        <td><a href="INIFile.html#writeSectionHeader"><b>writeSectionHeader</b></a></td>
        <td><tt>(<tt><span style="color:navy;">std::ostream</span></tt>&amp; <tt><span style="color:blue;">stream</span></tt>, <tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">section</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INIFile"><b>~INIFile</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="INIFile.html#INISection"><tt><span style="color:navy"><b>INISection</b></span></tt></a>*</tt> </td>
        <td><a href="INIFile.html#IFfindSection"><b>findSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">name</span></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="INIFile.html#IFfoundSection"><b>foundSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">section</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><span style="color:navy">Management functions</span></h3>
    <pre><a name="INIFile1"></a><b>INIFile</b> (const char* filename) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor; The parameter filename specifies the file to parse
	  for initialization-information. If this file does not exist, an
	  exception is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of the INI file</dd>
      </dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd><code>name</code> must be an ASCIIZ-string</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>string: If file couldn't be open a text describing the error</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~INIFile"></a> <b>~INIFile</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>

    <pre><a name="IFaddSection"></a>void <b>addSection</b> (const <a href="INIFile.html#INISection"><b>INISection</b></a>&amp; section) </pre>
    <dl>
      <dd><p>Adds the passed section to the list of sections to parse.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Specification of the section</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="IFaddSection2"></a><a href="INIFile.html#INISection"><b>INISection</b></a>* <b>addSection</b> (const char* section) </pre>
    <dl>
      <dd><p>Adds a section to parse to the INI-file; does nothing if section already exists
</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Name of the section</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>INISection*: Pointer to new (or existing) section</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="IFaddEntity"></a>void <b>addEntity</b> (const <a href="Entity.html"><b>Entity</b></a>&amp; obj, <a href="INIFile.html#INISection"><b>INISection</b></a>&amp; section) </pre>
    <dl>
      <dd><p>Adds all the attributes of the Entity to the passed section</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose attributes should be added</dd>
          <dd><code>section</code>: Section where to add the attributes</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="IFaddEntity2"></a>void <b>addEntity</b> (const <a href="Entity.html"><b>Entity</b></a>&amp; obj, const char* section) </pre>
    <dl>
      <dd><p>Adds all the attributes of the Entity to the passed section</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose attributes should be added</dd>
          <dd><code>section</code>: Name of section (ASCIIZ string) where to add the attributes</dd>
      </dl></dd>
    </dl>

    <hr>
    <pre><a name="IFgetFile"></a><a href="XStream.html#Xifstream"><b>Xifstream</b></a>&amp; <b>getFile</b> ()</pre>
    <dl>
      <dd><p>Adds all the attributes of the Entity to the passed section</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd><a href="XStream.html#Xifstream"><b>Xifstream</b></a>&amp;: File which is parsed
</dd></dl></dd>
    </dl>

    <h3><span style="color:navy">Output</span></h3>
    <pre><a name="write"></a>void <b>write</b> (std::ostream&amp; stream, const char* section, const Entity&amp; obj)</pre> 
    <dl>
      <dd><p>Writes an entity to the INI-file. Every attribute of the object
            is written as <code>name=value</code>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: File to write to</dd>
          <dd><code>section</code>: Name of the section for all attributes in the object</dd>
          <dd><code>obj</code>: Object to write</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>There is no error-handling; failures are silently ignored!</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="writeSectionHeader"></a>void <b>writeSectionHeader</b> (std::ostream&amp; stream, const char* section)</pre> 
    <dl>
      <dd><p>Writes the header of a section. This consists of the (passed) name of the
            section in brackets.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: File to write to</dd>
          <dd><code>section</code>: Name of the section for all attributes in the object</dd>
          <dd><code>obj</code>: Object to write</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>There is no error-handling; failures are silently ignored!</dd></dl></dd>
    </dl>

    <h3><span style="color:navy">Parsing</span></h3>
    <pre><a name="IFread"></a>int <b>read</b> () throw (std::string) </pre>
    <dl>
      <dd><p>Tries to read the INI-file from the file.</p>
	<p>First the section header is parsed. If the name of the section from
	  the file is found in the list of sections, those sections are parsed.</p>
	<p>This step is repeated, until the end of the file is reached or a line
	  is found which is neither a section-header, nor an attribute.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF is reached; else
	  a non-zero value is returned or - depending on the error - an
	  exception is thrown.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status of reading: <0 hard error; 0 OK, >0 soft error
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>string: Message describing error in case of an invalid value
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="IFfoundSection"></a>int <b>foundSection</b> (const char* section, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is the check, if a section with the same name (case-sensitive!)
	is found within the entries of the object. If yes, its attributes are
	parsed.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Name of found section</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if name of <code>section</code> is OK, else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="IFfindSection"></a>const <a href="INIFile.html#INISection"><b>INISection</b></a>* <b>findSection</b> (const char* name) const </pre>
    <dl>
      <dd><p>Searches the entries of the INI-file-object for a section with the
	passed name. If a matching entry is found, a pointer to it is returned;
	else NULL.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of section to find</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Section*: Pointer to section or NULL (if not found)
</dd></dl></dd>
    </dl>

    <hr noshade><a name="INISection"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>
 
    <h1 align="center">Class INISection</h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by: <a href="INIFile.html#INIList">INIList</a></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information stored in a section of an INI-file.</p>
    <p>Usually this class is just used to bundle the attributes of a section
      together; none of their members is called directly. The only exception
      is for INI-files without any section, only with attributes. In that case
      the <a href="INIFile.html#ISreadAttributes"><b>readAttributes</b></a>-member can
      be used to parse those values (regardless of any header-information).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="INIFile.html#INISection1"><b>INISection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">name</span></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt>void</tt></td>
        <td><a href="INIFile.html#ISaddAttribute"><b>addAttribute</b></a></td>
        <td><tt>(const <span style="color:purple"><a href="Attribute.html"><b>IAttribute</b></a></span>&amp; <span style="color:blue">attribute</span>) throw (<span style="color:purple">std::string</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="Attribute.html"><tt><span style="color:navy"><b>IAttribute</b></span></tt></a>*</tt> </td>
        <td><a href="INIFile.html#ISfindAttribute2"><b>findAttribute</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">std::string</span></tt>&amp; <tt><span style="color:blue">name</span></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="Attribute.html"><tt><span style="color:navy"><b>IAttribute</b></span></tt></a>*</tt> </td>
        <td><a href="INIFile.html#ISfindAttribute"><b>findAttribute</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">name</span></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>const</tt> <tt><span style="color:purple">char</span></tt>*</tt> </td>
        <td><a href="INIFile.html#ISgetName"><b>getName</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><span style="color:purple">bool</span></tt></tt> </td>
        <td><a href="INIFile.html#ISmatches"><b>matches</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">name</span></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><span style="color:purple">int</span></tt></td>
        <td><a href="INIFile.html#ISreadAttributes"><b>readAttributes</b></a></td>
        <td><tt>(<span style="color:purple"><a href="XStream.html#Xistream"><b>Xistream</b></a></span>&amp; <span style="color:blue">result</span>) throw (<span style="color:purple">std::string</span>)</tt>;</td></tr>
      <tr valign="top"><td><tt><span style="color:purple">int</span></tt></td>
        <td><a href="INIFile.html#ISreadFromStream"><b>readFromStream</b></a></td>
        <td><tt>(<span style="color:purple"><a href="XStream.html#Xistream"><b>Xistream</b></a></span>&amp; <span style="color:blue">result</span>) throw (<span style="color:purple">std::string</span>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INISection"><b>~INISection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>

      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundKey"><b>foundKey</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">key</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundSection"><b>foundSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">section</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundValue"><b>foundValue</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><span style="color:navy">Management functions</span></h3>
    <pre><a name="INISection1"></a><b>INISection</b> (const char* name)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the section.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of section</dd>
      </dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd><code>name</code> must be a valid ASCIIZ-string (not NULL).
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~INISection"></a><b>~INISection</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>

    <pre><a name="ISaddAttribute"></a>void <b>addAttribute</b> (const <a href="Attribute.html"><b>IAttribute</b></a>&amp; attribute) </pre>
    <dl>
      <dd><p>Adds an attribute to parse to the section</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>attribute</code>: Attribute to add</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="ISgetName"></a>const char* <b>getName</b> () const</pre>
    <dl>
      <dd><p>Returns the name of the section.</p></dd>
    </dl>
    <hr>
    <pre><a name="ISmatches"></a>bool <b>matches</b> (const char* name) const</pre>
    <dl>
      <dd><p>Checks if the passed name matches (case-sensitive!) the name of the
	section.</p></dd>
    </dl>
    <hr>

    <pre><a name="ISIAttribute*"></a>const IAttribute* <b>findAttribute</b> (const char* name) const </pre>
    <dl>
      <dd><p>Searches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of attribute to find</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>IAttribute*: Pointer to attribute or NULL (if not found)
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>name must not be a NULL pointer
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISfindAttribute2"></a>const IAttribute* <b>findAttribute</b> (const std::string&amp; name) const </pre>
    <dl>
      <dd><p>TriesSearches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of attribute to find</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>IAttribute*: Pointer to attribute or NULL (if not found)
</dd></dl></dd>
    </dl>

    <h3><span style="color:navy">Parsing</span></h3>
    <pre><a name="ISreadFromStream"></a>int <b>readFromStream</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string) </pre>
    <dl>
      <dd><p>Tries to read the (whole) section from the INI-file.</p>
	<p>First the section header is parsed. Note that the name of the
	  section in the INI-file must match those of the class.</p>
	<p>If the header can be parsed successfully, every following
	  key=value pair is inspected and - if key matches an attribute
	  in the section - assigned.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header is reached. Errors are returned (or execeptions are
	  thrown) if either the section-name differ or the attribute is either
	  not found inside the class or the value can note be assigned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Extended stream to read from</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int:  ParseObject::OK if a know key is found and it's value can be assigned
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>The exact behaviour depends on the type of the attribute!
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: Text describing error if an unrecoverable error
 occurs
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISreadAttributes"></a>int <b>readAttributes</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string) </pre>
    <dl>
      <dd><p>Tries to read the attributes of a section from the INI-file.</p>
	<p>Every key=value pair is inspected and - if key matches the
	  name of an attribute in the section - assigned to the connected
	  variable.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header (to be exact: Anything which is not a key) is reached.
	  Errors are returned (or execeptions are thrown) if the attribute is
	  either not found inside the class or the value can not be assigned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Extended stream to read from</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int:  ParseObject::OK if a know key is found and it's value can be assigned
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>The exact behaviour depends on the type of the attribute!
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: Text describing error if an unrecoverable error occurs
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="ISfoundSection"></a>int <b>foundSection</b> (const char* section, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is to check, if the section matches (case-sensitive!) the
	passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Name of found section</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if name of <code>section</code> is OK, else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISfoundKey"></a>int <b>foundKey</b> (const char* key, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a key of an attribute has been found. Every attribute of
	the section is compared with the passed key. If they match the value of
	the key is assigned to the attribute.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>key</code>: Name of the found key</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if <code>key</code> is found; else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISfoundValue"></a>int <b>foundValue</b> (const char* value, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a value of an attribute has been found. This value is
	  assigned using the virtual
	  <a href="INIFile.html#IAassign"><b>assign</b></a>-member
	  of <a href="Attribute.html"><b>IAttribute</b></a>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Value to assign to the (previously) found attribute</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if <code>value</code> could be assigned successfully; else ParseObject::PARSE_CB_ABORT</dd></dl></dd>
    </dl>

    <hr noshade><a name="INIList"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>
 
    <h1 align="center">Class INIList</h1>
    <p>Derived from:
      <a href="INIFile.html#INISection">INISection</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to parse all entries of a section into a list (vector) of values</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="INIFile.html#INIList1"><b>INIList</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">name</span></tt>, <tt>const</tt> <tt><span style="color:navy">std::vector&lt;T&gt;</span></tt>&amp; <tt><span style="color:blue">values</span></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt>void</tt></td>
        <td><a href="INIFile.html#ILwrite"><b>write</b></a></td>
        <td><tt>(<tt><span style="color:purple">ostream</span></tt>&amp; <tt><span style="color:blue">stream</span></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt>void</tt></td>
        <td><a href="INIFile.html#ILwrite2"><b>write</b></a></td>
        <td><tt>(<tt><span style="color:purple">ostream</span></tt>&amp; <tt><span style="color:blue">stream</span></tt>, <tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">section</span></tt>, <tt>const</tt> <tt><span style="color:navy">std::vector&lt;T&gt;</span></tt>&amp; <tt><span style="color:blue">values</span></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INIList"><b>~INIList</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>

      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="INIFile.html#ILfoundKey"><b>foundKey</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">key</span></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple">int</span></tt></tt> </td>
        <td><a href="INIFile.html#ILfoundValue"><b>foundValue</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple">char</span></tt>* <tt><span style="color:blue">value</span></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><span style="color:navy">Management functions</span></h3>
    <pre><a name="INIList1"></a><b>INIList</b> (const char* name, std::vector&lt;T&gt;&amp; values)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the section.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of section</dd>
      </dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd><code>name</code> must be a valid ASCIIZ-string (not NULL).</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~INIList"></a><b>~INIList</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>

    <pre><a name="ILfoundKey"></a>int <b>foundKey</b> (const char* key, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a key of an attribute has been found. The key must be a
         numeric value specifying the index of an element in the list.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>key</code>: Index of an element</dd>
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if <code>key</code> is numeric; else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ILfoundValue"></a>int <b>foundValue</b> (const char* value, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a value of an element of the list has been found. This value is
	  assigned using the virtual
	  <a href="INIFile.html#IAassign"><b>assign</b></a>-member
	  of <a href="Attribute.html"><b>IAttribute</b></a>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Value to assign to the (previously) found attribute
      </dl></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if <code>value</code> could be assigned successfully; else ParseObject::PARSE_CB_ABORT</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ILwrite"></a>void <b>write</b> (ostream&amp; stream) </pre>
    <dl>
      <dd><p>Writes the list in an INI-file like manner to the stream.</p>
        <p>The entries are written in the form <code>index=value</code>; starting
          with an index of 0.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Stream to write to</dd>
      </dl></dd>
    </dl>
    <hr>
    <pre><a name="ILwrite2"></a>void <b>write</b> (ostream&amp; stream, const char* section, const std::vector&lt;T&gt;&amp; values) </pre>
    <dl>
      <dd><p>Writes the list in an INI-file like manner to the stream.</p>
        <p>The entries are written in the form <code>index=value</code>; starting
          with an index of 0.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Stream to write to</dd>
      </dl></dd>
    </dl>
  </body>
</html>
