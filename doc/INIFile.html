<!-- -*-HTML-*- -->

<!-- $Id: INIFile.html,v 1.4 2002/04/11 19:05:48 markus Rel $ -->

<html>
  <head>
    <title>General Reference: INIFile</title>
    <meta name="description" content="Documentation of INIFile-classes">
    <meta name="keywords" content="Documentation, Docu, INI-file, section, INIFile, INISection, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-05-10">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center"><a name="INIFile">Class INIFile</a></h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information of an INI-file. In the first level this
      only includes reading of an INI-file and assigning the found values to
      some variables. In the future this might be enhanced to writing
      INI-files too.</p>

    <p>Technically this works by binding names (strings) to the addresses of
      variables (in attributes). Whenever a key matching those names is found,
      the apropiate value of the key is (tried to) assigned to the variable.</p>

    <p>This attributes can be further grouped by sections (where every
      attribute must belong to a section). The result is a OS/2- and
      Windoze-like INI-file with the following syntax:</p>

    <pre>    [Section1]
    Attribute1=Value1
    Attribute2=2

    [Section2]
    Attribute3=01012000</pre>

    <p>There are some predefined macros to make the generation of the
      data-structure to parse an INI-file easier. They must be used in that
      (top-down) order.</p>

    <dl>
      <dt><b>INIFILE (file)</b></dt>
      <dd>Defines an object of type INIFile named _inifile_;<br>&nbsp;</dd>
      <dt><b>INISECTION (name)</b></dt>
      <dd>Defines an object of type INISection. Both the defined variable and
	the section-name in the INI-file are called <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INISection) called <i>name</i>.</p></dd>
      <dt><b>INIATTR (section, type, name)</b></dt>
      <dd>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and (also) name <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
      <dt><b>INIATTR2 (section, type, attr, name)</b></dt>
      <dd>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and name <i>attr</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
    </dl>

    <p>Example to parse the INI-file (called <i>Test.ini</i> above:</p>


    <pre>    int Attribute1;
    std::string attr2;
    ADate Attribute3;

    INIFILE ("Test.ini");
    INISECTION (Section1);
    INIATTR (Attribute1, int, Attribute1);
    INIATTR2 (Local, std::string, attr2, Attribute2);
    INISECTION (Section2);
    INIATTR (Local, ADate, Attribute3);</pre>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#INIFile1"><b>INIFile</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">name</font>) const throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="INIFile.html#IFaddSection"><b>addSection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="INIFile.html#INISection"><tt><font color="navy"><b>INISection</b></font></tt></a>&amp; <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="INIFile.html#IFread"><b>read</b></a></td>
        <td><tt>() const throw (<font color="purple">std::string</font>&amp;)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INIFile"><b>~INIFile</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="INIFile.html#INISection"><tt><font color="navy"><b>INISection</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#IFfindSection"><b>findSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#IFfoundSection"><b>foundSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="INIFile1"></a>INIFile (const char* filename) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor; The parameter filename specifies the file to parse
	  for initialization-information. If this file does not exist, an
	  exception is thrown.</p>
        <p><b>Note</b>: Depending on the operating system the filename might or
	  might not be case-sensitive!
    </dl>
    <pre><a name="~INIFile"></a>~INIFile ()</pre>

   <pre><a name="IFaddSection"></a>void addSection (const <a href="INIFile.html#INISection">INISection</a>&amp; section)</pre>
    <dl>
      <dd>
	<p>Adds a section to the list of sections to parse. In the
	  debug-version of the library (when the macro <i>NDEBUG</i> is
	  defined) it is checked, if the name of the section is unique.
	  Doubles are reported with an exception.</p></dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="IFread"></a>int read () throw (std::string)</pre>
    <dl>
      <dd>
	<p>Tries to read the INI-file from the file.</p>
	<p>First the section header is parsed. If the name of the section from
	  the file is found in the list of sections, those sections are parsed.</p>
	<p>This step is repeated, til the end of the file is reached or a line
	  is found which is neither a section-header, nor an attribute.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF is reached; else
	  a non-zero value is returned or - depending on the error - an
	  exception is thrown.</p></dd>
    </dl>

    <pre><a name="IFfoundSection"></a>virtual int foundSection (const char* section)</pre>
    <dl>
      <dd>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is the check, if a section with the same name (case-sensitive!)
	is found within the entries of the object. If yes, their attributes are
	parsed.</dd>
    </dl>

    <pre><a name="IFfindSection"></a>const <a href="INIFile.html#INISection">INISection</a>* findSection (const char* name) const</pre>
    <dl>
      <dd>Searches the entries of the INI-file-object for a section with the
	passed name. If a matching entry is found, a pointer to it is returned;
	else NULL.</dd>
    </dl>

    <hr noshade><a name="INISection"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>
 
    <h1 align="center">Class INISection</h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information stored in a section of an INI-file.</p>
    <p>Usually this class is just used to bundle the attributes of a section
      together; none of their members is called directly. The only exception
      is for INI-files without any section, only with attributes. In that case
      the <a href="INIFile.html#ISreadAttributes"><b>readAttributes</b></a>-member can
      be used to parse those values (regardless of any header-information).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="INIFile.html#INISection"><b>INISection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt>void</tt></td>
        <td><a href="INIFile.html#ISaddAttribute"><b>addAttribute</b></a></td>
        <td><tt>(const <font color="purple"><a href="Attribute.html"><b>IAttribute</b></a></font>&amp; <font color="blue">attribute</font>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="Attribute.html"><tt><font color="navy"><b>IAttribute</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#ISfindAttribute2"><b>findAttribute</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">std::string</font></tt>&amp; <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="Attribute.html"><tt><font color="navy"><b>IAttribute</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#ISfindAttribute"><b>findAttribute</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>const</tt> <tt><font color="purple">char</font></tt>*</tt> </td>
        <td><a href="INIFile.html#ISgetName"><b>getName</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="INIFile.html#ISmatches"><b>matches</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><font color="purple">int</font></tt></td>
        <td><a href="INIFile.html#ISreadAttributes"><b>readAttributes</b></a></td>
        <td><tt>(<font color="purple"><a href="XStream.html#Xistream"><b>Xistream</b></a></font>&amp; <font color="blue">result</font>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><font color="purple">int</font></tt></td>
        <td><a href="INIFile.html#ISreadFromStream"><b>readFromStream</b></a></td>
        <td><tt>(<font color="purple"><a href="XStream.html#Xistream"><b>Xistream</b></a></font>&amp; <font color="blue">result</font>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INISection"><b>~INISection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>

      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundKey"><b>foundKey</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">key</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundSection"><b>foundSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundValue"><b>foundValue</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="INISection2"></a>INISection (const char* name)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the section and must not be NULL.</p></dd>
    </dl>
    <pre><a name="~INISection"></a>~INISection ()</pre>

    <pre><a name="ISaddAttribute"></a>void addAttribute (const <a href="Attribute.html"><b>IAttribute</b></a>&amp; attribute) throw (std::string)</pre>
    <dl>
      <dd><p>Adds an attribute to parse to the section. In the debug-version an
	  exception is thrown, if an attribute with the same name already
	  exists.</p></dd>
    </dl>

    <pre><a name="ISgetName"></a>const char* getName () const</pre>
    <dl>
      <dd>Returns the name of the section.</dd>
    </dl>

    <pre><a name="ISmatches"></a>bool matches (const char* name) const</pre>
    <dl>
      <dd>Checks if the passed name matches (case-sensitive!) the name of the
	section.</dd>
    </dl>

    <pre><a name="ISfindAttribute"></a>const IAttribute* findAttribute (const char* name) const</pre>
    <dl>
      <dd>Searches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p>
    </dl>
    <pre><a name="ISfindAttribute2"></a>const IAttribute* findAttribute (const std::string&amp; name) const</pre>
    <dl>
      <dd>Searches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p>
    </dl>
    

    <h4>Parsing</h4>
    <pre><a name="ISreadFromStream"></a>int readFromStream (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd>
	<p>Tries to read the (whole) section from the INI-file.</p>
	<p>First the section header is parsed. Note that the name of the
	  section in the INI-file must match those of the class.</p>
	<p>If the header can be parsed successfully, every following
	  <i>key=value</i>-pair is inspected and - if key matches an attribute
	  in the section - assigned.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header is reached. Errors are returned (or execeptions are
	  thrown) if either the section-name differ or the attribute is either
	  not found inside the class or the value can note be assigned.</p>
	<p><b>Note</b>: The exact behaviour depends on the type of the
	  attribute!</dd>
    </dl>
    <pre><a name="ISreadAttributes"></a>int readAttributes (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd>
	<p>Tries to read the attributes of a section from the INI-file.</p>
	<p>Every <i>key=value</i>-pair is inspected and - if key matches the
	  name of an attribute in the section - assigned to the connected
	  variable.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header (to be exact: Anything which is not a key) is reached.
	  Errors are returned (or execeptions are thrown) if the attribute is
	  either not found inside the class or the value can not be assigned.</p>
	<p><b>Note</b>: The exact behaviour depends on the type of the
	  attribute!</dd>
    </dl>

    <pre><a name="ISfoundSection"></a>virtual int foundSection (const char* section)</pre>
    <dl>
      <dd>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is the check, if the section matches (case-sensitive!) the
	passed parameter. The method reports this result by either
	ParseObject::PARSE_OK or ParseObject::PARSE_CB_ABORT.</dd>
    </dl>

    <pre><a name="ISfoundKey"></a>virtual int foundKey (const char* key)</pre>
    <dl>
      <dd>Callback if a key of an attribute has been found. Every attribute of
	the section is compared with the passed key. If they match the value of
	the key is assigned to the attribute-variable and ParseObject::PARSE_OK
	is returned; else ParseObject::PARSE_CB_ABORT.</dd>
    </dl>

    <pre><a name="ISfoundValue"></a>virtual int foundValue (const char* value)</pre>
    <dl>
      <dd><p>Callback if a value of an attribute has been found. This value is
	  assigned using the pure-virtual
	  <a href="INIFile.html#IAassignFromString"><b>assignFromString</b></a>-member
	  of <a href="Attribute.html"><b>IAttribute</b></a>.</p>
	<p>This method is defined in templatized subclasses of
	  <a href="Attribute.html"><b>IAttribute</b></a> for the
	  standard C types (int, double and the like), std::string, classes
	  derived from <a href="AttrVal.html"><b>AttributValues</b></a> and everything
	  having an <i>operator=(const char*)</i>-member to assign values and
	  a <i>isDefined ()</i>-member the check for conistency; to enhance
	  that for other types simply define  
	  <a href="Attribute.html"><b>IAttribute</b></a>::<a href="Attribute.html#assignFromString"><b>assignFromString</b></a>
	  for your class.</p>
	<p>If assigning the value succeeds,  ParseObject::PARSE_OK is returned;
	  else ParseObject::PARSE_CB_ABORT.</dd>
    </dl>
  </body>
</html>
