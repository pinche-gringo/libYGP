<!-- -*-HTML-*- -->

<!-- $Id: INIFile.html,v 1.5 2002/12/01 08:36:18 markus Exp $ -->

<html>
  <head>
    <title>General Reference: INIFile</title>
    <meta name="description" content="Documentation of INIFile-classes">
    <meta name="keywords" content="Documentation, Docu, INI-file, section, INIFile, INISection, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-05-10">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center"><a name="INIFile">Class INIFile</a></h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information of an INI-file. In the first level this
      only includes reading of an INI-file and assigning the found values to
      some variables. In the future this might be enhanced to writing
      INI-files too.</p>

    <p>Technically this works by binding names (strings) to the addresses of
      variables (in attributes). Whenever a key matching those names is found,
      the apropiate value of the key is (tried to) assigned to the variable.</p>

    <p>This attributes can be further grouped by sections (where every
      attribute must belong to a section). The result is a OS/2- and
      Windoze-like INI-file with the following syntax:</p>

    <pre>    [Section1]
    Attribute1=Value1
    Attribute2=2

    [Section2]
    Attribute3=01012000</pre>

    <p>There are some predefined macros to make the generation of the
      data-structure to parse an INI-file easier. They must be used in that
      (top-down) order.</p>

    <dl>
      <dt><b>INIFILE (file)</b></dt>
      <dd>Defines an object of type INIFile named _inifile_;<br>&nbsp;</dd>
      <dt><b>INISECTION (name)</b></dt>
      <dd>Defines an object of type INISection. Both the defined variable and
	the section-name in the INI-file are called <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INISection) called <i>name</i>.</p></dd>
      <dt><b>INIATTR (section, type, name)</b></dt>
      <dd>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and (also) name <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
      <dt><b>INIATTR2 (section, type, attr, name)</b></dt>
      <dd>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and name <i>attr</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
    </dl>

    <p>Example to parse the INI-file (called <i>Test.ini</i> above:</p>


    <pre>    int Attribute1;
    std::string attr2;
    ADate Attribute3;

    INIFILE ("Test.ini");
    INISECTION (Section1);
    INIATTR (Attribute1, int, Attribute1);
    INIATTR2 (Local, std::string, attr2, Attribute2);
    INISECTION (Section2);
    INIATTR (Local, ADate, Attribute3);</pre>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="INIFile.html#IFaddEntity"><b>addEntity</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">Entity</font></tt>&amp; <tt><font color="blue">obj</font></tt>, <a href="INIFile.html#INISection"><tt><font color="navy"><b>INISection</b></font></tt></a>& <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="INIFile.html#IFaddEntity2"><b>addEntity</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">Entity</font></tt>&amp; <tt><font color="blue">obj</font></tt>, <tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="INIFile.html#IFaddSection"><b>addSection</b></a></td>
        <td><tt>(<tt>const</tt> <a href="INIFile.html#INISection"><tt><font color="navy"><b>INISection</b></font></tt></a>&amp; <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="INIFile.html#INISection"><tt><font color="navy"><b>INISection</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#IFaddSection2"><b>addSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><a href="XStream.html#Xifstream"><b>Xifstream</b></a></tt>&</tt> </td>
        <td><a href="INIFile.html#IFgetFile"><b>getFile</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#INIFile1"><b>INIFile</b></a></td>
        <td><tt>(const <font color="purple">char</font>* <font color="blue">name</font>) const throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="INIFile.html#IFread"><b>read</b></a></td>
        <td><tt>() const throw (<font color="purple">std::string</font>&amp;)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INIFile"><b>~INIFile</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="INIFile.html#INISection"><tt><font color="navy"><b>INISection</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#IFfindSection"><b>findSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#IFfoundSection"><b>foundSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><font color="navy">Management functions</font></h3>
    <pre><a name="INIFile1"></a><b>INIFile</b> (const char* filename) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor; The parameter filename specifies the file to parse
	  for initialization-information. If this file does not exist, an
	  exception is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of the INI file<dd>
      </dl><dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd><code>name</code> must be an ASCIIZ-string
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>string: If file couldn't be open a text describing the error
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~INIFile"></a> <b>~INIFile</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>

    <pre><a name="IFaddSection"></a>void <b>addSection</b> (const INISection& section) </pre>
    <dl>
      <dd><p>Adds the passed section to the list of sections to parse.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Specification of the section<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="IFaddSection2"></a>INISection* <b>addSection</b> (const char* section) </pre>
    <dl>
      <dd><p>Adds a section to parse to the INI-file; does nothing if section already exists
</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Name of the section<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>INISection*: Pointer to new (or existing) section
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="IFaddEntity"></a>void <b>addEntity</b> (const <a href="Entity.html"><b>Entity</b></a>& obj, <a href="INIFile.html#INISection"><b>INISection</b></a>& section) </pre>
    <dl>
      <dd><p>Adds all the attributes of the Entity to the passed section</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose attributes should be added<dd>
          <dd><code>section</code>: Section where to add the attributes<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="IFaddEntity2"></a>void <b>addEntity</b> (const <a href="Entity.html"><b>Entity</b></a>& obj, const char* section) </pre>
    <dl>
      <dd><p>Adds all the attributes of the Entity to the passed section</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>obj</code>: Object whose attributes should be added<dd>
          <dd><code>section</code>: Name of section (ASCIIZ string) where to add the attributes<dd>
      </dl><dd>
    </dl>

    <hr>
    <pre><a name="IFgetFile"></a><a href="XStream.html#Xifstream"><b>Xifstream</b></a>&amp; <b>getFile</b> ()</pre>
    <dl>
      <dd><p>Adds all the attributes of the Entity to the passed section</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd><a href="XStream.html#Xifstream"><b>Xifstream</b></a>&amp;: File which is parsed
</dd></dl></dd>
    </dl>

    <h3><font color="navy">Parsing</font></h3>
    <pre><a name="IFread"></a>int <b>read</b> () throw (std::string) </pre>
    <dl>
      <dd><p>Tries to read the INI-file from the file.</p>
	<p>First the section header is parsed. If the name of the section from
	  the file is found in the list of sections, those sections are parsed.</p>
	<p>This step is repeated, until the end of the file is reached or a line
	  is found which is neither a section-header, nor an attribute.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF is reached; else
	  a non-zero value is returned or - depending on the error - an
	  exception is thrown.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status of reading: <0 hard error; 0 OK, >0 soft error
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>string: Message describing error in case of an invalid value
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="IFfoundSection"></a>int <b>foundSection</b> (const char* section, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is the check, if a section with the same name (case-sensitive!)
	is found within the entries of the object. If yes, its attributes are
	parsed.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Name of found section<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if name of <code>section</code> is OK, else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="IFfindSection"></a>const <a href="INIFile.html#INISection">INISection</a>* <b>findSection</b> (const char* name) const </pre>
    <dl>
      <dd><p>Searches the entries of the INI-file-object for a section with the
	passed name. If a matching entry is found, a pointer to it is returned;
	else NULL.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of section to find<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Section*: Pointer to section or NULL (if not found)
</dd></dl></dd>
    </dl>

    <hr noshade><a name="INISection"></a>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>
 
    <h1 align="center">Class INISection</h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;INIFile.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information stored in a section of an INI-file.</p>
    <p>Usually this class is just used to bundle the attributes of a section
      together; none of their members is called directly. The only exception
      is for INI-files without any section, only with attributes. In that case
      the <a href="INIFile.html#ISreadAttributes"><b>readAttributes</b></a>-member can
      be used to parse those values (regardless of any header-information).</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="INIFile.html#INISection"><b>INISection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt>void</tt></td>
        <td><a href="INIFile.html#ISaddAttribute"><b>addAttribute</b></a></td>
        <td><tt>(const <font color="purple"><a href="Attribute.html"><b>IAttribute</b></a></font>&amp; <font color="blue">attribute</font>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="Attribute.html"><tt><font color="navy"><b>IAttribute</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#ISfindAttribute2"><b>findAttribute</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">std::string</font></tt>&amp; <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>const</tt> <a href="Attribute.html"><tt><font color="navy"><b>IAttribute</b></font></tt></a>*</tt> </td>
        <td><a href="INIFile.html#ISfindAttribute"><b>findAttribute</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>const</tt> <tt><font color="purple">char</font></tt>*</tt> </td>
        <td><a href="INIFile.html#ISgetName"><b>getName</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="INIFile.html#ISmatches"><b>matches</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">name</font></tt>) <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><font color="purple">int</font></tt></td>
        <td><a href="INIFile.html#ISreadAttributes"><b>readAttributes</b></a></td>
        <td><tt>(<font color="purple"><a href="XStream.html#Xistream"><b>Xistream</b></a></font>&amp; <font color="blue">result</font>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>
      <tr valign="top"><td><tt><font color="purple">int</font></tt></td>
        <td><a href="INIFile.html#ISreadFromStream"><b>readFromStream</b></a></td>
        <td><tt>(<font color="purple"><a href="XStream.html#Xistream"><b>Xistream</b></a></font>&amp; <font color="blue">result</font>) throw (<font color="purple">std::string</font>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="INIFile.html#~INISection"><b>~INISection</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>

      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundKey"><b>foundKey</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">key</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundSection"><b>foundSection</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">section</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="INIFile.html#ISfoundValue"><b>foundValue</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">value</font></tt>)</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><font color="navy">Management functions</font></h3>
    <pre><a name="INISection2"></a><b>INISection</b> (const char* name)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the section.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of section<dd>
      </dl><dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd><code>name</code> must be a valid ASCIIZ-string (not NULL).
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~INISection"></a><b>~INISection</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>

    <pre><a name="ISaddAttribute"></a>void <b>addAttribute</b> (const <a href="Attribute.html"><b>IAttribute</b></a>&amp; attribute) </pre>
    <dl>
      <dd><p>Adds an attribute to parse to the section</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>attribute</code>: Attribute to add<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="ISgetName"></a>const char* <b>getName</b> () const</pre>
    <dl>
      <dd><p>Returns the name of the section.</p></dd>
    </dl>
    <hr>
    <pre><a name="ISmatches"></a>bool <b>matches</b> (const char* name) const</pre>
    <dl>
      <dd><p>Checks if the passed name matches (case-sensitive!) the name of the
	section.</p></dd>
    </dl>
    <hr>

    <pre><a name="ISIAttribute*"></a>const IAttribute* <b>findAttribute</b> (const char* name) const </pre>
    <dl>
      <dd><p>Searches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of attribute to find<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>IAttribute*: Pointer to attribute or NULL (if not found)
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>name must not be a NULL pointer
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISfindAttribute2"></a>const IAttribute* <b>findAttribute</b> (const std::string&amp; name) const </pre>
    <dl>
      <dd><p>TriesSearches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>name</code>: Name of attribute to find<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>IAttribute*: Pointer to attribute or NULL (if not found)
</dd></dl></dd>
    </dl>

    <h3><font color="navy">Parsing</font></h3>
    <pre><a name="ISreadFromStream"></a>int <b>readFromStream</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string) </pre>
    <dl>
      <dd><p>Tries to read the (whole) section from the INI-file.</p>
	<p>First the section header is parsed. Note that the name of the
	  section in the INI-file must match those of the class.</p>
	<p>If the header can be parsed successfully, every following
	  key=value pair is inspected and - if key matches an attribute
	  in the section - assigned.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header is reached. Errors are returned (or execeptions are
	  thrown) if either the section-name differ or the attribute is either
	  not found inside the class or the value can note be assigned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Extended stream to read from<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int:  ParseObject::OK if a know key is found and it's value can be assigned
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>The exact behaviour depends on the type of the attribute!
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: Text describing error if an unrecoverable error
 occurs
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISreadAttributes"></a>int <b>readAttributes</b> (<a href="XStream.html#Xistream"><b>Xistream</b></a>&amp; stream) throw (std::string) </pre>
    <dl>
      <dd><p>Tries to read the attributes of a section from the INI-file.</p>
	<p>Every key=value pair is inspected and - if key matches the
	  name of an attribute in the section - assigned to the connected
	  variable.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header (to be exact: Anything which is not a key) is reached.
	  Errors are returned (or execeptions are thrown) if the attribute is
	  either not found inside the class or the value can not be assigned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>stream</code>: Extended stream to read from<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int:  ParseObject::OK if a know key is found and it's value can be assigned
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>The exact behaviour depends on the type of the attribute!
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: Text describing error if an unrecoverable error occurs
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="ISfoundSection"></a>int <b>foundSection</b> (const char* section, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is to check, if the section matches (case-sensitive!) the
	passed parameter.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>section</code>: Name of found section<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if name of <code>section</code> is OK, else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISfoundKey"></a>int <b>foundKey</b> (const char* key, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a key of an attribute has been found. Every attribute of
	the section is compared with the passed key. If they match the value of
	the key is assigned to the attribute.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>key</code>: Name of the found key<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if <code>key</code> is found; else ParseObject::PARSE_CB_ABORT.
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ISfoundValue"></a>int <b>foundValue</b> (const char* value, unsigned int) </pre>
    <dl>
      <dd><p>Callback if a value of an attribute has been found. This value is
	  assigned using the virtual
	  <a href="INIFile.html#IAassign"><b>assign</b></a>-member
	  of <a href="Attribute.html"><b>IAttribute</b></a>.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>value</code>: Value to assign to the (previously) found attribute
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: PARSE_OK, if <code>value</code> could be assigned successfully; else ParseObject::PARSE_CB_ABORT
</dd></dl></dd>
    </dl>
  </body>
</html>
