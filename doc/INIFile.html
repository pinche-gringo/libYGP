<!-- $Id: INIFile.html,v 1.1 2000/05/11 21:56:05 Markus Exp $ -->

<html>
  <head>
    <title>General Reference: INIFile</title>
    <meta name="description" content="Documentation of INIFile-classes">
    <meta name="keywords" content="Documentation, Docu, INI-file, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-05-10">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td></tr>
    </table>

    <h1 align="center"><a name="INIFile">Class INIFile</a></h1>
    <p>Derived from: <i>None</i></p>

    <p>Header-file: INIFile.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information of an INI-file. In the first level this
      only includes reading of an INI-file and assigning the found values to
      some variables. In the future this might be enhanced to writing
      INI-files too.</p>
    <p>Technically this works by binding names (strings) to the addresses of
      variables (in attributes). Whenever a key matching those names is found,
      the apropiate value of the key is (tried to) assigned to the variable.</p>
    <p>This attributes can be further grouped by sections. The result is a
      OS/2- and Windoze-like INI-file with the following syntax:</p>
    <pre>    [Special]
    Attr1=1
    Attr2=This is a test!

    [Common]
    Attr3=29.2.2000</pre>

    <p>There are some predefined macros to make the generation of the
      data-structure to parse an INI-file easier. They must be used in that
      (top-down) order.</p>

    <dl>
      <dt><b>INIFILE (file)</b></dt>
      <dd>Defines an object of type INIFile named _inifile_;<br>&nbsp;</dd>
      <dt><b>INISECTION (name)</b></dt>
      <dd>Defines an object of type INISection. Both the defined variable and
	the section-name in the INI-file are called <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INISection) called <i>name</i>.</p></dd>
      <dt><b>INIATTR (section, type, name)</b></dt>
      <dd>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and (also) name <i>name</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
      <dt><b>INIATTR2 (section, type, attr, name)</b></dt>
      <dd>Defines an attribute for section <i>section</i> having the key
	  (in the INI-file) of <i>name</i>. The value of this key is assigned
	  to a variable of type <i>type</i> and name <i>attr</i>.
	<p><b>Note</b>: This macro defines a variable (of type
	  INIAttribute&lt;type&gt;) called <i>name_</i>.</p></dd>
    </dl>

    <p>Example to parse the INI-file above:</p>


    <pre>    int Attr1;
    std::string attr2;
    ADate Attr3

    INIFILE ("Test.ini");
    INISECTION (Special);
    INIATTR (Local, int, Attr1);
    INIATTR2 (Local, std::string, attr2, Attr2);
    INISECTION (Common);
    INIATTR (Local, ADate, Attr3);</pre>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#INIFile1">INIFile</a></td>
        <td>(const char* filename) throw (std::string)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="INIFile.html#~INIFile">~INIFile</a></td><td>()</td></tr>

      <tr valign="top"><td>void</td>
        <td><a href="INIFile.html#IFaddSection">addSection</a></td>
	<td>(const <a href="INIFile.html#INISection">INISection</a>&amp; section)</td></tr>
      <tr valign="top"><td>int</td>
        <td><a href="INIFile.html#IFread">read</a></td><td>() throw (std::string)</td></tr>

      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="INIFile.html#IFfoundSection">foundSection</a></td>
	<td>(const char* section)</td></tr>
      <tr valign="top"><td>const <a href="INIFile.html#INISection">INISection</a>*</td>
        <td><a href="INIFile.html#IFfindSection">findSection</a></td>
	<td>(const char* name) const</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="INIFile1"></a>INIFile (const char* filename) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor; The parameter filename specifies the file to parse
	  for initialization-information. If this file does not exist, an
	  exception is thrown.</p>
        <p><b>Note</b>: Depending on the operating system the filename might or
	  might not be case-sensitive!
    </dl>
    <pre><a name="~INIFile"></a>~INIFile ()</pre>

   <pre><a name="IFaddSection"></a>void addSection (const <a href="INIFile.html#INISection">INISection</a>&amp; section)</pre>
    <dl>
      <dd>
	<p>Adds a section to the list of sections to parse. In the
	  debug-version of the library (when the macro <i>NDEBUG</i> is
	  defined) it is checked, if the name of the section is unique.
	  Doubles are reported with an exception.</p></dd>
    </dl>

    <h4>Parsing</h4>
    <pre><a name="IFread"></a>int read () throw (std::string)</pre>
    <dl>
      <dd>
	<p>Tries to read the INI-file from the file.</p>
	<p>First the section header is parsed. If the name of the section from
	  the file is found in the list of sections, those sections are parsed.</p>
	<p>This step is repeated, til the end of the file is reached or a line
	  is found which is neither a section-header, nor an attribute.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF is reached; else
	  a non-zero value is returned or - depending on the error - an
	  exception is thrown.</p></dd>
    </dl>

    <pre><a name="IFfoundSection"></a>virtual int foundSection (const char* section)</pre>
    <dl>
      <dd>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is the check, if a section with the same name (case-sensitive!)
	is found within the entries of the object. If yes, their attributes are
	parsed.</dd>
    </dl>

    <pre><a name="IFfindSection"></a>const <a href="INIFile.html#INISection">INISection</a>* findSection (const char* name) const</pre>
    <dl>
      <dd>Searches the entries of the INI-file-object for a section with the
	passed name. If a matching entry is found, a pointer to it is returned;
	else NULL.</dd>
    </dl>

    <hr noshade>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td></tr>
    </table>
 
    <h1 align="center"><a name="INISection">Class INISection</a></h1>
    <p>Derived from: <i>None</i></p>

    <p>Header-file: INIFile.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to handle the information stored in a section of an INI-file.</p>
    <p>Usually this class is just used to bundle the attributes of a section
      together; none of their members is called directly. The only exception
      is for INI-files without any section, only with attributes. In that case
      the <a href="INIFile.html#readAttributes">readAttributes</a>-member can
      be used to parse those values (regardless of any header-information).</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#INISection2">INISection</a></td>
        <td>(const char* name)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="INIFile.html#~INISection">~INISection</a></td><td>()</td></tr>

      <tr valign="top"><td><a href="INIFile.html#IINIAttribute">IINIAttribute</a>*</td>
        <td><a href="INIFile.html#ISfindAttribute">findAttribute</a></td>
	<td>(const char* name) const</td></tr>
      <tr valign="top"><td>void</td>
        <td><a href="INIFile.html#ISaddAttribute">addAttribute</a></td>
	<td>(const <a href="INIFile.html#IINIAttribute">IINIAttribute</a>&amp; attribute) throw (std::string)</td></tr>
      <tr valign="top"><td>int</td>
        <td><a href="INIFile.html#ISreadFromStream">readFromStream</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</td></tr>
      <tr valign="top"><td>int</td>
        <td><a href="INIFile.html#ISreadAttributes">readAttributes</a></td>
	<td>(<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</td></tr>

      <tr valign="top"><td>const char*</td>
        <td><a href="INIFile.html#ISgetName">getName</a></td>
	<td>() const</td></tr>
      <tr valign="top"><td>bool</td>
        <td><a href="INIFile.html#ISmatches">matches</a></td>
	<td>(const char* name) const</td></tr>

      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="INIFile.html#ISfoundSection">foundSection</a></td>
	<td>(const char* section)</td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="INIFile.html#ISfoundKey">foundKey</a></td>
	<td>(const char* key)</td></tr>
      <tr valign="top"><td>virtual int</td>
        <td><a href="INIFile.html#ISfoundValue">foundValue</a></td>
	<td>(const char* value)</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="INISection2"></a>INISection (const char* name)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the section and must not be NULL.</p></dd>
    </dl>
    <pre><a name="~INISection"></a>~INISection ()</pre>

    <pre><a name="ISaddAttribute"></a>void addAttribute (const <a href="INIFile.html#IINIAttribute">IINIAttribute</a>&amp; attribute) throw (std::string)</pre>
    <dl>
      <dd><p>Adds an attribute to parse to the section. In the debug-version an
	  exception is thrown, if an attribute with the same name already
	  exists.</p></dd>
    </dl>

      <tr valign="top"><td>const char*</td>
        <td><a href="INIFile.html#ISgetName">getName</a></td>
	<td>() const</td></tr>
    <pre><a name="ISgetName"></a>const char* getName () const</pre>
    <dl>
      <dd>Returns the name of the section.</dd>
    </dl>

    <pre><a name="ISmatches"></a>bool matches (const char* name) const</pre>
    <dl>
      <dd>Checks if the passed name matches (case-sensitive!) the name of the
	section.</dd>
    </dl>

    <pre><a name="ISfindAttribute"></a>const IINIAttribute* findAttribute (const char* name) const</pre>
    <dl>
      <dd>Searches for an attribute matching the passed name. If such an
	attribute is not found, NULL is returned.</p>
    </dl>
    

    <h4>Parsing</h4>
    <pre><a name="ISreadFromStream"></a>int readFromStream (<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd>
	<p>Tries to read the (whole) section from the INI-file.</p>
	<p>First the section header is parsed. Note that the name of the
	  section in the INI-file must match those of the class.</p>
	<p>If the header can be parsed successfully, every following
	  <i>key=value</i>-pair is inspected and - if key matches an attribute
	  in the section - assigned.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header is reached. Errors are returned (or execeptions are
	  thrown) if either the section-name differ or the attribute is either
	  not found inside the class or the value can note be assigned.</p>
	<p><b>Note</b>: The exact behaviour depends on the type of the
	  attribute!</dd>
    </dl>
    <pre><a name="ISreadAttributes"></a>int readAttributes (<a href="XStream.html#Xistream">Xistream</a>&amp; stream) throw (std::string)</pre>
    <dl>
      <dd>
	<p>Tries to read the attributes of a section from the INI-file.</p>
	<p>Every <i>key=value</i>-pair is inspected and - if key matches the
	  name of an attribute in the section - assigned to the connected
	  variable.</p>
	<p>The function returns ParseObject::PARSE_OK, if EOF or a new
	  section-header (to be exact: Anything which is not a key) is reached.
	  Errors are returned (or execeptions are thrown) if the attribute is
	  either not found inside the class or the value can not be assigned.</p>
	<p><b>Note</b>: The exact behaviour depends on the type of the
	  attribute!</dd>
    </dl>

    <pre><a name="ISfoundSection"></a>virtual int foundSection (const char* section)</pre>
    <dl>
      <dd>Callback if a section-header (to be exact: an identifier after the
	start-of-section character open bracket ([)) is found. The default
	action is the check, if the section matches (case-sensitive!) the
	passed parameter. The method reports this result by either
	ParseObject::PARSE_OK or ParseObject::PARSE_CB_ABORT.</dd>
    </dl>

    <pre><a name="ISfoundKey"></a>virtual int foundKey (const char* key)</pre>
    <dl>
      <dd>Callback if a key of an attribute has been found. Every attribute of
	the section is compared with the passed key. If they match the value of
	the key is assigned to the attribute-variable and ParseObject::PARSE_OK
	is returned; else ParseObject::PARSE_CB_ABORT.</dd>
    </dl>

    <pre><a name="ISfoundValue"></a>virtual int foundValue (const char* value)</pre>
    <dl>
      <dd><p>Callback if a value of an attribute has been found. This value is
	  assigned using the pure-virtual
	  <a href="INIFile.html#IAassignFromString">assignFromString</a>-member
	  of <a href="INIFile.html#IINIAttribute">IINIAttribute</a>.</p>
	<p>This method is defined in templatized subclasses of
	  <a href="INIFile.html#IINIAttribute">IINIAttribute</a> for the
	  standard C types (int, double and the like), std::string, classes
	  derived from <a href="AttrVal.html">AttributValues</a> and everything
	  having an <i>operator=(const char*)</i>-member to assign values and
	  a <i>isDefined ()</i>-member the check for conistency; to enhance
	  that for other types simply define  
	  <a href="INIFile.html#INIAttribute">INIAttribute</a>::<a href="INIFile.html#IAassignFromString">assignFromString</a>
	  for your class.</p>
	<p>If assigning the value succeeds,  ParseObject::PARSE_OK is returned;
	  else ParseObject::PARSE_CB_ABORT.</dd>
    </dl>

    <hr noshade>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td></tr>
    </table>
 
    <h1 align="center"><a name="IINIAttribute">Class IINIAttribute</a></h1>
    <p>Derived from: <i>None</i></p>

    <p>Header-file: INIFile.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class to bundle a name to the address of an variable; together called
      attribute.</p>
    <p>This is an abstract base-class to define the interface for concrete
      realizations with a type for the attribute-variable.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td>bool</td><td><a href="INIFile.html#IIAmatches">matches</a></td>
        <td>(const char* name) const</td></tr>
      <tr valign="top"><td>virtual bool</td><td><a href="INIFile.html#IIAassignFromString">assignFromString</a></td>
        <td>(const char* value) = 0</td></tr>
      <tr valign="top"><td>const char*</td>
        <td><a href="INIFile.html#ISgetName">getName</a></td>
	<td>() const</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#IINIAttribute2">IINIAttribute</a></td>
        <td>(const char* name)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="INIFile.html#~IINIAttribute">~IINIAttribute</a></td><td>()</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="IINIAttribute2"></a>IINIAttribute (const char* name)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the attribute and must not be NULL.</p></dd>
    </dl>
    <pre><a name="~IINIAttribute"></a>~IINIAttribute ()</pre>

    <pre><a name="IIAgetName"></a>const char* getName () const</pre>
    <dl>
      <dd>Returns the name of the attribute.</dd>
    </dl>

    <pre><a name="IIAmatches"></a>bool matches (const char* name) const</pre>
    <dl>
      <dd>Checks if the passed name matches (case-sensitive!) the name of the
	attribute.</dd>
    </dl>

    <pre><a name="IIAassignFromString"></a>virtual bool assignFromString (const char* value) = 0</pre>
    <dl>
      <dd>Pure virtual method to assign an ASCIIZ-string to the variable stored
	withing the attribute. Derived objects must define this method and
	return true, if the assignment is OK; else false.</dd>
    </dl>

    <hr noshade>
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td></tr>
    </table>
 
    <h1 align="center"><a name="INIAttribute">Class INIAttribute&lt;T&gt;</a></h1>
    <p>Derived from: <a href="INIFile.html#IINIAttribute">IINIAttribute</a></p>

    <p>Header-file: INIFile.h</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Templated subclass of <a href="INIFile.html#IINIAttribute">IINIAttribute</a>
      to specify the type of the variable.</p>
    <p>Usually this class is not used directly (except of course defined), but
      just a helper-class for <a href="INIFile.html#INIFile">INIFile</a>- and
      <a href="INIFile.html#INISection">INISection</a>-classes.</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td></td><td><a href="INIFile.html#INIAttribute2">INIAttribute</a></td>
        <td>(const char* name)</td></tr>
      <tr valign="top"><td>virtual</td>
        <td><a href="INIFile.html#~INIAttribute">~INIAttribute</a></td><td>()</td></tr>
      <tr valign="top"><td>virtual bool</td><td><a href="INIFile.html#IAassignFromString">assignFromString</a></td>
        <td>(const char* value) = 0</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="INIAttribute2"></a>INIAttribute (const char* name T&amp; attr)</pre>
    <dl>
      <dd><p>Constructor; name is the name of the attribute and must not be
	  NULL; attr is the variable to bind to the name.</p></dd>
    </dl>
    <pre><a name="~INIAttribute"></a>~INIAttribute ()</pre>

    <pre><a name="IAassignFromString"></a>virtual bool assignFromString (const char* value)</pre>
    <dl>
      <dd><p>Virtual method to assign an ASCIIZ-string to the variable stored
	withing the attribute.</p>
	<p>This method return true, if assign the value was OK, else false.
	  At the moment there are implementations for the standard C-types,
	  std::string and classes derived from <a href="AttrVal.html">AttributValue</a>.</p>
	<p>This can be easily enhanced by own types by defining (and
	  implementing) your own <i>assignFromStream</i>-members with your
	  own type (see the header INIFile.h for examples).</p></dd>
    </dl>

    <hr noshade>
    <p>Maintained by <a href=mailto:Markus.Schwab@digitalsignum.com">Markus Schwab</a></p>
  </body>
</html>
