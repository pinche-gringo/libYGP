<!-- $Id: SmartPtr.html,v 1.4 2001/10/20 00:55:43 markus Exp $ -->

<html>
  <head>
    <title>General Reference: SmartPtr</title>
    <meta name="description" content="Documentation of SmartPtr-class">
    <meta name="keywords" content="Documentation, Docu, SmartPtr, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class SmartPtr&lt;T&gt;</h1>
    <p>Derived from:
      <i>none</i>
      <br>
      Derived by:
      <i>none</i></p>

    <p>#include &lt;SmartPtr.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Smart-pointer-class; its referenced object is freed when the smart
      pointer-object is released.</p>

    <p>In counterpart to auto_ptr there is <b>no</b> ownership handling (and
      therefor no copy-constructor nor an assignment-operator).</p>

    <p><b>Note</b>: This class is (intented to be) simple. Consider this when
      using it!</p>
    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td></td>
        <td><a href="SmartPtr.html#SmartPtr"><b>SmartPtr</b></a></td>
        <td><tt>(<font color="navy">T</font>* <font color="blue">pValue</font> = NULL)</tt>;</td></tr>

      <tr valign="top"><td><tt><a href="SmartPtr.html"><b>SmartPtr</b></a>&amp;</tt></td>
        <td><a href="SmartPtr.html#operator="><tt><font color="black"><b>operator</b></font>=</a></td>
        <td><tt>(<font color="navy">T</font>* <font color="blue">pValue</font>)</tt>;</td></tr>

      <tr valign="top"><td><tt><font color="navy">T</font>*</tt></td>
        <td><a href="SmartPtr.html#operator-g"><tt><font color="black"><b>operator</b></font>-&gt;</tt></a></td>
        <td><tt>() const</tt>;</td></tr>
      <tr valign="top"><td><tt><font color="navy">T</font>&amp;</tt></td>
        <td><a href="SmartPtr.html#operator*"><tt><font color="black"><b>operator</b></font>*</a></td>
        <td><tt>() const</tt>;</td></tr>
      <tr valign="top"><td></td>
        <td><a href="SmartPtr.html#operatorT*"><tt><font color="black"><b>operator</b></font> T*</a></td>
        <td><tt>() const</tt>;</td></tr>

      <tr valign="top"><td><tt>virtual</tt></td>
        <td><a href="SmartPtr.html#~SmartPtr"><b>~SmartPtr</b></a></td>
        <td><tt>()</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="SmartPtr"></a>SmartPtr (T* pValue = NULL)</pre>
    <dl>
      <dd><p>Defaultconstructor; lets the SmartPtr-object point to the passed
          value.</p>
        <p><b>Note</b>: The parameter must be the address of an object on the
          heap (created with new)!</p></dd>
    </dl>
    <pre><a name="~SmartPtr"></a>~SmartPtr ()</pre>

    <pre><a name="operator="></a>SmartPtr&amp; operator= (T* pValue)</pre>
    <dl>
      <dd>Assignmentoperator; releases the old object pointed to and starts
        handling the new (passed) one.</dd>
    </dl>

    <h4>Accessing the object</h4>
    <pre><a name="operator-g"></a>T* operator-&gt; () const</pre>
    <dl>
      <dd>Retrieves the stored pointer to the object.</dd>
    </dl>

    <pre><a name="operator*"></a>T&amp; operator* () = 0</pre>
    <dl>
      <dd>Retrieves a reference to the stored obect.</dd>
    </dl>

    <pre><a name="operatorT*"></a>operator T* () const</pre>
    <dl>
      <dd>Type-conversion; Retrieves the stored pointer to the object.</dd>
    </dl>

  </body>
</html>
