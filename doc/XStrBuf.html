<!-- -*-HTML-*- -->

<!-- $Id: XStrBuf.html,v 1.5 2002/04/11 19:05:48 markus Rel $ -->

<html>
  <head>
    <title>General Reference: extStreambuf</title>
    <meta name="description" content="Documentation of extStreambuf-class">
    <meta name="keywords" content="Documentation, Docu, extStreambuf, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class extStreambuf&lt;T&gt;</h1>
    <p>Derived from:
      streambuf
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;XStrBuf.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Extended streambuf, designed to parse text.</p>

    <p>It overcomes two drawbacks of the original streambuf:</p>
    <ul>
      <li>Column- and line-information (which - to be fair - wouldn't make very
        much sense in the common streambuf anyway).</li>
      <li>A variable-sized putback-buffer. The common streambuf only stores one
        block (and a few bytes from the last), so a pushback beyond this border
        is not possible.</li>
    </ul>
    <p><b>Note</b>: This buffer only works for input and needs a "real"
      data-sink as source, so provide another streambuf-object to get its data
      from with the <a href="XStrBuf.html#extStreambuf2">constructor</a> or
      with the <a href="XStrBuf.html#setSource">setSource</a>-method!</p>
    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="XStrBuf.html#extStreambuf"><b>extStreambuf</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="XStrBuf.html#extStreambuf2"><b>extStreambuf</b></a></td>
        <td><tt>(<tt><font color="navy">streambuf</font></tt>& <tt><font color="blue">source</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="XStrBuf.html#extStreambuf3"><b>extStreambuf</b></a></td>
        <td><tt>(<tt><font color="navy">streambuf</font></tt>* <tt><font color="blue">source</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="XStrBuf.html#getColumn"><b>getColumn</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="navy">unsigned</font></tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="XStrBuf.html#getLine"><b>getLine</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="XStrBuf.html#overflow"><b>overflow</b></a></td>
        <td><tt>(<tt><font color="purple">int</font></tt> <tt><font color="blue">ch</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="XStrBuf.html#pbackfail"><b>pbackfail</b></a></td>
        <td><tt>(<tt><font color="purple">int</font></tt> <tt><font color="blue">c</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="XStrBuf.html#setSource2"><b>setSource</b></a></td>
        <td><tt>(<tt><font color="navy">streambuf</font></tt>* <tt><font color="blue">source</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="XStrBuf.html#setSource"><b>setSource</b></a></td>
        <td><tt>(<tt><font color="navy">streambuf</font></tt>& <tt><font color="blue">source</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="XStrBuf.html#underflow"><b>underflow</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="XStrBuf.html#~extStreambuf"><b>~extStreambuf</b></a></td>
        <td><tt>()</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h4>Management functions</h4>
    <pre><a name="extStreambuf"></a>extStreambuf ()</pre>
    <dl>
      <dd>Defaultconstructor; Although reading from this object should work and
        should also return some "random" data, to provide a "real" data-sink
        is highly recommended. This method might be declared private (or at
        least protected) in the future.</dd>
    </dl>
    <pre><a name="extStreambuf2"></a>extStreambuf (streambuf&amp; source)</pre>
    <dl>
      <dd>Constructor; creates an extended streambuf which takes its input from
        the provided source.</dd>
    </dl>
    <pre><a name="extStreambuf3"></a>extStreambuf (streambuf* source)</pre>
    <dl>
      <dd>Constructor; creates an extended streambuf which takes its input from
        the provided source.</dd>
    </dl>
    <pre><a name="~extStreambuf"></a>~extStreambuf ()</pre>

    <pre><a name="setSource"></a>void setSource (streambuf&amp; source)</pre>
    <dl>
      <dd>Sets a new data-sink for the extended streambuf. Because its very
        likely that after this call the next input is taken from the remaining
        characters left in the "old" source, this function should only be used
        in combination with the <a href="XStrBuf.html#extStreambuf"><b>default
          constructor</b></a> and might be declared private (or protected) in the
        future.</dd>
    </dl>
    <pre><a name="setSource2"></a>void setSource (streambuf* source)</pre>
    <dl>
      <dd>Sets a new data-sink for the extended streambuf. Because its very
        likely that after this call the next input is taken from the remaining
        characters left in the "old" source, this function should only be used
        in combination with the <a href="XStrBuf.html#extStreambuf"><b>default
          constructor</b></a> and might be declared private (or protected) in the
        future.</dd>
    </dl>

    <h4>In- &amp; output</h4>
    <pre><a name="overflow"></a>int overflow (int ch)</pre>
    <dl>
      <dd>Called if output would cause the streambuf to overrun. Because this
        class is designed for input, this method shouldn't be called. It also
        might be declared protected in the future.</dd>
    </dl>
    <pre><a name="underflow"></a>int underflow ()</pre>
    <dl>
      <dd><p>Called if the object doesn't contain data in the input-buffer.</p>
        <p>It then copies characters from its data-sink (the streambuf passed
          while constructing or defined with setSource) til the next line-feed
          character (10, 0x0a, '\n') and sets this data as its input.</p>
        <p>This method is called automatically and should be used. It also
          might be declared protected in the future.</p></dd>
    </dl>

    <pre><a name="pbackfail"></a>int pbackfail (int ch)</pre>
    <dl>
      <dd><p>There are two reasons why this method could be called while pushing
        back characters:</p>
	<ul type="disc">
          <li>A character is pushed back which doesn't fit the read character.
            This is propably due to a programming failure and the pushback is
            not performed.</li>
          <li><p>A buffer underrun; caused by pushing characters back into the
              previous line (and - depending on the implementation of streambuf
              - maybe a few characters more). In this read-position of the
              data-sink is changed to the end of the previous line.</p>
            <p><b>Note</b>: For the sake of performance the check if the
              character pushed back matches the character in the stream is
              <b>not</b> done (but the next read-operation returns the "right"
              character)! Thinking of caches, this behaviour might be changed
              in the future.</p></li>
        </ul></dd>
    </dl>

    <h4>Accessing the object</h4>
    <pre><a name="getLine"></a>unsigned int getLine () const</pre>
    <dl>
      <dd>Returns the actual line of the streambuf. This value is 0 before any
        data is read and starts with 1 for the first line (after the first
        read-operation). A new line starts after a character 10 (0x0a, or the
        C-charachter '\n'), which is UNIX-style but works also for the
        DOS/Windoze and the like.</dd>
    </dl>
    <pre><a name="getColumn"></a>unsigned int getColumn () const</pre>
    <dl>
      <dd>Returns the actual position in the line of the streambuf. This value
        is 0 before any data (of the line) is read and starts with 1 after the
        first read-operation in the line (A new line starts after a character
        10 (0x0a, or the C-charachter '\n'), which is UNIX-style but works
        also for the DOS/Windoze and the like.</dd>
    </dl>
  </body>
</html>
