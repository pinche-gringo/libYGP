<!-- -*-HTML-*- -->
<!-- $Id: CRegExp.html,v 1.5 2002/12/08 22:41:53 markus Exp $ -->

<html>
  <head>
    <title>General Reference: RegularExpression</title>
    <meta name="description" content="Documentation of RegularExpression-class">
    <meta name="keywords" content="Documentation, Docu, RegularExpression, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2001-09-29">
    <meta name="DC.Rights" content="Anticopyright (A) 2001, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class RegularExpression</h1>
    <p>Derived from
      <a href="RegExp.html">IRegularExpression</a>
      <br>
      Derived by: <i>none</i></p>

    <p>#include &lt;CRegExp.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>

    <p>Class to compare text with regular expressions. Here is a
      little intruduction into the supported constructs; see regex(7) or
      the GNU regexp manual for a better description. The Perl regexp
      documentation might be another source of information (though Perl's regexp are more
      powerfull). On the other hand, also the regex(7) documentation doesn't match
      exactly the implementation (notably the mentioned special cases of bracket
      expressions ([[:&lt;:]] and [[:&gt;:]]), which are not implemented (on my
      system - and therefore only available if the class is compiled with
      <code>ENHANCED_REGEXP</code> defined).</p>

    <dl compact>
      <dt><b>*</b></dt>
      <dd>Is not a construct by itself; it is a suffix which repeats the (smallest
        possible) preceding regular expression as many times as possible.</dd>
      <dt><b>+</b></dt>
      <dd>is a suffix character similar to '<b>*</b>', except that it
        requires that the preceeding regular expression is matched at
        least once.</dd>
      <dt><b>?</b></dt>
      <dd>is a suffix character similar to '<b>*</b>', except that it
        requires that the preceeding regular expression is matched either
        once or not at all.
      <dt><b>.</b></dt>
      <dd>matches any single character.</dd>
      <dt><b>^</b></dt>
      <dd>Matches an empty string in the beginning of the line.</dd>
      <dt><b>$</b></dt>
      <dd>Similar to the caret (') this matches the end of the line.</dd>

      <dt><b>|</b></dt>
      <dd>seperates two alternatives.</dd>
      <dt><b>(...)</b></dt>
      <dd>groups regular expressions and marks the matching
         substring for future reference.</dd>

      <dt><b>\</b></dt>
      <dd>Quotes the following characters (including the backlash (\) itself:
        <dl compact>
          <dt><b>\DIGIT</b></dt>
          <dd>to repeat the matched text of the DIGIT'th '<b>\(...\)</b>-construct.</dd>
          <dt><b>\b</b></dt>
          <dd>matches the empty string, provided its at the beginning or the
            end of a word.</dd>
          <dt><b>\B</b></dt>
          <dd>matches the empty string, provided its not at the beginning or
            the end of a word.</dd>
          <dt><b>\&lt;</b></dt>
          <dd>matches the empty string, provided its at the beginning of a word.</dd>
          <dt><b>\&gt;</b></dt>
          <dd>matches the empty string, provided its at the end of a word.</dd>
          <dt><b>\w</b></dt>
          <dd>matches any word-constituent character.</dd>
          <dt><b>\W</b></dt>
          <dd>matches any character that is not word-constituent.</dd>
        </dl>
      </dd>

      <dt><b>[&lt;match&gt;]</b></dt>
      <dd>matches the characters specified in match.</dd>
      <dt><b>[^&lt;match&gt;]</b></dt>
      <dd>matches the characters not specified in match.</dd>
      <dt><b>[!&lt;match&gt;]</b></dt>
      <dd>matches the characters not specified in match.

      <p>&lt;<i>match</i>&gt; ::= &lt;<i>char</i>&gt;&lt;<i>match</i>&gt; |
        &lt;<i>range</i>&gt;&lt;<i>match</i>&gt; |  
        &lt;<i>character-class</i>&gt;&lt;<i>match</i>&gt; | {}<br>
        &lt;<i>range</i>&gt; ::= &lt;<i>low</i>&gt;-&lt;<i>high</i>&gt;<br>
        &lt;<i>character-class</i>&gt; ::= [:&lt;<i>class</i>&gt;:]<br>
        &lt;<i>class</i>&gt; ::= alnum | alpha | cntrl | digit | space | graph
                                 | lower | print | punct | upper [ | &lt; | &gt; ]
                                 <sup><a href="CRegExp.html#note1">1</a></sup>

      <p><b>Note</b>: To include the character square bracket ([) in the match, it
        must be the first character; similar to the caret (^), wich must
        <b>not</b> be the first character to get included.</p></dd>

      <dt><b>{i}, {i,}, {i,j}</b></dt>
      <dd>the previous regular expression must be repeated either
        exactly <i>i</i> times; <i>i</i> times or more; <i>i</i> through <i>j</i>
        (inclusive) times.</dd>
    </dl>

    <p><b>Note</b>: The pExpression-parameter is stored as is (and not
      copied); so take care it is valid during the life-time of the
      object.</p>

    <p>Use the <a href="RegExp#matches"><b>matches</b></a>-method of
      the parent (RegularExpression) to check if the object matches some
      data.</p>

    <hr noshade>
    <table border="0">
      <tr><td colspan="3"><h3>public function member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="CRegExp.html#RegularExpression"><b>RegularExpression</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pRegExp</span></tt>) <tt>throw (<span style="color:purple;">std::string</span>)</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple;">int</span></tt></tt> </td>
        <td><a href="CRegExp.html#checkIntegrity"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const throw (<span style="color:purple;">std::string</span>)</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><a href="CRegExp.html#RegularExpression"><b>RegularExpression</b></a>&</tt> </td>
        <td><a href="CRegExp.html#operator="><tt><span style="color:black;"><b>operator</b></span></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pRegExp</span></tt>)  throw (<span style="color:purple;">std::string</span>)</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="CRegExp.html#~RegularExpression"><b>~RegularExpression</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
      <tr><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><span style="color:purple;">bool</span></tt></tt> </td>
        <td><a href="CRegExp.html#compare"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pAktRegExp</span></tt>, <tt>const</tt> <tt><span style="color:purple;">char</span></tt>* <tt><span style="color:blue;">pCompare</span></tt>)</tt>;</td></tr>
      <tr><td>&nbsp;</td></tr>
    </table>
    <hr noshade>
    <h2>Member descriptions</h2>


    <h3 style="color:navy;">Management functions</h3>
    <pre><a name="RegularExpression"></a> <b>RegularExpression</b> (const char* pRegExp) throw (std::string)</pre>
    <dl>
      <dd><p>Constructor, specifies the regular expression to match.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pRegExp</code>: Pointer to character array holding regular expression<dd>
      </dl><dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>This input is <b>not</b> copied, so it must be valid during the lifetime of the
            regular expression.</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: In case of an invalid regexp a describing text</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="~RegularExpression"></a> <b>~RegularExpression</b> ()</pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="operator="></a>RegularExpression&amp; <b>operator=</b> (const char* pRegExp)</pre>
    <dl>
      <dd><p>Sets the passed value as regular expression to match.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pRegExp</code>: Pointer to character array holding regular expression<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>RegularExpression&amp;: Reference to this</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>This input is <b>not</b> copied, so it must be valid during the lifetime of the
            regular expression.</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: In case of an invalid regexp a describing text</dd></dl></dd>
    </dl>

    <h3 style="color:navy;">Matching functions</h3>
    <pre><a name="compare"></a>bool <b>compare</b> (const char* pAktRegExp, const char* pCompare)</pre>
    <dl>
      <dd><p>Checks if the passed text matches the passed regular expression.</p>
        <p>Both passed parameter must not be NULL-pointers and the regular expression
          must be in a valid syntax (this can be checked with the
          <a href="FileRExp.html#checkIntegrity">checkIntegrity</a>-method).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pAktRegExp</code>: Pointer to character array holding regular expression<dd>
          <dd><code>pCompare</code>: Pointer to character array holding value to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>bool: Result (true = match)</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
         <dd><code>pAktRegExp</code>, <code>pCompare</code>: ASCIIZ-strings</dd></dl></dd>
    </dl>

    <h3 style="color:navy;">Utility functions</h3>
    <pre><a name="checkIntegrity"></a>int <b>checkIntegrity</b> () const throw (std::string)</pre>
    <dl>
      <dd><p>Checks the syntax of the regular expression. If everything is OK, 0
        is returned; 1 if there is no regular expression at all. In case of any other
        error an exception is thrown.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Status; 0: OK</dd></dl></dd>
      <dd><dl><dt><b>Requires</b></dt>
          <dd>pFileRegExp is a valid regexp</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::string: In case of an invalid regexp a describing text</dd></dl></dd>
    </dl>

    <hr noshade>
    <dl>
      <dt><b><a name="note1">1</a></b></dt>
      <dd>The classes "&lt;" and "&gt;" are only available if the class is compiled
        with <code>ENHANCED_REGEXP</code> defined</dd>
    </dl>
  </body>
</html>
