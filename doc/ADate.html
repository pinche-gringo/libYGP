<!-- -*-HTML-*- -->

<!-- $Id: ADate.html,v 1.15 2002/11/26 19:56:05 markus Exp $ -->

<html>
  <head>
    <title>General Reference: ADate</title>
    <meta name="description" content="Documentation of ADate-class">
    <meta name="keywords" content="Documentation, Docu, ADate, class">

    <meta name="DC.Creator" content="Markus Schwab">
    <meta name="DC.Date" content="2000-04-14">
    <meta name="DC.Rights" content="Anticopyright (A) 2000, distributed under the GNU General Public License">
  </head>

  <body bgcolor="#F0F0F0" text="#000000" link="#0000FF" vlink="#000077" alink="#FF0000">
    <table align="center" border="0" cellspacing="10">
      <tr><td><a href="index.html">Class Index</a></td>
      <td><a href="cross_index.html">Cross Index</a></td></tr>
    </table>

    <h1 align="center">Class ADate</h1>
    <p>Derived from:
      <a href="AttrVal.html">AttributValue</a>
      <br>
      Derived by:
      <a href="ATStamp.html">ATimestamp</a></p>

    <p>#include &lt;ADate.h&gt;</p>

    <hr noshade>
    <h2>Description</h2>
    <p>Class for date attributes. As every AttributValue is supports undefined
      values.</p>

    <p>Note that it's possible to calculate with ADate-objects. But beware,
      that the results are not always intuitive (e.g. what's today - today?
      Mathematically it's the 0.0.0, which is not a valid date and therefore
      changed to the 31.12.-1; a result which might not be expected).</p>

    <hr noshade>
    <table border="0">
      <tr valign="top"><td colspan="3"><h3>public member index</h3></td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate"><b>ADate</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate2"><b>ADate</b></a></td>
        <td><tt>(<tt><font color="purple">bool</font></tt> <tt><font color="blue">now</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate3"><b>ADate</b></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate4"><b>ADate</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">Day</font></tt>, <tt><font color="purple">char</font></tt> <tt><font color="blue">Month</font></tt>, <tt><font color="purple">int</font></tt> <tt><font color="blue">Year</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate5"><b>ADate</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pDate</font></tt>) throw (<tt><font color="navy">invalid_argument</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate6"><b>ADate</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">std::string</font></tt>&amp; <tt><font color="blue">date</font></tt>) throw (<tt><font color="navy">invalid_argument</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate7"><b>ADate</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">struct</font></tt> <tt><font color="blue">tm</font></tt>&amp; <tt><font color="blue">tm</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt></tt> </td>
        <td><a href="ADate.html#ADate8"><b>ADate</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">time_t</font></tt>&amp; <tt><font color="blue">date</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><a href="ADate.html#add"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#87"><b>add</b></a></td>
        <td><tt>(<tt><font color="navy">signed</font></tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">Day</font></tt>, <tt><font color="navy">signed</font></tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">Month</font></tt> = 0, <tt><font color="purple">int</font></tt> <tt><font color="blue">Year</font></tt> = 0)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="ADate.html#100"><b>checkIntegrity</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="navy">long</font></tt></tt> </td>
        <td><a href="ADate.html#compare"><b>compare</b></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html#63"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#define"><b>define</b></a></td>
        <td><tt>()</tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">char</font></tt></tt> </td>
        <td><a href="ADate.html#getDay"><b>getDay</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">char</font></tt></tt> </td>
        <td><a href="ADate.html#getMonth"><b>getMonth</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">int</font></tt></tt> </td>
        <td><a href="ADate.html#getYear"><b>getYear</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#isLeapYear"><b>isLeapYear</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#isLeapYear"><b>isLeapYear</b></a></td>
        <td><tt>(<tt><font color="purple">int</font></tt> <tt><font color="blue">year</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>static</tt> <tt><font color="purple">char</font></tt></tt> </td>
        <td><a href="ADate.html#maxDayOf"><b>maxDayOf</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">month</font></tt>, <tt><font color="purple">int</font></tt> <tt><font color="blue">year</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">char</font></tt></tt> </td>
        <td><a href="ADate.html#maxDayOf"><b>maxDayOf</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#operator!="><tt><font color="black"><b>operator</b></font></tt><tt>!=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator+="><tt><font color="black"><b>operator</b></font></tt><tt>+=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator-="><tt><font color="black"><b>operator</b></font></tt><tt>-=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">rhs</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#operatorl"><tt><font color="black"><b>operator</b></font></tt><tt>&lt;</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#operatorl="><tt><font color="black"><b>operator</b></font></tt><tt>&lt;=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator="><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator=5"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">time_t</font></tt>&amp; <tt><font color="blue">date</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator=4"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="navy">struct</font></tt> <tt><font color="blue">tm</font></tt>&amp; <tt><font color="blue">date</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator=2"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">pDate</font></tt>) throw (<tt><font color="navy">invalid_argument</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><a href="ADate.html"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#operator=2"><tt><font color="black"><b>operator</b></font></tt><tt>=</tt></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">std::string</font></tt>&amp; <tt><font color="blue">date</font></tt>) throw (<tt><font color="navy">invalid_argument</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#operator=="><tt><font color="black"><b>operator</b></font></tt><tt>==</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#operatorg"><tt><font color="black"><b>operator</b></font></tt><tt>&gt;</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#operatorg="><tt><font color="black"><b>operator</b></font></tt><tt>&gt;=</tt></a></td>
        <td><tt>(<tt>const</tt> <a href="ADate.html"><b>ADate</b></a>&amp; <tt><font color="blue">other</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt>friend <a href="ADate.html"><b>ADate</b></a></tt></td>
        <td><a href="ADate.html#operator+"><tt><font color="black"><b>operator</b></font></tt><tt>+</tt></a></td>
        <td><tt>(const <a href="ADate.html"><b>ADate</b></a>&amp; <font color="blue">lhs</font>,
                 const <a href="ADate.html"><b>ADate</b></a>&amp; <font color="blue">rhs</font>);</tt></td></tr>
      <tr valign="top"><td><tt>friend <a href="ADate.html"><b>ADate</b></a></tt></td>
        <td><a href="ADate.html#operator-"><tt><font color="black"><b>operator</b></font></tt><tt>-</tt></a></td>
        <td><tt>(const <a href="ADate.html"><b>ADate</b></a>&amp; <font color="blue">lhs</font>,
                 const <a href="ADate.html"><b>ADate</b></a>&amp; <font color="blue">rhs</font>);</tt></td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#readFromStream"><b>readFromStream</b></a></td>
        <td><tt>(<tt><font color="purple">istream</font></tt>&amp; <tt><font color="blue">result</font></tt>) <tt>throw (<tt><font color="navy">invalid_argument</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#setDay"><b>setDay</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">Day</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#setMonth"><b>setMonth</b></a></td>
        <td><tt>(<tt><font color="purple">char</font></tt> <tt><font color="blue">Month</font></tt>)</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#setYear"><b>setYear</b></a></td>
        <td><tt>(<tt><font color="purple">int</font></tt> <tt><font color="blue">Year</font></tt>)</tt>;</td></tr>

      <tr valign="top"><td><tt><a href="ADate.html#63"><b>ADate</b></a>&amp;</tt> </td>
        <td><a href="ADate.html#sub"><b>sub</b></a></td>
        <td><tt>(<tt><font color="navy">signed</font></tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">Day</font></tt>, <tt><font color="navy">signed</font></tt> <tt><font color="purple">char</font></tt> <tt><font color="blue">month</font></tt> = 0, <tt><font color="purple">int</font></tt> <tt><font color="blue">Year</font></tt> = 0)</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">std::string</font></tt></tt> </td>
        <td><a href="ADate.html#toString"><b>toString</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">std::string</font></tt></tt> </td>
        <td><a href="ADate.html#toString2"><b>toString</b></a></td>
        <td><tt>(<tt>const</tt> <tt><font color="purple">char</font></tt>* <tt><font color="blue">format</font></tt>) <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="navy">struct</font></tt> <tt><font color="navy">tm</font></tt></tt> </td>
        <td><a href="ADate.html#toStructTM"><b>toStructTM</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">time_t</font></tt></tt> </td>
        <td><a href="ADate.html#toSysTime"><b>toSysTime</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">std::string</font></tt></tt> </td>
        <td><a href="ADate.html#toUnformatedString"><b>toUnformatedString</b></a></td>
        <td><tt>() <tt>const</tt></tt>;</td></tr>

      <tr valign="top"><td><tt><tt>static</tt> <a href="ADate.html"><b>ADate</b></a></tt> </td>
        <td><a href="ADate.html#today"><b>today</b></a></td>
        <td><tt>()</tt>;</td></tr>

      <tr valign="top"><td><tt><tt>virtual</tt> </tt> </td>
        <td><a href="ADate.html#~ADate"><b>~ADate</b></a></td>
        <td><tt>()</tt>;</td></tr>

      <tr><td>&nbsp;</td></tr>
      <tr valign="top"><td colspan="3"><h3>protected function member index</h3></td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#decDay"><b>decDay</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt><font color="purple">void</font></tt></tt> </td>
        <td><a href="ADate.html#incDay"><b>incDay</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#maxAdapt"><b>maxAdapt</b></a></td>
        <td><tt>()</tt>;</td></tr>
      <tr valign="top"><td><tt><tt>virtual</tt> <tt><font color="purple">bool</font></tt></tt> </td>
        <td><a href="ADate.html#minAdapt"><b>minAdapt</b></a></td>
        <td><tt>()</tt>;</td></tr>
    </table>

    <hr noshade>
    <h2>Member descriptions</h2>

    <h3><font color="navy">Management functions</font></h4>
    <pre><a name="ADate"></a><b>ADate</b> ()</pre>
    <dl>
      <dd><p>Defaultconstructor; the date is not defined</p></dd>
    </dl>

    <pre><a name="ADate3"></a><b>ADate</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Copyconstructor; copies the values of the passed object</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to copy<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="ADate2"></a><b>ADate</b> (bool now)</pre>
    <dl>
      <dd><p>Constructor; depending on the parameter the date is either set to the
        first of January, 1900 (now = false), or to the current day (now =
        true).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>now</code>: Flag which time to set (1900/1/1 (false) or now (true))<dd>
      </dl><dd>
    </dl>
    <hr>

    <pre><a name="ADate4"></a><b>ADate</b> (char Day, char Month, int Year)</pre>
    <dl>
      <dd><p>Constructor; sets the passed date. The date is undefined, if the
        passed parameters represent no valid day.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>day</code>: Day for this ADate<dd>
          <dd><code>month</code>: Month year: Year to set<dd>
      </dl><dd>
    </dl>
    <hr>

    <pre><a name="ADate5"></a><b>ADate</b> (const char* pDate) throw (invalid_argument)</pre>
    <dl>
      <dd><p>Constructor from an const char-pointer. The date must be
        passed as DDMMY[Y...]. If the buffer does not represent a
        valid day, the date is set to undefined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pDate</code>: Character array holding date to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::invalid_argument if the characters don't represent a valid date
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="ADate6"></a><b>ADate</b> (std::string&amp; date) throw (invalid_argument)</pre>
    <dl>
      <dd><p>Constructor; sets the passed date, which must be represented as
        DDMMY[Y...]. If the string does not represent a valid day,
        an exception is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pDate</code>: String holding date to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::invalid_argument if the string doesn not represent a valid date
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="ADate7"></a><b>ADate</b> (const struct tm&amp; date)</pre>
    <dl>
      <dd><p>Constructor; sets the values from the passed struct tm.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>date</code>: struct tm holding date to assign<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="ADate8"></a><b>ADate</b> (const time_t date)</pre>
    <dl>
      <dd><p>Constructor; converts the passed date to an ADate object.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>date</code>: System time representation of date to assign<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="~ADate"></a><b>~ADate</b> () </pre>
    <dl>
      <dd><p>Destructor</p></dd>
    </dl>
    <hr>
    <pre><a name="operator="></a>ADate& <b>operator=</b> (const ADate& other) </pre>
    <dl>
      <dd><p>Assignment-operator</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate&: Reference to self
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="operator=2"></a>ADate& <b>operator=</b> (const char* pDate) throw (std::invalid_argument) </pre>
    <dl>
      <dd><p>Assignment-operator from a const char-pointer. The date must be
        passed as DDMMY[Y...]. If the buffer does not represent a
        valid day, an exception is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>pDate</code>: Character array holding date to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate&: Reference to self
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::invalid_argument if the characters don't represent a date
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator=3"></a>ADate&amp; <b>operator=</b> (const std::string&amp; date) throw (invalid_argument)</pre>
    <dl>
      <dd><p>Assignment-operator from a const string. The date must be
        passed as DDMMY[Y...]. If the string does not represent a
        valid day, an exception is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>date</code>: String holding date to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate&: Reference to self
</dd></dl></dd>
      <dd><dl><dt><b>Throws</b></dt>
          <dd>std::invalid_argument if the characters don't represent a date
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator=4"></a>ADate&amp; <b>operator=</b> (const struct tm&amp; date)</pre>
    <dl>
      <dd><p>Assignment-operator from a struct tm.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>date</code>: Struct tm holding date to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate&: Reference to self
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator=5"></a>ADate&amp; <b>operator=</b> (const time_t date)</pre>
    <dl>
      <dd><p>Assignment-operator from a a system time.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>date</code>: System time holding date to assign<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate&: Reference to self
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="define"></a>void <b>define</b> ()</pre>
    <dl>
      <dd><p>Sets the date to the 1st of January, 1900.</p></dd>
    </dl>

    <pre><a name="setDay"></a>void <b>setDay</b> (char Day) </pre>
    <dl>
      <dd><p>Sets the day to the passed value. If the date is not valid, it is
        set to undefined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>Day</code>: Day to set<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="setMonth"></a>void <b>setMonth</b> (char Month) </pre>
    <dl>
      <dd><p>Sets the month to the passed value. If the date is not valid, it is
        set to undefined.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>month</code>: Month to set<dd>
      </dl><dd>
    </dl>
    <hr>
    <pre><a name="setYear"></a>void <b>setYear</b> (int Year)</pre>
    <dl>
      <dd><p>Sets the year to the passed value.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>Year</code>: Year to set<dd>
      </dl><dd>
    </dl>

    <h3><font color="navy">In- &amp; output, conversion</font></h4>
    <pre><a name="readFromStream"></a>void <b>readFromStream</b> (std::istream& in) throw (std::invalid_argument) </pre>
    <dl>
      <dd><p>Reads a date as <i>DDMMY[Y...]</i> from a stream. If the input is
        not valid, an exception is thrown.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>in</code>: Stream to parse<dd>
      </dl><dd>
    </dl>
    <hr>

    <pre><a name="toString"></a>std::string <b>toString</b> () const </pre>
    <dl>
      <dd><p>Converts the date into a string, in the format specified by the current locale.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: String-representation of ADate
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>Only dates valid for struct tm can be printed (e.g. dates after
 1900)</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="toString2"></a>std::string <b>toString</b> (const char* format) const </pre>
    <dl>
      <dd><p>Converts the date into a string, in the specified format. The
          parameter format can be any value accepted by the strftime
          library-routine.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: String-representation of ADate
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>Only dates valid for struct tm can be printed (e.g. dates after
 1900)</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="toUnformatedString"></a>std::string <b>toUnformatedString</b> () const </pre>
    <dl>
      <dd><p>Converts the date into a string, in the format DDMMYYYY; each entry is filled up
        with zeros.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>std::string: String-representation of ADate
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="toStructTM"></a>struct tm <b>toStructTM</b> () const </pre>
    <dl>
      <dd><p>Converts the date to a struct tm.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>struct tm: Date in struct tm-format; the time-part is set to zeros
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>It is not checked if the date is in the right range for a
 struct tm (after 1900 and before 2039)</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="toSysTime"></a>time_t <b>toSysTime</b> () const</pre>
    <dl>
      <dd><p>Converts the date to a system-timestructure.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>time_t: Date in system format
</dd></dl></dd>
    </dl>

    <h3><font color="navy">Query</font></h4>
    <pre><a name="getDay"></a>char <b>getDay</b> () const</pre>
    <dl>
      <dd><p>Retrieves the day stored in the object.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>char: Day part of the object
</dd></dl></dd>
    </dl>

    <pre><a name="getMonth"></a>char <b>getMonth</b> () const</pre>
    <dl>
      <dd><p>Retrieves the month.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>char: Month part of the object
</dd></dl></dd>
    </dl>

    <pre><a name="getYear"></a>int <b>getYear</b> () const</pre>
    <dl>
      <dd><p>Retrieves the  year.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>char: Day part of the object
</dd></dl></dd>
    </dl>

    <pre><a name="today"></a>ADate <b>today</b> ()</pre>
    <dl>
      <dd></p>Returns a date-object	representing the current day.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate&amp;: Current day
</dd></dl></dd>
    </dl>

    <h3><font color="navy">Calculation</font></h4>
    <pre><a name="operator+="></a>ADate& <b>operator+=</b> (const ADate& rhs) </pre>
    <dl>
      <dd><p>Adds another date-value to the date-object. An undefined date is
        treated as "0.0.0"; so only if both objects are undefined, the result
        is (remains) undefined. Overflows (of day or month) are corrected.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>lhs</code>: Value to add<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Self</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator-="></a>ADate& <b>operator-=</b> (const ADate& rhs) </pre>
    <dl>
      <dd><p>Substracts another date-value from the date-object. An undefined date
        is treated as "0.0.0"; the result is (remains) undefined if both
        objects are undefined. Underflows (of day or month) are corrected.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>rhs</code>: Value to substract<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Self</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="operator+"></a>ADate <b>operator+</b> (const ADate& lhs, const ADate& rhs) </pre>
    <dl>
      <dd><p>Adds two date-values and returns the result. An undefined date is
        treated as "0.0.0"; the result is (remains) undefined if both objects
        are undefined. Overflows (of day or month) are corrected.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>lhs</code>: Left-hand-side of addition<dd>
          <dd><code>rhs</code>: Right-hand-side of addition<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate: Result of additon</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator-"></a>ADate <b>operator-</b> (const ADate& lhs, const ADate& rhs) </pre>
    <dl>
      <dd><p>Substracts two date-values and returns the result. An undefined date
        is treated as "0.0.0"; the result is (remains) undefined if both objects
        are undefined. Overflows (of day or month) are corrected.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>lhs</code>: Left-hand-side of substraction<dd>
          <dd><code>rhs</code>: Right-hand-side of substraction<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>ADate: Result of substraction</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="add"></a>ADate& <b>add</b> (signed char Day, signed char Month, int Year) </pre>
    <dl>
      <dd><p>If this is not undefined, the passed values are added (with attention
          to overflows). The result is returned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>day</code>: Day to add<dd>
          <dd><code>month</code>: Month to add year: Year to add<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Self
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>In counterpart to the mathematic operators (+ and -)
          this method does not change the object if it is undefined!
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="sub"></a>ADate& <b>sub</b> (signed char Day, signed char Month, int Year) </pre>
    <dl>
      <dd><p>If this is defined, the passed values are substracted (with
          attention to underflows). The result is returned.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>day</code>: Day to substract<dd>
          <dd><code>month</code>: Month to substract year: Year to substract<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Self
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>In counterpart to the mathematic operators (+ and -)
          this method does not change the object if it is undefined!
</dd></dl></dd>
    </dl>

    <h3><font color="navy">Comparison</font></h4>
    <pre><a name="operator=="></a>bool <b>operator==</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Compares two date-objects and returns true, if they are equal (either
        the same day or both undefined).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>true, if the objects are equal</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operator!="></a>bool <b>operator!=</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Compares two date-objects and returns true, if they are not equal
        (different days and not both undefined).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>true, if the objects are not equal</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operatorl"></a>bool <b>operator&lt;</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Compares two date-objects and returns true, if this is "older" (further
        in the past) than other (e.g. "yesterday" &lt; "today" == true).
        Undefined values are considered as older than any other date.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>true, if this further in the past than other</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operatorg"></a>bool <b>operator&gt;</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Compares two date-objects and returns true, if this is "younger" (later
        on a time-line) than other (e.g. "tomorrow" &gt; "today" == true).
        Undefined values are considered as older than any other date.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>true, if other further in the past than this</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operatorl="></a>bool <b>operator&lt;=</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Compares two date-objects and returns true, if this is "older" (further
        in the past) than other or equal to it (e.g. "yesterday" &lt;= "today"
        == true; two undefined values are also considered as equal).
        Undefined values are considered as older than any other date.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>true, if this further in the past than other or equal</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="operatorg="></a>bool <b>operator&gt;=</b> (const ADate&amp; other)</pre>
    <dl>
      <dd><p>Compares two date-objects and returns true, if this is "younger" (later
        on a time-line) than other or equal to it (e.g. "tomorrow" &gt;= "today"
        == true; two undefined values are also considered as equal).
        Undefined values are considered as older than any other date.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>true, if other further in the past than this or equal</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="compare"></a>long <b>compare</b> (const ADate& other) </pre>
    <dl>
      <dd><p>Returns the (approximated) difference in days between two dates. "Younger dates" (closer to the past) are considered bigger than "older dates" (further in the past; that means the numeric value of the date is compared.<p> If both dates are undefined, those difference is "0", if only this is undefined the result is MINLONG; if other is undefined MAXLONG is returned (-> undefined dates are considered as (very) old).</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>other</code>: Object to compare<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>>0 if this "younger" other; 0 if this == <code>other</code>; <0 else</dd></dl></dd>
    </dl>
    <hr>
    <h3><font color="navy">Utility-functions</font></h4>
    <pre><a name="maxDayOf"></a>char <b>maxDayOf</b> () const</pre>
    <dl>
      <dd><p>Returns the maximal day for month/year of the object.</p></dd>
          <dd>int: Maximal day for the object [28 - 31]
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="maxDayOf2"></a>char <b>maxDayOf</b> (char month, int year) </pre>
    <dl>
      <dd><p>Returns the maximal day for the passed month/year-combination.</p></dd>
      <dd><dl><dt><b>Parameters</b></dt>
          <dd><code>month</code>: Month to check<dd>
          <dd><code>year</code>: Year to check<dd>
      </dl><dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>int: Maximal day for the passed parameters [28 - 31]
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="isLeapYear"></a>bool <b>isLeapYear</b> ()</pre>
    <dl>
      <dd><p>Checks if the year of the object is a leap-year (years which can be divided by 4; except if it is also divideable by 100) Parameters  year: Year to check</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>bool: True, if leap-year
</dd></dl></dd>
    </dl>
    <hr>
    <pre><a name="isLeapYear2"></a>bool <b>isLeapYear</b> (int year) </pre>
    <dl>
      <dd><p>Checks if the passed year is a leap-year (years which can be divided by 4; except if it is also divideable by 100) Parameters  year: Year to check</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>bool: True, if leap-year
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="incDay"></a>void <b>incDay</b> ()</pre><dl>
      <dd><p>Increments the day of the current object with regard of overflows.</p></dd>
    </dl>

    <pre><a name="decDay"></a>void <b>decDay</b> ()</pre>
    <dl>
      <dd><p>Decrements the day of the current object with regard of underflows.</p></dd>
    </dl>

    <pre><a name="minAdapt"></a>bool <b>minAdapt</b> () </pre>
    <dl>
      <dd><p>Corrects the object after an (possible) underflows. If the object is integer after
        the operation, true is returned.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>bool: Flag, if object is integer
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="maxAdapt"></a>bool <b>maxAdapt</b> () </pre>
    <dl>
      <dd><p>Corrects the object after an (possible) overflows. If the object is integer after
        the operation, true is returned.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>bool: Flag, if object is integer
</dd></dl></dd>
    </dl>
    <hr>

    <pre><a name="checkIntegrity"></a>int <b>checkIntegrity</b> () const </pre>
    <dl>
      <dd><p>Checks if this object represents a valid date.</p></dd>
      <dd><dl><dt><b>Returns</b></dt>
          <dd>Status; 0: OK
</dd></dl></dd>
      <dd><dl><dt><b>Remarks</b></dt>
          <dd>Even undefined dates must have valid values!</dd></dl></dd>
    </dl>
    <hr>
    </dl>
  </body>
</html>
